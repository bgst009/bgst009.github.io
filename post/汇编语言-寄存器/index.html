<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>汇编语言-寄存器 | BGST</title>
<link rel="shortcut icon" href="/favicon.ico?v=1611837387648">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?ac5f8e6430f227559918c7ea7f9fd9a7";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

  <meta name="description" content="汇编语言-寄存器" />
  <meta name="keywords" content="归纳" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>BGST</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">适用 Gemini,Pisces 布局,版权说明需配置</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">43</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">16</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">16</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item" style="border-top: 1px dotted #ccc; margin-top: 10px;">
      </div>
    
  
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>
<ul>
<li><a href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8">通用寄存器</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8-cs%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%92%8Cip%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">（地址寄存器）指令寄存器 CS（段地址）和IP（偏移地址）</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">指令的执行过程</a></li>
</ul>
</li>
<li><a href="#debug">debug</a></li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bgst009.github.io/post/汇编语言-寄存器/">
      汇编语言-寄存器
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-02-17</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://bgst009.github.io/tag/9EqYBcXwSl/">
        <span>归纳</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>3分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>520<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="寄存器">寄存器</h1>
<hr>
<ol>
<li>
<p>小例子<br>
1.1 B800：0400 回车<br>
1.2 1空格 1空格<br>
1.3 2空格 2空格<br>
1.4    ...</p>
</li>
<li>
<p>汇编程序员 就是 通过 汇编语言 中的 汇编指令 去修改 寄存器的值 从而 控制 CPU 控制整个计算机</p>
</li>
</ol>
<h2 id="通用寄存器">通用寄存器</h2>
<blockquote>
<p><strong>AX,BX,CX,DX</strong></p>
<ol>
<li>他们各自可分为两个 8 位寄存器(only)<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 9: ax=ah+al$̲$ $$(h==high,l=…'>ax=ah+al$$ $$(h==high,l==low)
</p>
</li>
<li>1 byte = 8 bit(8位寄存器)==字节型数据<br>
2 byte =16 bit(16位寄存器)<mark>字型数据  <code>2个字节</code><br>
一个字型数据</mark>2个字节型数据=高位字节+低位字</li>
<li><strong>数据与寄存器之间 要 保持一致性，8位寄存器给8位数据，16为寄存器给16位数据</strong><br>
<mark>不区</mark>分大小写</li>
</ol>
</blockquote>
<h2 id="地址寄存器指令寄存器-cs段地址和ip偏移地址">（地址寄存器）指令寄存器 CS（段地址）和IP（偏移地址）</h2>
<blockquote>
<p>jmp指令 jmp 2000:0 <mark><mark>&gt; cs</mark>2000,ip</mark>=0;</p>
<blockquote>
<p>mov ax,1000<br>
jmp ax<br>
==&gt; ip=1000;</p>
</blockquote>
<p>只能用jmp指令修改cs,ip</p>
<p>1.CPU从cs:ip 所指的内存单元中读取内容，存取到 指令缓存器当中<br>
2.然后IP跳转到下一个指令位置，并且在执行指令缓存器当中的指令<br>
3.重复1。</p>
<table>
<thead>
<tr>
<th>段地址寄存器</th>
<th>偏移地址寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td>ds（内存）,es,ss（栈）,cs</td>
<td>sp（栈）,bp,si,di,ip,bx</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="指令的执行过程">指令的执行过程</h2>
<ol>
<li>CPU从cs:ip所指向的内存单元 读取 指令 然后 存放到 指令缓存器当中</li>
<li>IP = IP + 所读指令的长度，从而指向下一条指令</li>
<li>执行指令缓存器的内容，回到步骤1</li>
</ol>
<h1 id="debug">debug</h1>
<p><strong>-r 查看和修改寄存器中的内容</strong></p>
<p>-r cs<br>
cs value<br>
enter</p>
<p><strong>-d 查看内存中的内容</strong>  段地址加偏移地址</p>
<blockquote>
<p>-d ss:00</p>
</blockquote>
<p><strong>-v 将机器指令翻译成汇编指令</strong><br>
<strong>-a 以汇编指令的格式 在内存中写入一条汇编指令</strong> 每次debug都的写<br>
<strong>-t 执行当前 cs:ip 所指的机器指令</strong> 代码段<br>
<strong>-e 可以改写 内存中的内容（数据）</strong></p>
<p><strong>-p 快速执行完loop 指令</strong><br>
<em>*-g 地址 ==== 一直执行到 地址 的 位置</em>*</p>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      适用 Gemini,Pisces 布局,版权说明需配置
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://bgst009.github.io/post/汇编语言-寄存器/" title="汇编语言-寄存器">https://bgst009.github.io/post/汇编语言-寄存器/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://bgst009.github.io/tag/9EqYBcXwSl/"># 归纳</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="汇编语言-寄存器（内存访问）" href="https://bgst009.github.io/post/汇编语言-寄存器（内存访问）/">汇编语言-寄存器（内存访问）</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="汇编语言-寄存器（内存访问）" href="https://bgst009.github.io/post/汇编语言-寄存器（内存访问）/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="JDBC课堂笔记" href="https://bgst009.github.io/post/JDBC课堂笔记/">JDBC课堂笔记</a>
        <a class="nav-mobile-next" title="JDBC课堂笔记" href="https://bgst009.github.io/post/JDBC课堂笔记/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-10/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;阅读下面的内容，理解每一个细节，然后构选程序来描述函数指针数组的用法和向函数传函数指针的方法&lt;/p&gt;
&lt;p&gt;关于函数指针&lt;/p&gt;
&lt;p&gt;指针的值是地址，函数指针的值是函数的入口地址&lt;/p&gt;
&lt;p&gt;下面与&lt;code&gt;int&lt;/code&gt;·型变量对比，说明函数指针变量的定义方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int a;&lt;/code&gt;整型变量a&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int*a;&lt;/code&gt;整型指针变量a&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int a(char,char)&lt;/code&gt;;函数&lt;code&gt;a&lt;/code&gt;，函数类型为:返回值为&lt;code&gt;int&lt;/code&gt;，参数为&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int (*a)(char,char);&lt;/code&gt;返回值为&lt;code&gt;int&lt;/code&gt;，参数为 &lt;code&gt;charchar&lt;/code&gt;的函数的函数指针变量a&lt;/p&gt;
&lt;p&gt;可见类型加 &lt;code&gt;*&lt;/code&gt; 则表示指向某种类型的指针。&lt;/p&gt;
&lt;p&gt;为什么&lt;code&gt;int*a&lt;/code&gt;直接加&lt;code&gt;＊&lt;/code&gt;，而&lt;code&gt;int（*a）（char，char）&lt;/code&gt;要用括号？&lt;/p&gt;
&lt;p&gt;如果不加括号&lt;code&gt;:int＊a（char，char）&lt;/code&gt;是返回&lt;code&gt;int＊&lt;/code&gt;的函数。为了不和函数&lt;code&gt;int*a（ char char）&lt;/code&gt;混淆加上括号，&lt;code&gt;int（*a）（char，char&lt;/code&gt;）表示一个指向函数的指针。&lt;/p&gt;
&lt;p&gt;下面与&lt;code&gt;int&lt;/code&gt;型对比，说明函数指针类型的描述方法:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int a;&lt;/code&gt;整型变量a&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int&lt;/code&gt;整型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int (*a)(char,char);&lt;/code&gt;函数指针a&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int (*)(char,char);&lt;/code&gt;函数指针&lt;code&gt;a&lt;/code&gt;返回值为&lt;code&gt;int&lt;/code&gt;型，参数为&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;的函数的函数指针&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;函数指针使用举例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int f(char, char);
main() {
    int a;
    int b;
    long c;
    int (*p)(char, char);

    p = f;
    b = (int)f;
    c = (long)f;

    printf(&amp;quot;main=%x f=%x\n&amp;quot;, main, f);
    printf(&amp;quot;p=%x    b=%x c=%lx\n&amp;quot;, p, b, c);

    a = p(1, 2);
    printf(&amp;quot;%d\n&amp;quot;, a);

    a = ((int (*)(char, char))b)(1, 2);
    printf(&amp;quot;%d\n&amp;quot;, a);
}
int f(char a, char b) { return a + b; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int far f(char, char);
main() {
    int a;
    int b;
    long c;
    int(far * p)(char, char);

    p = f;
    b = (int)f;
    c = (long)f;

    printf(&amp;quot;main offset=%x\n&amp;quot;, main);
    printf(&amp;quot;main=%lx\n&amp;quot;, (long)main);
    printf(&amp;quot;f offset=%x\n&amp;quot;, (int)f);
    printf(&amp;quot;f=%lx\n&amp;quot;, f);
    printf(&amp;quot;p=%lx b=%x c=%lx\n&amp;quot;, p, b, c);

    a = p(1, 2);
    printf(&amp;quot;%d\n&amp;quot;, a);

    a = ((int(far *)(char, char))c)(1, 2);
    printf(&amp;quot;%d\n&amp;quot;, a);
}
int far f(char a, char b) { return a + b; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;向函数传函数指针&#34;&gt;向函数传函数指针&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int add(int a, int b) { return a + b; }
int f2(int (*p)(int, int));
int a;
main() {
    p = add;
    a = f2(p);
    printf(&amp;quot;%d\n&amp;quot;, a);
}
int f2(int (*p)(int, int)) {
    printf(&amp;quot;---------------f2-----------------\n&amp;quot;);
    return p(1, 2) + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201009102929.png&#34; alt=&#34;image-20201009102929141&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数指针数组的用法&#34;&gt;函数指针数组的用法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
int div(int a, int b) { return a / b; }
int f2(int (*p)(int, int));
void f3(int (*p[])(int, int), int);
int (*p)(int, int);
int (*pb[4])(int, int) = {add, sub, mul, div};
int a;
int i;
main() {
    p = add;
    a = f2(p);
    printf(&amp;quot;%d\n&amp;quot;, a);
    f3(pb, 4);
}
int f2(int (*p)(int, int)) {
    printf(&amp;quot;---------------f2-----------------\n&amp;quot;);
    return p(1, 2) + 1;
}
void f3(int (*p[])(int, int), int size) {
    printf(&amp;quot;---------------f3-----------------\n&amp;quot;);
    for (i = 0; i &amp;lt; size; i++) {
        a = p[i](8, 4);
        printf(&amp;quot;%d\n&amp;quot;, a);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201009103102.png&#34; alt=&#34;image-20201009103102619&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
">C语言综合研究与高强度程序设计训练10</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-9/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;写一个函数，&lt;code&gt;showstr（char…）&lt;/code&gt;，打印多个字符串，它可以接收不定数量的char型参&lt;br&gt;
数，最后一个参数可传入0， &lt;code&gt;showstr&lt;/code&gt;通过此可以识别何时停止打印，返回&lt;br&gt;
例子，调用 &lt;code&gt;showstr&lt;/code&gt;在屏幕上打印字符串&lt;code&gt;“This is program＂.“Welcome to＂Hello world！＂&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void showstr(char *, ...);
char *p1 = &amp;quot;This is a c program.&amp;quot;;
char *p2 = &amp;quot;Welcome to c !&amp;quot;;
char *p3 = &amp;quot;Hello world !&amp;quot;;
int i = 0;
main() { showstr(p1, p2, p3, 0); }
void showstr(char *str, ...) {
    for (i = 0; (*(int *)(_BP + 4 + i)) != 0; i += 2) {
        printf(&amp;quot;%s\n&amp;quot;, *(int *)(_BP + 4 + i));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201008130007.png&#34; alt=&#34;image-20201008130007166&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
">C语言综合研究与高强度程序设计训练9</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/1007_-zong-he-yan-jiu-6-7-wen-ti-yan-jiu-bao-gao/"" data-c="
          &lt;h1 id=&#34;综合研究六&#34;&gt;综合研究六&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;了解浮点型数据在内存中是怎么存储的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把双精度的十进制转换为二进制科学计数法然后对应下图存储到内存中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007103509.png&#34; alt=&#34;image-20201007103509309&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设 &lt;code&gt;a=8&lt;/code&gt;则其二进制科学计数法表示为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1.000&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1.000*2^3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,双精度浮点数的存储格式为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;1.&lt;/mn&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1023&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(-1)^s*1.f*2^{e-1023}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,符号位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s=0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,指数位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1026&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;010000000010&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e=1026=0100 0000 0010&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,有效位&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f = 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,故对应的二进制表示为&lt;code&gt;0100 0000 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&lt;/code&gt;十六进制为 &lt;code&gt;40 20 00 00 00 00 00 00 00&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写程序验证&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;double da = 8;
main() {
    int i;
    printf(&amp;quot;double %lf,address %lx,size %d\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));
    for (i = 0; i &amp;lt; sizeof(double); ++i) {
        if (i % 2 == 0)
            printf(&amp;quot;\n&amp;quot;);
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);
        printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;da) + i));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以看到下图结果和预测的一致&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007105359.png&#34; alt=&#34;image-20201007105359297&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一维数组和一级指针区别&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007110810.png&#34; alt=&#34;数组与指针&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int *pi;
int i;
void f();
main() {
    f();
    for (i = 0; i &amp;lt; 10; i++) {
        printf(&amp;quot;%d &amp;quot;, pi[i]);
    }
}
void f() {
    int ia[10];
    for (i = 0; i &amp;lt; 10; i++) {
        ia[i] = i + 1;
        printf(&amp;quot;%d &amp;quot;, ia[i]);
    }
    printf(&amp;quot;\n&amp;quot;);
    for (i = 0; i &amp;lt; 10; i++) {
        printf(&amp;quot;%d &amp;quot;, *(ia + i));
    }
    printf(&amp;quot;\n&amp;quot;);

    pi = ia;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007124701.png&#34; alt=&#34;image-20201007124701011&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过上图可以看到在函数返回后再次打印结果只保存前两个数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C中的延时函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sleep（）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;double start, stop, durationTime;
main() {
    printf(&amp;quot;start\n&amp;quot;);
    start = clock();
    sleep(1 * 2);
    stop = clock();
    printf(&amp;quot;end\n&amp;quot;);
    durationTime = ((double)(stop - start)) / 10;
    printf(&amp;quot;duration %lfs&amp;quot;, durationTime);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007111945.png&#34; alt=&#34;image-20201007111945051&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int型变量（存储一般类型（char、int、long等）变量的地址）和指针变量加一操作的区别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变量加一为值加一，而指针变量加一为指针变量增加变量长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char ca = &#39;a&#39;;
int ia = 6;
long la = 7;
char *pca = &amp;amp;ca;
int *pia = &amp;amp;ia;
long *pla = &amp;amp;la;
main() {
    printf(&amp;quot;char ca: %c , ca+1: %c\n&amp;quot;, ca, ca + 1);
    printf(&amp;quot;int  ia: %d , ia+1: %d\n&amp;quot;, ia, ia + 1);
    printf(&amp;quot;long la: %ld , la+1: %ld\n&amp;quot;, la, la + 1);
    printf(&amp;quot;size\n&amp;quot;);
    printf(&amp;quot;char %d,int %d,long %d\n&amp;quot;, sizeof(char), sizeof(int), sizeof(long));
    printf(&amp;quot;pchar pca: %x , pca+1: %x\n&amp;quot;, pca, pca + 1);
    printf(&amp;quot;pint pia: %x , pia+1: %x\n&amp;quot;, pia, pia + 1);
    printf(&amp;quot;plong pla: %x , pla+1: %x\n&amp;quot;, pla, pla + 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007113030.png&#34; alt=&#34;image-20201007113030495&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;综合研究7&#34;&gt;综合研究7&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;了解C语言中的输入函数（写程序验证不同输入函数功能上的区别）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;kbhit()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main() {
    char ch;
    //检查当前是否有键盘输入，若有则返回一个非0值，否则返回0
    while (!kbhit()) {
        cprintf(&amp;quot;hello world\n&amp;quot;);
        sleep(1);
        if (kbhit()) {
            ch = getch();
            if (ch == 27)//ESE
                break;
        }
    }
    cprintf(&amp;quot;end\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007130341.png&#34; alt=&#34;image-20201007130341728&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bioskey&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f2() {
    int a;
    /* 当用户再循环时不按下任何键时，bioskey(1) 一直为0，则 !bioskey(1)
     * 为1，条件成立，继续循环，printf（），直到，用户任意按下一个键时，bioskey(1)不为0，成功退出。
     */
    a = 1;
    while (!bioskey(a)) {
        cprintf(&amp;quot;biosKey\n&amp;quot;);
        sleep(1);
    }
    cprintf(&amp;quot;end\n&amp;quot;);

    /*  当cmd是0，bioskey()返回下一个在键盘键入的值（它将等待到按下一个键）。
     *  它返回一个16位的二进制数，包括两个不同的值。当按下一个普通键时，
     * 它的低8位数存放该字符的ASCII码,高8位存放该键的扫描码；对于特殊键（如方向键、F1～F12等等），
     * 低8位为0，高8位字节存放该键的扫描码。
     */
    a = 0;
    printf(&amp;quot;\n%c\n&amp;quot;, bioskey(0));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007131456.png&#34; alt=&#34;image-20201007131455820&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f3() {
    int a, b, c, d;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);           /*输入整数并赋值给变量a */
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;b);           /* 输入整数并赋值给变量b */
    printf(&amp;quot;a+b=%d\n&amp;quot;, a + b); /* 计算a+b的值 */
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;c, &amp;amp;d);    /* 输入两个整数并分别赋值给c、d */
    printf(&amp;quot;c*d=%d\n&amp;quot;, c * d); /* 计算c*d的值 */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007131934.png&#34; alt=&#34;image-20201007131934192&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getche()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f4(){
    char c;
    c = getche();
    printf(&amp;quot;c=&#39;%c&#39;\n&amp;quot;, c);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007132418.png&#34; alt=&#34;image-20201007132418853&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;getch&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f5() {
    char c = getch();
    printf(&amp;quot;c=&#39;%c&#39;\n&amp;quot;, c);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;​	&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007132728.png&#34; alt=&#34;image-20201007132728673&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gets&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f6() {
    /* gets() 会读取用户输入的整行内容，包括空格。而 scanf()
     * 遇到空格就结束读取，也就是说，使用 scanf()
     * 读取的字符串中永远不会包含空格。 */
    char str1[30], str2[30]; /* 定义两个字符数组 */
    gets(str1);
    scanf(&amp;quot;%s&amp;quot;, str2);
    puts(str1);
    puts(str2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007133158.png&#34; alt=&#34;image-20201007133158613&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">1007_综合研究6-7问题研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-8/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;（1）定义一个描述学生成绩的数据类型:&lt;br&gt;
&lt;code&gt;struct stu｛ unsigned char c； unsigned char os； unsigned char masm； unsigned char java； struct stu far ＊next； ｝&lt;/code&gt;&lt;br&gt;
&lt;code&gt;struct stu&lt;/code&gt;型数据的前四个数据项存储学生的几门课程的成绩；数据项&lt;code&gt;next&lt;/code&gt;存储下一个学生成绩的地址。&lt;br&gt;
（2）定义一个数组: &lt;code&gt;struct stu［375］&lt;/code&gt;；&lt;br&gt;
（3）将内存0:0处的3000个数据当作375个 struct stu型的数据，将它们的c、os、masmjava数据项的内容拷贝到数组a的对应数据项中。&lt;br&gt;
（4）查找数组a中课程成绩总分小于400大于200的数据，用next数据项将它们连接起来。（5）将连接起来的数据打印出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct stu {
    unsigned char c;
    unsigned char os;
    unsigned char masm;
    unsigned char java;
    struct stu *next;
};

int n;
struct stu a[375];
struct stu *s;
int sum;
main() {
    long address = 0x00000000;

    for (n = 0; n &amp;lt; 375; n++) {
        a[n].c = *(char far *)address++;
        a[n].os = *(char far *)address++;
        a[n].masm = *(char far *)address++;
        a[n].java = *(char far *)address++;
    }

    s-&amp;gt;next = 0;
    for (n = 0; n &amp;lt; 375; n++) {
        if (a[n].c + a[n].os + a[n].masm + a[n].java &amp;lt; 400 &amp;amp;&amp;amp;
            a[n].c + a[n].os + a[n].masm + a[n].java &amp;gt; 200) {
            a[n].next = s-&amp;gt;next;
            s-&amp;gt;next = &amp;amp;a[n];
        }
    }

    n = 0;
    while (s-&amp;gt;next) {
        s = s-&amp;gt;next;
        if (!s)
            break;
        printf(&amp;quot;%d: &amp;quot;, ++n);
        sum = s-&amp;gt;c + s-&amp;gt;os + s-&amp;gt;masm + s-&amp;gt;java;
        printf(&amp;quot;c: %c,os: %c,masm: %c,java: %c,sum: %d\n&amp;quot;, s-&amp;gt;c, s-&amp;gt;os, s-&amp;gt;masm,
               s-&amp;gt;java, sum);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201005181125.png&#34; alt=&#34;image-20201005181125417&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">C语言综合研究与高强度程序8</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-7/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;写一个程序，进行如下工作:&lt;br&gt;
（1）从内存偏移地址2000h处开始，读取偏移地址n处的整型数据d，按照如下格式打印&lt;br&gt;
偏移地址n数据d&lt;br&gt;
（2）将数据d当作新的偏移地址n，读取偏移地址n处的整型数据d按照上面的格式打印。直到偏移地址为xff为，或用户从键盘输入字符“q”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1&#34;&gt;1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int n = 0x2000;
int c;
int t;
main() {
    while (n != 0xffff &amp;amp;&amp;amp; c != &#39;q&#39;) {
        printf(&amp;quot;offset address %xh -&amp;gt; data %c\n&amp;quot;, n, *(char *)n);
        printf(&amp;quot;stop input q: &amp;quot;);
        scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);
        printf(&amp;quot;\ninput n: &amp;quot;);
        scanf(&amp;quot;%x&amp;quot;, &amp;amp;t);
        n += t;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201005123641.png&#34; alt=&#34;image-20201005123640831&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2&#34;&gt;2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;b.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int n = 0x2000;
int c;
int t;
main() {
    while (n != 0xffff &amp;amp;&amp;amp; c != &#39;q&#39;) {
        printf(&amp;quot;offset address %xh -&amp;gt; data %c\n&amp;quot;, n, *(int *)n);

        printf(&amp;quot;stop input q: &amp;quot;);
        scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);

        printf(&amp;quot;\ninput n: &amp;quot;);
        scanf(&amp;quot;%x&amp;quot;, &amp;amp;t);
        t += n;
        n += *(int *)t;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201005124652.png&#34; alt=&#34;image-20201005124652055&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
">C语言综合研究与高强度程序设计训练7</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/1003_-zong-he-yan-jiu-4-5-bu-chong-yan-jiu-bao-gao/"" data-c="
          &lt;h1 id=&#34;4&#34;&gt;4&lt;/h1&gt;
&lt;h2 id=&#34;1&#34;&gt;1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;了解tlib如何生成list文件，查看list文件中是什么内容？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过查看使用说明尝试生成list文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003183838.png&#34; alt=&#34;image-20201003183838110&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过生成的&lt;mark&gt;CSLISTFI.LST&lt;/mark&gt;可以看到文件中包含着标号，大小，但不知道标号是&lt;mark&gt;obj&lt;/mark&gt;文件的名称还是其中的函数名称故通过自己的 c 文件生成&lt;mark&gt;obj&lt;/mark&gt;然后加入&lt;mark&gt;cs.lib&lt;/mark&gt;中来进行验证&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;生成的list文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Publics by module

ABS     	size = 16
	_abs                            

ABSREAD 	size = 76
	_absread                          _abswrite

ACCESS  	size = 57
	_access                         

ALLOCMEM	size = 36
	_allocmem                       

ATEXIT  	size = 104
	__atexitcnt                       __atexittbl
	_atexit                         

ATOL    	size = 128
    .............
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;test.c&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int t1(int a, int b) {
    int c;
    c = a + b;
    return c;
}
int t2(int a, int b) {
    int c;
    c = a - b;
    return c;
}
int t3(int a, int b) { return a + b + 1; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003185025.png&#34; alt=&#34;image-20201003185025478&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 &lt;mark&gt;cslsitfile&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以看到标号为obj文件的名称，大小的obj文件的大小，带下划线的为函数名&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003185310.png&#34; alt=&#34;image-20201003185310200&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2&#34;&gt;2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;使用tlib进行操作时，会进行检测。写程序测试是检测函数名、obj文件名，还是两个都检测？如果都检测，那先检测哪一个？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;紧接着在添加完test.obj后重新写一个不一样的test.c生成obj并加入cs.lib可以看到添加失败可以看到如果obj名称一致尽管函数名不一致也会添加失败&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不一样的test.c&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int f3(int a, int b) { return a + b + 1; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003190042.png&#34; alt=&#34;image-20201003190042310&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后将test.c的obj文件拷贝重命名然后在添加到cs.lib中，可以看到虽然obj文件名不一致tlib还检查函数名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003200900.png&#34; alt=&#34;image-20201003200721444&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过以上可以看出tlib会对函数名和obg文件名进行检查，现在接着将原始的test.obj再加入cslib中tlib会提示obj文件名一致添加失败，所以tlib先检查obj文件名然后检查函数名&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003201631.png&#34; alt=&#34;image-20201003201631248&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3&#34;&gt;3&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;将同一个.obj文件放入cs.lib和maths.lib中，会从哪个中取该文件中的函数？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;稍微修改一下test.c然后再生成obj加入maths.lib&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;test.c&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int t1(int a, int b) {
+   int c = 9;
    c = a + b;
    return c;
}
int t2(int a, int b) {
+    int c = 8;
    c = a - b;
    return c;
}
int t3(int a, int b) { return a + b + 1; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003202038.png&#34; alt=&#34;image-20201003202038759&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写测试程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;main.c&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CQL&#34;&gt;main() {
    int a = 1;
    int b = 2;
    int c;
    c = t1(a, b);
    printf(&amp;quot;c = %d&amp;quot;, c);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;debug查看生成的可执行文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以看出会从maths.lib中去函数&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003202551.png&#34; alt=&#34;image-20201003202550847&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">1003_综合研究4-5补充研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/02020930_-zong-he-yan-jiu-6-yan-jiu-bao-gao/"" data-c="
          &lt;h2 id=&#34;1&#34;&gt;1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）写一个C程序，打印int、long、 double型变量所占的字节数、地址、各个字节的地址和内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int ia = 6;
long la = 7;
double da = 8;
main() {
    int i;
    printf(&amp;quot;int %d          ,address %lx,size %d\n&amp;quot;, ia, (long)&amp;amp;ia,
           sizeof(int));
    for (i = 0; i &amp;lt; sizeof(int); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;ia + i);
        printf(&amp;quot;value  %d &amp;quot;, *((&amp;amp;ia) + i));
    }
    printf(&amp;quot;\n&amp;quot;);

    printf(&amp;quot;long %ld         ,address %lx,size %d\n&amp;quot;, la, (long)&amp;amp;la,
           sizeof(long));
    for (i = 0; i &amp;lt; sizeof(long); ++i) {
        if (i % 2 == 0)
            printf(&amp;quot;\n&amp;quot;);
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;la + i);
        printf(&amp;quot;value  %ld &amp;quot;, *((&amp;amp;la) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;double %lf,address %lx,size %d\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));
    for (i = 0; i &amp;lt; sizeof(double); ++i) {
        if (i % 2 == 0)
            printf(&amp;quot;\n&amp;quot;);
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);
        printf(&amp;quot;value  %lf &amp;quot;, *((&amp;amp;da) + i));
    }
}int ia = 6;
long la = 7;
double da = 8;
main() {
    int i;
    printf(&amp;quot;int %d          ,address %lx,size %d\n&amp;quot;, ia, (long)&amp;amp;ia,
           sizeof(int));
    for (i = 0; i &amp;lt; sizeof(int); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;ia + i);
        printf(&amp;quot;value  %d &amp;quot;, *((&amp;amp;ia) + i));
    }
    printf(&amp;quot;\n&amp;quot;);

    printf(&amp;quot;long %ld         ,address %lx,size %d\n&amp;quot;, la, (long)&amp;amp;la,
           sizeof(long));
    for (i = 0; i &amp;lt; sizeof(long); ++i) {
        if (i % 2 == 0)
            printf(&amp;quot;\n&amp;quot;);
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;la + i);
        printf(&amp;quot;value  %ld &amp;quot;, *((&amp;amp;la) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;double %lf,address %lx,size %d\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));
    for (i = 0; i &amp;lt; sizeof(double); ++i) {
        if (i % 2 == 0)
            printf(&amp;quot;\n&amp;quot;);
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);
        printf(&amp;quot;value  %lf &amp;quot;, *((&amp;amp;da) + i));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200930184753.png&#34; alt=&#34;image-20200930184753489&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修正&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int ia = 6;
long la = 7;
double da = 8;
main() {
    int i;
    /*     printf(&amp;quot;%x %x %x %x\n&amp;quot;, &amp;amp;ia, ((int)(&amp;amp;ia) + 1), (char *)((char)(&amp;amp;ia) +
     *1), (char *)((char)(&amp;amp;ia) + 1)); */
    printf(&amp;quot;int %d          ,address %lx,size %d\n&amp;quot;, ia, (long)&amp;amp;ia,
           sizeof(int));
    for (i = 0; i &amp;lt; sizeof(int); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;ia + i);
 +       printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;ia) + i));
    }
    printf(&amp;quot;\n&amp;quot;);

    printf(&amp;quot;long %ld         ,address %lx,size %d\n&amp;quot;, la, (long)&amp;amp;la,
           sizeof(long));
    for (i = 0; i &amp;lt; sizeof(long); ++i) {
        if (i % 2 == 0)
            printf(&amp;quot;\n&amp;quot;);
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;la + i);
+        printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;la) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;double %lf,address %lx,size %d\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));
    for (i = 0; i &amp;lt; sizeof(double); ++i) {
        if (i % 2 == 0)
            printf(&amp;quot;\n&amp;quot;);
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);
+        printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;da) + i));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007094453.png&#34; alt=&#34;image-20201007094453071&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2&#34;&gt;2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;（2）写一个C程序，打印stu型变量所占的字节数、地址、各数据项地址、内容和各个字节的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  typedef struct
  {
  int num；
  unsigned char c；
  unsigned char osi
  unsigned char masm；
  char name［20］
  }stu；
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;提示:研究 sizeof的用法；可将任何一个变量的存储空间，看做一个数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {
    int num;
    unsigned char c;
    unsigned char os;
    unsigned char masm;
    char name[20];
} stu;

main() {
    int i = 0;
    stu s;
    s.num = 9;
    s.c = &#39;1&#39;;
    s.os = &#39;2&#39;;
    s.masm = &#39;3&#39;;
    s.name[0] = &#39;L&#39;;
    s.name[1] = &#39;i&#39;;
    s.name[2] = &#39;L&#39;;
    s.name[3] = &#39;\0&#39;;

    printf(&amp;quot;size: %d,address: %lx\n&amp;quot;, sizeof(s), (long)&amp;amp;s);
    printf(&amp;quot;num :    %d,address: %lx\n&amp;quot;, s.num, (long)&amp;amp;(s.num));
    for (i = 0; i &amp;lt; sizeof(int); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.num) + i);
        printf(&amp;quot;value  %d &amp;quot;, *(&amp;amp;(s.num) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;c   :    %c,address: %lx\n&amp;quot;, s.c, (long)&amp;amp;(s.c));
    for (i = 0; i &amp;lt; sizeof(char); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.c) + i);
        printf(&amp;quot;value  %c &amp;quot;, *(&amp;amp;(s.c) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;os  :    %c,address: %lx\n&amp;quot;, s.os, (long)&amp;amp;(s.os));
    for (i = 0; i &amp;lt; sizeof(char); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.os) + i);
        printf(&amp;quot;value  %c &amp;quot;, *(&amp;amp;(s.os) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;masm:    %c,address: %lx\n&amp;quot;, s.masm, (long)&amp;amp;(s.masm));
    for (i = 0; i &amp;lt; sizeof(char); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.masm) + i);
        printf(&amp;quot;value  %c &amp;quot;, *(&amp;amp;(s.masm) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;name:  %s,address: %lx\n&amp;quot;, s.name, (long)&amp;amp;(s.name));
    /* printf(&amp;quot;%d&amp;quot;, sizeof(char *)); */
    for (i = 0; i &amp;lt; 20; i++) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.name) + i);
        printf(&amp;quot;value  %c &amp;quot;, *((*(&amp;amp;s.name)) + i));
    }
    printf(&amp;quot;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200930193943.png&#34; alt=&#34;image-20200930193943568&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修正&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;b.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {
    int num;
    unsigned char c;
    unsigned char os;
    unsigned char masm;
    char name[20];
} stu;

char *cp;

main() {
    int i = 0;
    stu s;
    s.num = 9;
    s.c = &#39;1&#39;;
    s.os = &#39;2&#39;;
    s.masm = &#39;3&#39;;
    s.name[0] = &#39;L&#39;;
    s.name[1] = &#39;i&#39;;
    s.name[2] = &#39;L&#39;;
    s.name[3] = &#39;\0&#39;;

    printf(&amp;quot;size: %d,address: %lx\n&amp;quot;, sizeof(s), (long)&amp;amp;s);
    printf(&amp;quot;num :    %d,address: %lx\n&amp;quot;, s.num, (long)&amp;amp;(s.num));
    for (i = 0; i &amp;lt; sizeof(int); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.num) + i);
        cp = (char *)((int)&amp;amp;(s.num) + i);
        printf(&amp;quot;value  %d &amp;quot;, *cp);
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;c   :    %c,address: %lx\n&amp;quot;, s.c, (long)&amp;amp;(s.c));
    for (i = 0; i &amp;lt; sizeof(char); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.c) + i);
        cp = (char *)((int)&amp;amp;(s.c) + i);
        printf(&amp;quot;value  %c &amp;quot;, *cp);
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;os  :    %c,address: %lx\n&amp;quot;, s.os, (long)&amp;amp;(s.os));
    for (i = 0; i &amp;lt; sizeof(char); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.os) + i);
        cp = (char *)((int)&amp;amp;(s.os) + i);
        printf(&amp;quot;value  %c &amp;quot;, *cp);
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;masm:    %c,address: %lx\n&amp;quot;, s.masm, (long)&amp;amp;(s.masm));
    for (i = 0; i &amp;lt; sizeof(char); ++i) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.masm) + i);
        cp = (char *)((int)&amp;amp;(s.masm) + i);
        printf(&amp;quot;value  %c &amp;quot;, *cp);
    }
    printf(&amp;quot;\n&amp;quot;);
    printf(&amp;quot;name:  %s,address: %lx\n&amp;quot;, s.name, (long)&amp;amp;(s.name));
    /* printf(&amp;quot;%d&amp;quot;, sizeof(char *)); */
    for (i = 0; i &amp;lt; 20; i++) {
        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.name) + i);
        cp = (char *)((int)&amp;amp;(s.name) + i);
        printf(&amp;quot;value  %c &amp;quot;, *cp);
    }
    printf(&amp;quot;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007095106.png&#34; alt=&#34;image-20201007095106825&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3&#34;&gt;3&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;（3）写一个程序，这个程序的运行结果反映如下主题参数的存储空间与局部变量的存储空间，在函数运行后收回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;long *f(int a);
long res[2];
long p;
long l;
main() {
    long *a = f(5);
    p = a[0];
    l = a[1];

    printf(&amp;quot;parm  %d ,address %lx\n&amp;quot;, *(long *)a[0], p);
    printf(&amp;quot;local %d ,address %lx\n&amp;quot;, *(long *)a[1], l);
}

long *f(int parm) {
    int local = 1;
    local += parm;
    printf(&amp;quot;parm  %d address %lx\n&amp;quot;, parm, (long)&amp;amp;parm);
    printf(&amp;quot;local %d address %lx\n&amp;quot;, local, (long)&amp;amp;local);

    res[0] = (long)&amp;amp;parm;
    res[1] = (long)&amp;amp;local;

    /*     printf(&amp;quot;parm %d ,address %lx\n&amp;quot;, *(long *)res[0], res[0]);
        printf(&amp;quot;parm %d ,address %lx\n&amp;quot;, *(long *)res[1], res[1]); */
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200930213929.png&#34; alt=&#34;image-20200930213929300&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修正&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;long *f(int a);
long res[2];

main() {
    f(5);
    printf(&amp;quot;============\n&amp;quot;);
    f(8);
}

long *f(int parm) {
    int local = 1;
    local += parm;

    printf(&amp;quot;parm  %d address %lx\n&amp;quot;, parm, (long)&amp;amp;parm);
    printf(&amp;quot;local %d address %lx\n&amp;quot;, local, (long)&amp;amp;local);

    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007095242.png&#34; alt=&#34;image-20201007095242216&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">02020930_综合研究6研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/0929_-zong-he-yan-jiu-5-yan-jiu-bao-gao/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;用&lt;mark&gt;debug&lt;/mark&gt; 对一下程序进行分析，记录每一条c语句运行后，相关内存单元的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ac&#34;&gt;a.c&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;注意理解指针的机制，“**” 和 “&amp;amp;” 运算的意义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char ch;
char *p;
char **pa;
char far *pf;
int n;

main() {
    p = (unsigned char *)0x1000;
    ch = *(unsigned char *)0x1000 + *p + *(unsigned char far *)0x200;

    p = &amp;amp;ch;

    *p = *p + 1;

    pa = &amp;amp;p;
    **pa = **pa + 1;

    pf = (char far *)&amp;amp;ch;
    *pf = *pf + 1;

    n = (int)&amp;amp;ch;
    *(char *)n = *(char *)n + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一句 &lt;code&gt;p = (unsigned char *)0x1000;&lt;/code&gt;p在数据段中偏移地址为&lt;mark&gt;01af&lt;/mark&gt;然后看内存中的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*mov	word ptr DGROUP:_p,4096*/
    p = (unsigned char *)0x1000;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114715.png&#34; alt=&#34;image-20200929114715440&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114758.png&#34; alt=&#34;image-20200929114758733&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二句 &lt;code&gt;ch = *(unsigned char *)0x1000 + *p + *(unsigned char far *)0x200;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*
        mov	al,byte ptr [4096]
        mov	bx,word ptr DGROUP:_p
        add	al,byte ptr [bx]
        xor	bx,bx
        mov	es,bx
        mov	bx,512
        add	al,byte ptr es:[bx]
        mov	byte ptr DGROUP:_ch,al
    */
    ch = *(unsigned char *)0x1000 + *p + *(unsigned char far *)0x200;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114830.png&#34; alt=&#34;image-20200929114830832&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114933.png&#34; alt=&#34;image-20200929114933614&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三句 &lt;code&gt;p = &amp;amp;ch;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*                      [01af]            01a8*/
    /*mov	word ptr DGROUP:_p,offset DGROUP:_ch*/
    p = &amp;amp;ch;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115117.png&#34; alt=&#34;image-20200929115116923&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四句 &lt;code&gt;*p = *p + 1;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*
        mov	bx,word ptr DGROUP:_p
        mov	al,byte ptr [bx]
        inc	al
        mov	bx,word ptr DGROUP:_p
        mov	byte ptr [bx],al
    */
    *p = *p + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115201.png&#34; alt=&#34;image-20200929115201697&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到p指向的内存中的值增加一&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115239.png&#34; alt=&#34;image-20200929115238797&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第五句 &lt;code&gt;pa = &amp;amp;p;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*                ds:[01a6]         01af
    mov	word ptr DGROUP:_pa,offset DGROUP:_p
    */
    pa = &amp;amp;p;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115547.png&#34; alt=&#34;image-20200929115547139&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第六句 &lt;code&gt;**pa = **pa + 1;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*
        mov	bx,word ptr DGROUP:_pa
        mov	bx,word ptr [bx]
        mov	al,byte ptr [bx]
        inc	al
        mov	bx,word ptr DGROUP:_pa
        mov	bx,word ptr [bx] bx=01a6
        mov	byte ptr [bx],al
    */
    **pa = **pa + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115644.png&#34; alt=&#34;image-20200929115644803&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到p指向的内存中的值增加一&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115712.png&#34; alt=&#34;image-20200929115711875&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第七句 &lt;code&gt;pf = (**char** far *)&amp;amp;ch;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*                  01ad
        mov	word ptr DGROUP:_pf+2,ds
                        [01a8]              01a8
        mov	word ptr DGROUP:_pf,offset DGROUP:_ch
    */
    pf = (char far *)&amp;amp;ch;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115906.png&#34; alt=&#34;image-20200929115906423&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到pf存在的是&lt;mark&gt;ch&lt;/mark&gt;的地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120128.png&#34; alt=&#34;image-20200929120128258&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第八句 &lt;code&gt;*pf = *pf + 1;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*
        les	bx,dword ptr DGROUP:_pf
        mov	al,byte ptr es:[bx]
        inc	al
        les	bx,dword ptr DGROUP:_pf
        mov	byte ptr es:[bx],al
    */
    *pf = *pf + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120436.png&#34; alt=&#34;image-20200929120436617&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到p指向的内存中的值增加一&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120344.png&#34; alt=&#34;image-20200929120344832&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第九句 &lt;code&gt;n = (**int**)&amp;amp;ch;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*                      01a8
        mov	ax,offset DGROUP:_ch
                        01a9
        mov	word ptr DGROUP:_n,ax
    */
    n = (int)&amp;amp;ch;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120603.png&#34; alt=&#34;image-20200929120603717&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120647.png&#34; alt=&#34;image-20200929120647507&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第十句 &lt;code&gt;*(**char** *)n = *(**char** *)n + 1;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    /*
        mov	bx,word ptr DGROUP:_n
        mov	al,byte ptr [bx]
        inc	al
        mov	bx,word ptr DGROUP:_n
        mov	byte ptr [bx],al
    */
    *(char *)n = *(char *)n + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120716.png&#34; alt=&#34;image-20200929120716356&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120800.png&#34; alt=&#34;image-20200929120800531&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上可以看出&lt;code&gt;*p&lt;/code&gt;的功能是取出以&lt;code&gt;p&lt;/code&gt;中数据作为偏移地址的内存中的值，&lt;code&gt;&amp;amp;p&lt;/code&gt;的功能就是取出&lt;code&gt;p&lt;/code&gt;的偏移地址&lt;/p&gt;
&lt;h2 id=&#34;bc&#34;&gt;b.c&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;注意理解 struct指针的用法，指针“＋”运算的意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {
    int number;
    char c;
    char name[8];
} stu;

stu a;

char *pchar;
int *pint;
stu *pstu;

main() {
    pstu = &amp;amp;a;

    pstu-&amp;gt;number = 1;
    (*pstu).c = 80;
    pstu-&amp;gt;name[0] = &#39;T&#39;;
    pstu-&amp;gt;name[1] = &#39;o&#39;;
    (*pstu).name[2] = &#39;m&#39;;
    (*pstu).name[3] = &#39;0&#39;;

    pchar = 0;
    pint = 0;
    pstu = 0;

    pchar = pchar + 1;
    pint = pint + 1;
    pstu = pstu + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过汇编代码可以得出不论是指针的&lt;code&gt;-&amp;gt;&lt;/code&gt; 运算和&lt;code&gt;.&lt;/code&gt; 运算最后翻译成的汇编都是把&lt;code&gt;stu&lt;/code&gt; 的首地址传给&lt;code&gt;bx&lt;/code&gt;然后通过&lt;code&gt;bx&lt;/code&gt;加上偏移来访问结构体变量的真正内存地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929111437.png&#34; alt=&#34;image-20200929111437771&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929111851.png&#34; alt=&#34;image-20200929111851178&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符型指针加一就把指针内存中的数据增加一，整形指针加一就把指针内存中的数据增加二，结构体指针加一就是把指针内存中的数据增加结构体中各个变量长度总和。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929112528.png&#34; alt=&#34;image-20200929112528048&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cc&#34;&gt;c.c&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;将字符串“hello world！”分别拷贝到从0:200、:210起始的内存中:将数组a分别拷贝到0:220、0:230起始的内存中。&lt;/p&gt;
&lt;p&gt;注意理解“［］”运算的意义及数组名与指针的关系。&lt;/p&gt;
&lt;p&gt;假设p是一个指针，p［n］的意义等同于＊（p＋n）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char *p;
char far *pf;
char str[20] = &amp;quot;hello world!&amp;quot;;
int a[8] = {11, 22, 33, 44, 55, 66, 77, 88};
int n;

main() {
    pf = (char far *)0x200;
    for (n = 0; str[n]; n++)
        *(pf + n) = str[n];

    p = str;
    pf = (char far *)0x210;
    for (n = 0; p[n]; n++)
        pf[n] = *(str + n);

    for (n = 0; n &amp;lt; 8; n++)
        ((int far *)0x220)[n] = *(a + n);
    for (n = 0; n &amp;lt; 8; n++)
        *(int far *)(0x230 + n * 2) = *(&amp;amp;a[0] + n);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
	mov	word ptr DGROUP:_pf+2,0
	mov	word ptr DGROUP:_pf,512
*/
pf = (char far *)0x200;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929122947.png&#34; alt=&#34;image-20200929122947409&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
;	?debug	L 9		[01ca]
	mov	word ptr DGROUP:_n,0
	jmp	short @5
@4:
;	?debug	L 10
	mov	bx,word ptr DGROUP:_n ;[01ca]
	mov	al,byte ptr DGROUP:_str[bx] ;[bx+0194]
	les	bx,dword ptr DGROUP:_pf
	add	bx,word ptr DGROUP:_n
	mov	byte ptr es:[bx],al
@3:
	inc	word ptr DGROUP:_n
@5:					[01ca]
	mov	bx,word ptr DGROUP:_n
	cmp	byte ptr DGROUP:_str[bx],0
	jne	@4
*/
for (n = 0; str[n]; n++)
	*(pf + n) = str[n];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化后&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123634.png&#34; alt=&#34;image-20200929123634814&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*					01d0				0194
	mov	word ptr DGROUP:_p,offset DGROUP:_str
*/
p = str;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123821.png&#34; alt=&#34;image-20200929123821356&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123859.png&#34; alt=&#34;image-20200929123859645&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
	mov	word ptr DGROUP:_pf+2,0
	mov	word ptr DGROUP:_pf,528
*/

pf = (char far *)0x210;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123930.png&#34; alt=&#34;image-20200929123929928&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123957.png&#34; alt=&#34;image-20200929123957303&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
;	?debug	L 14
	mov	word ptr DGROUP:_n,0
	jmp	short @9
@8:
;	?debug	L 15
	mov	bx,word ptr DGROUP:_n
	mov	al,byte ptr DGROUP:_str[bx]
	les	bx,dword ptr DGROUP:_pf
	add	bx,word ptr DGROUP:_n
	mov	byte ptr es:[bx],al
@7:
	inc	word ptr DGROUP:_n
@9:
	mov	bx,word ptr DGROUP:_p
	add	bx,word ptr DGROUP:_n
	cmp	byte ptr [bx],0
	jne	@8
*/
for (n = 0; p[n]; n++)
        pf[n] = *(str + n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拷贝hello world从0:200 -&amp;gt; 0:210&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929124213.png&#34; alt=&#34;image-20200929124213070&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
@6:
;	?debug	L 17
	mov	word ptr DGROUP:_n,0
	jmp	short @13
@12:
;	?debug	L 18
	mov	bx,word ptr DGROUP:_n
	shl	bx,1
	mov	ax,word ptr DGROUP:_a[bx]
	mov	dx,word ptr DGROUP:_n
	shl	dx,1
	xor	bx,bx
	mov	es,bx
	mov	bx,544
	add	bx,dx
	mov	word ptr es:[bx],ax
@11:
	inc	word ptr DGROUP:_n
@13:
	cmp	word ptr DGROUP:_n,8
	jl	@12
*/
for (n = 0; n &amp;lt; 8; n++)
        ((int far *)0x220)[n] = *(a + n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929124433.png&#34; alt=&#34;image-20200929124433711&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
@10:
;	?debug	L 19
	mov	word ptr DGROUP:_n,0
	jmp	short @17
@16:
;	?debug	L 20
	mov	bx,word ptr DGROUP:_n
	shl	bx,1
	mov	ax,word ptr DGROUP:_a[bx]
	push	ax
	mov	ax,word ptr DGROUP:_n
	shl	ax,1
	add	ax,560
	cwd	
	mov	bx,ax
	mov	es,dx
	pop	ax
	mov	word ptr es:[bx],ax
@15:
	inc	word ptr DGROUP:_n
@17:
	cmp	word ptr DGROUP:_n,8
	jl	@16
*/
for (n = 0; n &amp;lt; 8; n++)
        *(int far *)(0x230 + n * 2) = *(&amp;amp;a[0] + n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拷贝a从0:220-&amp;gt;0:230&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929124530.png&#34; alt=&#34;image-20200929124530273&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;综上&lt;code&gt;p[n]&lt;/code&gt;的意思是访问以&lt;code&gt;p&lt;/code&gt;为基地址&lt;code&gt;n&lt;/code&gt;为偏移地址中的数据，数组名&lt;code&gt;p&lt;/code&gt;和指针&lt;code&gt;*p&lt;/code&gt;存储的都是数据的起始地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">0929_综合研究5研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/0928_-zong-he-yan-jiu-1-3-bu-chong-yan-jiu-bao-gao/"" data-c="
          &lt;h2 id=&#34;综合研究2&#34;&gt;综合研究2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过函数名直接打印出段地址和偏移地址（不使用_CS）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过查阅相关资料可以尝试把函数名前强制转换成长整型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a;
void f1(void) { a = 1; }
void f2(void) { a = 2; }
void f3(void) { a = 3; }
main() {
    char *string = &amp;quot;--------------------&amp;quot;;
    printf(&amp;quot;\nCS: %x\n&amp;quot;, _CS);
    printf(&amp;quot;%s&amp;quot;, string);
    printf(&amp;quot;\nf1: %lx\n&amp;quot;, (long)f1);
    printf(&amp;quot;\nf2: %lx\n&amp;quot;, (long)f2);
    printf(&amp;quot;\nf3: %lx\n&amp;quot;, (long)f3);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928070215.png&#34; alt=&#34;image-20200928070215176&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过&lt;code&gt;cs&lt;/code&gt;输出的数字可以检验出 强制转换可以正确输出函数对应的段地址和偏移地址。&lt;/p&gt;
&lt;h2 id=&#34;综合研究3&#34;&gt;综合研究3&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;写程序验证全局变量存储空间是加载时分配，还是c0s分配。	@未解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编写测试程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int b = 9;
main() {
    static int a = 8;
    a++;
    b++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译链接生成可执行程序通过debug查看变量在数据段的偏移地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928071005.png&#34; alt=&#34;image-20200928071005129&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以看见存储全局变量的段地址和偏移地址，然后在重新debug后直接跳转到相应的位置查看&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928071303.png&#34; alt=&#34;image-20200928071303637&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以推断全局变量是在程序加载时给全局变量分配空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;程序5首先要找到每条C语句对应的汇编代码，然后单步跟踪，跟踪时要将栈中的情况都画出来（这部分自己纸上画就可以，不必体现在研究报告中，但是必须通过这个过程去完全理解程序）。跟踪一遍后，回答教材中的两个问题。	@未解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LEA 取有效地址指令&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928074812.png&#34; alt=&#34;image-20200928074812709&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序的汇编代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075257.png&#34; alt=&#34;image-20200928075256961&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075321.png&#34; alt=&#34;image-20200928075320888&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075558.png&#34; alt=&#34;image-20200928075558794&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;执行 &lt;code&gt;call 266&lt;/code&gt;可以看到把结构体的数据的首地址偏移地址和要返回结果的段地址的偏移地址存储到栈中然后调用 &lt;code&gt;call 076a:13ea&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928082337.png&#34; alt=&#34;image-20200928082337791&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075810.png&#34; alt=&#34;image-20200928075810572&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;call 076a:13ea&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928083602.png&#34; alt=&#34;image-20200928083601974&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928080105.png&#34; alt=&#34;image-20200928080104918&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;执行到&lt;code&gt;076a:13f0 c57606&lt;/code&gt;可以看到传入栈中的结构体数据的源地址和要返回结果的目的地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928082824.png&#34; alt=&#34;image-20200928082824733&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行到&lt;code&gt;adc cx,cx&lt;/code&gt;前后查看目的地址中的数据可以发现数据已经由源地址传送到目的地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928083959.png&#34; alt=&#34;image-20200928083959039&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从函数返回的结构体数据类型存储在数据段中，在函数中先把返回结果的段地址和偏移地址压入栈中然后把结构体的段地址和偏移地址压入栈中，接着调用子程序（参数就是两个偏移地址）把栈中的数据移动到目标地址的内存中，子程序完成返回目标地址的偏移地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行到&lt;code&gt;call 076a:1406&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以看到&lt;code&gt;dx:ax&lt;/code&gt;为 &lt;code&gt;076a:1406&lt;/code&gt;的参数&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928090026.png&#34; alt=&#34;image-20200928090026334&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子程序 &lt;code&gt;076a:1460&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928091101.png&#34; alt=&#34;image-20200928091101628&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928090256.png&#34; alt=&#34;image-20200928090256790&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;可以看到此程序的功能是把结构体数据复制到目的地址&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928091139.png&#34; alt=&#34;image-20200928091139256&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 &lt;code&gt;call 0256&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928091532.png&#34; alt=&#34;image-20200928091531970&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到子程序通过栈来使用传过来的结构体数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928092331.png&#34; alt=&#34;image-20200928092331592&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向函数传递结构体数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过调用子程序来把结构体数据复制到栈中&lt;/li&gt;
&lt;li&gt;然后函数在通过栈来使用结构体数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">0928_综合研究1-3补充研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/0926_-zong-he-yan-jiu-4-yan-jiu-bao-gao/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;源程序文件（.c文件）需要进行编译、连接两步工作后生成&lt;code&gt;exe&lt;/code&gt;文件在前面的内容中，&lt;br&gt;
这两步工作是集成在一起完成的。&lt;/p&gt;
&lt;p&gt;多个&lt;code&gt;obj&lt;/code&gt;文件中的代码可以存储在一个&lt;code&gt;lib&lt;/code&gt;文件中，对于&lt;code&gt;tc2.0&lt;/code&gt;开发环境，一个&lt;code&gt;exe&lt;/code&gt;文件&lt;br&gt;
中可能包含了来自多个&lt;code&gt;obj&lt;/code&gt;文件和&lt;code&gt;lib&lt;/code&gt;文件中的代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cs.lib emu.lib maths.lib&lt;/code&gt;等&lt;code&gt;lib&lt;/code&gt;文件中存储着C语言库函数的代码，比如 &lt;code&gt;printf&lt;/code&gt;、 &lt;code&gt;getch&lt;/code&gt;等等C语言提供的库函数都在&lt;code&gt;cs.lib&lt;/code&gt;中存储。&lt;br&gt;
我们用形如&lt;code&gt;tcc a.c&lt;/code&gt;的方法对程序进行编译连接，使用的是&lt;code&gt;tc2.0&lt;/code&gt;设计的一套固定的&lt;br&gt;
生成&lt;code&gt;exe&lt;/code&gt;文件的方案。这套设计好的方案的具体步骤如下:&lt;br&gt;
（1）&lt;code&gt;tcc&lt;/code&gt;将源程序文件编译为&lt;code&gt;a.obj&lt;/code&gt;&lt;br&gt;
（2）&lt;code&gt;tcc&lt;/code&gt;调用 &lt;code&gt;tlink&lt;/code&gt;将&lt;code&gt;c0s.obj、cs.lib、emu.lib maths.lib&lt;/code&gt;中的&lt;code&gt;a.obj&lt;/code&gt;中的程序要用到的代码&lt;br&gt;
与&lt;code&gt;a.obj&lt;/code&gt;的代码连接到一起生成&lt;code&gt;exe&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;而来自&lt;code&gt;c0s.obj&lt;/code&gt;中的代码被连接到其他代码的前面。&lt;code&gt;c0s.obj&lt;/code&gt;中的代码所做的工作是:进&lt;br&gt;
行相关的初始化工作、调用名称为“&lt;code&gt;main&lt;/code&gt;”的函数、其他工作。&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;c0s.obj&lt;/code&gt;的代码被连接到其他代码前面，则&lt;code&gt;exe&lt;/code&gt;文件运行的时候首先运行来自 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;br&gt;
中的代码，进行相关的初始化工作，然后调用&lt;code&gt;main&lt;/code&gt;函数，从此开始运行程序员写的程序。&lt;/p&gt;
&lt;p&gt;我们可以看出，这套工作方案落实了C语言的“用户程序必须从&lt;code&gt;main&lt;/code&gt;函数开始”的规则。&lt;/p&gt;
&lt;h2 id=&#34;问题研究&#34;&gt;问题研究&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用&lt;code&gt;tcc&lt;/code&gt;将下面的程序编译为&lt;code&gt;obj&lt;/code&gt;文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int f(void) { return 1; }
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926112859.png&#34; alt=&#34;image-20200926112859041&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过查看&lt;code&gt;tcc&lt;/code&gt;的使用方式可以看到 &lt;code&gt;-c&lt;/code&gt;为生成&lt;code&gt;obj&lt;/code&gt;文件的参数&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926113040.png&#34; alt=&#34;image-20200926113040248&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;tcc&lt;/code&gt;的方法编译连接下面的程序。注意显示出来的信息。这些信息说明了什么？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main() { f(); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过编译链接，显示出来没有&lt;code&gt;f&lt;/code&gt;的定义，说明&lt;code&gt;tlink&lt;/code&gt;链接时仅仅链接 &lt;code&gt;c0s.obj、cs.lib、emu.lib maths.lib&lt;/code&gt;其余的用户自定义的不会被自动链接。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926113259.png&#34; alt=&#34;image-20200926113259807&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tc2.0&lt;/code&gt;提供一个工具&lt;code&gt;tlib.exe&lt;/code&gt;，可以用&lt;code&gt;tib.exe&lt;/code&gt;将一个&lt;code&gt;obj&lt;/code&gt;文件中的代码加到一个lib文&lt;br&gt;
件中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找到tlib.exe，研究它的使用方法，将（1）中生成的&lt;code&gt;obj&lt;/code&gt;文件加入到&lt;code&gt;csib&lt;/code&gt;中&lt;br&gt;
注意:我们要对一个对象（&lt;code&gt;cs.lib&lt;/code&gt;）进行正确的改动，但是种正确的改动不一定一次成功&lt;br&gt;
所以，在改动之前，我们可以将原来的对象保存一份，以便恢复。&lt;br&gt;
上面的工作成功后，用&lt;code&gt;tcc a.c&lt;/code&gt;的方法将程序c编译连接为&lt;code&gt;a.exe&lt;/code&gt;文件用 &lt;code&gt;debug&lt;/code&gt;&lt;br&gt;
加载&lt;code&gt;a.exe&lt;/code&gt;文件，找到&lt;code&gt;main&lt;/code&gt;函数和f函数的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;:&lt;code&gt;a.c&lt;/code&gt;中并没有写函数&lt;code&gt;f&lt;/code&gt;，&lt;code&gt;a exe&lt;/code&gt;中的函数&lt;code&gt;f&lt;/code&gt;的代码是在什么时候加入的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过观察&lt;code&gt;tlib.exe&lt;/code&gt;的使用方式后把&lt;code&gt;f.obj&lt;/code&gt;添加到&lt;code&gt;cs.lib&lt;/code&gt;中（提前备份以防止失败）后编译链接&lt;code&gt;a.c&lt;/code&gt;生成可执行文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926114704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;可以看到链接过程没有报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;debug&lt;/code&gt;来观察&lt;code&gt;a.exe&lt;/code&gt;可以看到程序开始后调用子程序然后我们开始转到子程序观察发现子程序为&lt;code&gt;f&lt;/code&gt;。&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926115332.png&#34; alt=&#34;image-20200926115332535&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926115407.png&#34; alt=&#34;image-20200926115407734&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在问题2中在链接的时候报错而修改完&lt;code&gt;cs.lib&lt;/code&gt;后在进行编译链接正常故&lt;code&gt;f&lt;/code&gt;中的代码是在链接的时候加入到&lt;code&gt;a.exe&lt;/code&gt;中的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序b.c中并没有写f、f2和 printf函数，bexe中这些函数的代码是什么时候加&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将下面的程序编译为&lt;code&gt;f.obj&lt;/code&gt;，将&lt;code&gt;f.obj&lt;/code&gt;加入&lt;code&gt;cs.lib&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;程序&lt;code&gt;f.c&lt;/code&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int f1(int a, int b) {
    int c;
    c = a + b;
    return c;
}
int f2(int a, int b) {
    int c;
    c = a - b;
    return c;
}
int f3(int a, int b) { return a + b + 1; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;tcc.exe，tlib.exe&lt;/code&gt;将生成后&lt;code&gt;obj&lt;/code&gt;文件添加到&lt;code&gt;cs.lib&lt;/code&gt;中&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926120657.png&#34; alt=&#34;image-20200926120657685&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;将下面的程序编译连接为&lt;code&gt;b.exe&lt;/code&gt;用 &lt;code&gt;debug&lt;/code&gt;加载&lt;code&gt;b.exe&lt;/code&gt;，找到其中所有函数代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;程序&lt;code&gt;b.c&lt;/code&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int func(int, int);

int a, b;

main() {
    a = f1(1, 2);
    b = f2(20, 10);
    a = func(a, b);
    printf(&amp;quot;%d\n&amp;quot;, a);
}

int func(int a, int b) { return a * b; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;tcc&lt;/code&gt;编译链接生成&lt;code&gt;b.exe&lt;/code&gt;可以找到函数代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926121609.png&#34; alt=&#34;image-20200926121609202&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926121743.png&#34; alt=&#34;image-20200926121743017&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926122007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926122127.png&#34; alt=&#34;image-20200926122126913&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;b.exe&lt;/code&gt;中的函数代码是链接时加入的，并且其中包含&lt;code&gt;f3&lt;/code&gt;的代码紧紧跟在&lt;code&gt;f2&lt;/code&gt;的后面，猜测加入代码是通过&lt;code&gt;obj&lt;/code&gt;为单位进行添加的&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926122844.png&#34; alt=&#34;image-20200926122844432&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在尝试将&lt;code&gt;f.c&lt;/code&gt;中的三个函数分成三份然后逐步添加到&lt;code&gt;cs.lib&lt;/code&gt;中。&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926125312.png&#34; alt=&#34;image-20200926125312063&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;f2&lt;/code&gt;后面就没有&lt;code&gt;f3&lt;/code&gt;的代码了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用&lt;code&gt;tlib&lt;/code&gt;将&lt;code&gt;cs.lib&lt;/code&gt;中 &lt;code&gt;printf&lt;/code&gt;函数的代码变为下面的程序的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf() { puts(&amp;quot;Do you want to use printf? No printf here.&amp;quot;); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使得调用 &lt;code&gt;printf&lt;/code&gt;的用户程序，比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main() {
    int a, b;
    a = 1;
    b = 2;
    printf(&amp;quot;%d\n&amp;quot;, a + b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在用&lt;code&gt;tcc&lt;/code&gt;编译连接后，运行时打印出&lt;code&gt;Do you want to use printf No printf here&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;printf&lt;/code&gt;从&lt;code&gt;cs.lib&lt;/code&gt;中移除&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926125903.png&#34; alt=&#34;image-20200926125903019&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;printf&lt;/code&gt;生成新的&lt;code&gt;obj&lt;/code&gt;文件后加入&lt;code&gt;cs.lib&lt;/code&gt;中&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926130513.png&#34; alt=&#34;image-20200926130513072&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;编译链接运行&lt;code&gt;main.c&lt;/code&gt;可以看到结果&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926130600.png&#34; alt=&#34;image-20200926130600602&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">0926_综合研究4研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/0925_-zong-he-yan-jiu-3-yan-jiu-bao-gao/"" data-c="
          &lt;h2 id=&#34;研究1&#34;&gt;研究1&lt;/h2&gt;
&lt;h3 id=&#34;摘要&#34;&gt;摘要&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用&lt;code&gt;debug&lt;/code&gt;对一下程序编译链接后的代码进行研究&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned int n;
void f1();
int f2(int, int);
void far f3();

main() {
    n = 0;
    f1();
    n = f2(1, 2);
    f3();
}

void f1() {
    n = 1;
}
int f2(int a, int b) {
    int c;
    c = a + b;
    return c;
}

void far f3() {
    n = 10;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;程序运行时n、a、b、c的段地在哪个存器中？&lt;/li&gt;
&lt;li&gt;全局变量的存空间在什么段里？局都量的储空间在什么段里？参数的存储空间在什么段里？函数的返回在什么地方？&lt;/li&gt;
&lt;li&gt;全局变量的存空间在什么时候分配？什么时候释？&lt;/li&gt;
&lt;li&gt;局部变量的存空间在什么时候分配？什么时候释？&lt;/li&gt;
&lt;li&gt;参数的存储空间在什么时候分配？什么时候释？&lt;/li&gt;
&lt;li&gt;函数3在调用与返回方式上与函数与2有何不同？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;研究过程&#34;&gt;研究过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先通过&lt;code&gt;TCC&lt;/code&gt;编译链接生成汇编文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &amp;quot;\src\three.c&amp;quot;
_TEXT	segment	byte public &#39;CODE&#39;
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP ;数据段地址和栈段地址为同一块内存空间
_TEXT	ends
_DATA	segment word public &#39;DATA&#39;
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public &#39;BSS&#39;
b@	label	byte
b@w	label	word
	?debug	C E9826239510C5C7372635C74687265652E63
_BSS	ends
_TEXT	segment	byte public &#39;CODE&#39;
;	?debug	L 10
_main	proc	near
;	?debug	L 11
	mov	word ptr DGROUP:_n,0 ;变量n
;	?debug	L 12
	call	near ptr _f1
;	?debug	L 13
	mov	ax,2
	push	ax
	mov	ax,1
	push	ax
	call	near ptr _f2
	pop	cx
	pop	cx
	mov	word ptr DGROUP:_n,ax
;	?debug	L 14
	call	far ptr _f3
@1:
;	?debug	L 15
	ret	
_main	endp
;	?debug	L 17
_f1	proc	near
;	?debug	L 17
	mov	word ptr DGROUP:_n,1
@2:
;	?debug	L 17
	ret	
_f1	endp
;	?debug	L 18
_f2	proc	near
	push	bp
	mov	bp,sp
	push	si
;	?debug	L 20
	mov	si,word ptr [bp+4]
	add	si,word ptr [bp+6]
;	?debug	L 21
	mov	ax,si
	jmp	short @3
@3:
;	?debug	L 22
	pop	si
	pop	bp
	ret	
_f2	endp
;	?debug	L 24
_f3	proc	far
;	?debug	L 24
	mov	word ptr DGROUP:_n,10
@4:
;	?debug	L 24
	ret	
_f3	endp
_TEXT	ends
_BSS	segment word public &#39;BSS&#39;
_n	label	word
	db	2 dup (?)
_BSS	ends
	?debug	C E9
_DATA	segment word public &#39;DATA&#39;
s@	label	byte
_DATA	ends
_TEXT	segment	byte public &#39;CODE&#39;
_TEXT	ends
	public	_main
	public	_n
	public	_f3
	public	_f2
	public	_f1
	end

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察汇编代码可以发现变量&lt;code&gt;n&lt;/code&gt;的段地址寄存器为&lt;code&gt;ds&lt;/code&gt;，而&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;的段地址寄存器为&lt;code&gt;ss&lt;/code&gt;，&lt;s&gt;&lt;code&gt;c&lt;/code&gt;的段地址寄存器为&lt;code&gt;cs&lt;/code&gt;。&lt;/s&gt;，&lt;code&gt;c&lt;/code&gt;的段地址寄存器为&lt;code&gt;ss&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在此程序中&lt;code&gt;n&lt;/code&gt;为全局变量并且存放在数据段中故全局变量存放在数据段中。&lt;code&gt;a,b&lt;/code&gt;为参数存放在栈中过参数存放在栈中，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局变量的存储空间在编译的时候就分配好有多大然后在执行可执行文件时在分配内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部变量在程序执行过程中用到的时候在分配 ，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数在给函数传递前分配空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;f3&lt;/code&gt;和&lt;code&gt;f2&lt;/code&gt;的调用方式可以通过汇编代码观察到&lt;code&gt;call	far ptr _f3&lt;/code&gt;和&lt;code&gt;call	near ptr _f2&lt;/code&gt;一个是&lt;code&gt;call	fa&lt;/code&gt;一个是``	call	near&lt;code&gt;而 返回时&lt;/code&gt;f2&lt;code&gt;先进行栈恢复然后在返回，&lt;/code&gt;f3`直接返回不进行栈恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;研究全部完成后，可以回答第2个问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;全局变量存储在数据段中&lt;/li&gt;
&lt;li&gt;局部变量存储在栈中&lt;/li&gt;
&lt;li&gt;参数存储在栈中&lt;/li&gt;
&lt;li&gt;返回值存储在寄存器中或者数据段中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;研究2&#34;&gt;研究2&lt;/h2&gt;
&lt;h3 id=&#34;摘要-2&#34;&gt;摘要&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void f(void);
main() {
    f();
    f();
}
void f(void) {
    int n = 0;
    static int a = 0;
    n++;
    a++;
    printf(&amp;quot;  %d  %d\n&amp;quot;, n, a);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题-2&#34;&gt;问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量 &lt;code&gt;n&lt;/code&gt; 与&lt;code&gt;a&lt;/code&gt;的存储空间分配方式何不同？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;研究过程-2&#34;&gt;研究过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;tcc&lt;/code&gt;生成汇编文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &amp;quot;\src\three2.c&amp;quot;
_TEXT	segment	byte public &#39;CODE&#39;
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public &#39;DATA&#39;
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public &#39;BSS&#39;
b@	label	byte
b@w	label	word
	?debug	C E9A96A39510D5C7372635C7468726565322E63
_BSS	ends
_TEXT	segment	byte public &#39;CODE&#39;
;	?debug	L 2
_main	proc	near
;	?debug	L 3
	call	near ptr _f
;	?debug	L 4
	call	near ptr _f
@1:
;	?debug	L 5
	ret	
_main	endp
_TEXT	ends
_DATA	segment word public &#39;DATA&#39;
	dw	0
_DATA	ends
_TEXT	segment	byte public &#39;CODE&#39;
;	?debug	L 6
_f	proc	near
	push	si
;	?debug	L 7
	xor	si,si
;	?debug	L 9
	inc	si
;	?debug	L 10
	inc	word ptr DGROUP:d@
;	?debug	L 11
	push	word ptr DGROUP:d@
	push	si
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	add	sp,6
@2:
;	?debug	L 12
	pop	si
	ret	
_f	endp
_TEXT	ends
	?debug	C E9
_DATA	segment word public &#39;DATA&#39;
s@	label	byte
	db	32
	db	32
	db	37
	db	100
	db	32
	db	32
	db	37
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public &#39;CODE&#39;
	extrn	_printf:near
_TEXT	ends
	public	_main
	public	_f
	end

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察可以发现&lt;code&gt;n&lt;/code&gt;时局部变量分配在栈空间中而&lt;code&gt;a&lt;/code&gt;分配在数据段中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;研究3&#34;&gt;研究3&lt;/h2&gt;
&lt;h3 id=&#34;摘要-3&#34;&gt;摘要&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned int a = 1;
unsigned int b = 1;
unsigned char c = 1;
unsigned int a1 = 1;
unsigned long a2 = 1;

main() {
    a++;
    b++;
    c++;
    a1++;
    a2++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题-3&#34;&gt;问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;程序中所有变量的存储空间相邻吗?tc2.0中，整型、字符型、长整型数据的存储空&lt;br&gt;
间分别为多大？&lt;/li&gt;
&lt;li&gt;不同的数据类型对数据运算方式的有何影响？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;研究过程-3&#34;&gt;研究过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;tcc&lt;/code&gt;生成&lt;code&gt;asm&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &amp;quot;\src\three3.c&amp;quot;
_TEXT	segment	byte public &#39;CODE&#39;
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public &#39;DATA&#39;
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public &#39;BSS&#39;
b@	label	byte
b@w	label	word
	?debug	C E9496C39510D5C7372635C7468726565332E63
_BSS	ends
_DATA	segment word public &#39;DATA&#39;
_a	label	word
	dw	1
_b	label	word
	dw	1
_c	label	byte
	db	1
_a1	label	word
	dw	1
_a2	label	word
	dw	1
	dw	0
_DATA	ends
_TEXT	segment	byte public &#39;CODE&#39;
;	?debug	L 7
_main	proc	near
;	?debug	L 8
	inc	word ptr DGROUP:_a
;	?debug	L 9
	inc	word ptr DGROUP:_b
;	?debug	L 10
	inc	byte ptr DGROUP:_c
;	?debug	L 11
	inc	word ptr DGROUP:_a1
;	?debug	L 12
	add	word ptr DGROUP:_a2,1
	adc	word ptr DGROUP:_a2+2,0
@1:
;	?debug	L 13
	ret	
_main	endp
_TEXT	ends
	?debug	C E9
_DATA	segment word public &#39;DATA&#39;
s@	label	byte
_DATA	ends
_TEXT	segment	byte public &#39;CODE&#39;
_TEXT	ends
	public	_main
	public	_c
	public	_b
	public	_a
	public	_a2
	public	_a1
	end

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过汇编代码可以发现只有长整型的运算方式是和其余数据类型的运算方式有所不同，长整型的运算方式为带进位的加法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过汇编代码可以看出，整型的存储空间为一个字，字符型的存储空间为一个字节，长整型的存储空间为两个字大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改程序然后生成可执行文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改后将数据改成易辨识的数据（1，2，3，4，5）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned int a = 1;
unsigned int b = 2;
unsigned char c = 3;
unsigned int a1 = 4;
unsigned long a2 = 5;

main() {
    a++;
    b++;
    c++;
    a1++;
    a2++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过debug来进行查看变量的存储空间是否相邻&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925135108.png&#34; alt=&#34;image-20200925135108549&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从图中可以看出存储空间依次相邻&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;研究4&#34;&gt;研究4&lt;/h2&gt;
&lt;h3 id=&#34;摘要-4&#34;&gt;摘要&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*定义一个结构体类型stu，这个结构体类型描述一个学生的成绩。其中包括
    : 学号（整型）、C、Os、masm三门课程的成绩（字符型）*/
struct stu {
    int number;
    char c;
    char os;
    char masm;
};
/*注意，在实际程序设计中，程序员往往需要定义新的数据类型来对数据进行抽象。C语言支持用基本的数据类型如“char”、“int”等等来构造新的更为复杂的数据类型。

“整型”这一数据类型的名称为“int”:“字符型这一数据类型的名称为“char”:
以上定义了一个 新的数据类型“struct stu”，这个数据类型的名称为“stu

structstu型数据包括4个数据项 : number、c、os、masm*/

struct stu a; /*定义一个struct stu型的变量a*/

main() {
    /*定义一个struct stu型的变量b*/
    struct stu b;

    a.number = 1;
    a.c = 80;
    a.os = 82;
    a.masm = 88;

    b.number = 2;
    b.c = 90;
    b.os = 92;
    b.masm = 98;

    printf(&amp;quot;number c  os masm\n&amp;quot;);
    printf(&amp;quot;-----------------\n&amp;quot;);

    printf(&amp;quot;%d     %d  %d  %d\n&amp;quot;, a.number, a.c, a.os, a.masm);
    printf(&amp;quot;%d     %d  %d  %d\n&amp;quot;, b.number, b.c, b.os, b.masm);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题-4&#34;&gt;问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;和他们的各个数据项的存储空间如何分配&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;研究过程-4&#34;&gt;研究过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将程序通过&lt;code&gt;tcc&lt;/code&gt;生成汇编文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &amp;quot;\src\three4.c&amp;quot;
_TEXT	segment	byte public &#39;CODE&#39;
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public &#39;DATA&#39;
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public &#39;BSS&#39;
b@	label	byte
b@w	label	word
	?debug	C E9127239510D5C7372635C7468726565342E63
_BSS	ends
_TEXT	segment	byte public &#39;CODE&#39;
;	?debug	L 18
_main	proc	near
	push	bp
	mov	bp,sp
	sub	sp,6
;	?debug	L 22
	mov	word ptr DGROUP:_a,1
;	?debug	L 23
	mov	byte ptr DGROUP:_a+2,80
;	?debug	L 24
	mov	byte ptr DGROUP:_a+3,82
;	?debug	L 25
	mov	byte ptr DGROUP:_a+4,88
;	?debug	L 27
	mov	word ptr [bp-6],2
;	?debug	L 28
	mov	byte ptr [bp-4],90
;	?debug	L 29
	mov	byte ptr [bp-3],92
;	?debug	L 30
	mov	byte ptr [bp-2],98
;	?debug	L 32
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	pop	cx
;	?debug	L 33
	mov	ax,offset DGROUP:s@+19
	push	ax
	call	near ptr _printf
	pop	cx
;	?debug	L 35
	mov	al,byte ptr DGROUP:_a+4
	cbw	
	push	ax
	mov	al,byte ptr DGROUP:_a+3
	cbw	
	push	ax
	mov	al,byte ptr DGROUP:_a+2
	cbw	
	push	ax
	push	word ptr DGROUP:_a
	mov	ax,offset DGROUP:s@+38
	push	ax
	call	near ptr _printf
	add	sp,10
;	?debug	L 36
	mov	al,byte ptr [bp-2]
	cbw	
	push	ax
	mov	al,byte ptr [bp-3]
	cbw	
	push	ax
	mov	al,byte ptr [bp-4]
	cbw	
	push	ax
	push	word ptr [bp-6]
	mov	ax,offset DGROUP:s@+57
	push	ax
	call	near ptr _printf
	add	sp,10
@1:
;	?debug	L 37
	mov	sp,bp
	pop	bp
	ret	
_main	endp
_TEXT	ends
_BSS	segment word public &#39;BSS&#39;
_a	label	word
	db	5 dup (?)
_BSS	ends
	?debug	C E9
_DATA	segment word public &#39;DATA&#39;
s@	label	byte
	db	110
	db	117
	db	109
..........
	db	0
_DATA	ends
_TEXT	segment	byte public &#39;CODE&#39;
	extrn	_printf:near
_TEXT	ends
	public	_main
	public	_a
	end

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察汇编文件可以发现，变量&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;的各个数据项的存储空间是连续分配的不过&lt;code&gt;a&lt;/code&gt;是在数据段中而&lt;code&gt;b&lt;/code&gt;是在栈中，而变量a和b是存储的该变量的初始地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;研究5&#34;&gt;研究5&lt;/h2&gt;
&lt;h3 id=&#34;摘要-5&#34;&gt;摘要&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct n {
    int a;
    int b;
    int c;
};

int f(struct n);

struct n func(void);

main() {
    struct n a;
    int b;

    a = func();
    b = f(a);

    printf(&amp;quot; %d&amp;quot;, b);
    printf(&amp;quot; %d&amp;quot;, f(func()));
}

int f(struct n a) { return (a.a + a.b) * a.c; }

struct n func(void) {
    struct n a;
    a.a = 1;
    a.b = 2;
    a.c = 3;
    return a;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题-5&#34;&gt;问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;向函数传递结构体型数据是如何实现的？&lt;/li&gt;
&lt;li&gt;从函数返回的结构体型数据存储在何处？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;研究过程-5&#34;&gt;研究过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;要探讨结构体是如何返回的，那么首先应该观察执行函数前后有什么变化。我们开始执行到调用func的汇编语句的前一句然后在执行到后一句观察寄存器的值的变化&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925151809.png&#34; alt=&#34;image-20200925151809779&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发现ax的值发生变化然后看对应数据段中的数据，发现从函数返回的结构体型数据存储在数据段中&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925152304.png&#34; alt=&#34;image-20200925152304087&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以从函数返回的结构体型数据存储在数据段中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于第一个问题向函数传递结构体型数据是如何实现的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先观察&lt;code&gt;b = f(a);&lt;/code&gt;对应的汇编代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;	?debug	L 16
	lea	bx,word ptr [bp-6]
	mov	dx,ss
	mov	ax,bx
	mov	cx,6
	call	far ptr SPUSH@
	call	near ptr _f
	add	sp,6
	mov	si,ax
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以看到在执行&lt;code&gt;call	near ptr _f&lt;/code&gt;前先执行了&lt;code&gt;call	far ptr SPUSH@&lt;/code&gt;根据名字猜测应该是往栈里吗压入 一些数据，接下来在&lt;code&gt;debug&lt;/code&gt;中检验猜测是否正确&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察到执行完&lt;code&gt;call	far ptr SPUSH@&lt;/code&gt;前后寄存器&lt;code&gt;sp&lt;/code&gt;的值发生了改变然后观察栈中的数据可以看到把结构体中的数据压入到栈中(&lt;code&gt;ss:ffce&lt;/code&gt;)。然后接下来进入&lt;code&gt;_f&lt;/code&gt;中看是否使用了栈中压入的数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925153742.png&#34; alt=&#34;image-20200925153742447&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在进入后执行到&lt;code&gt;mov bp,sp&lt;/code&gt; 后可以发现确实使用了栈中压入的数据（&lt;code&gt;ss:ffce&lt;/code&gt;）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925154430.png&#34; alt=&#34;image-20200925154430806&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到此就可以回答了，函数是通过栈来传递结构体的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;变量无非就是存储在栈中或者数据段中，如果变量需要长期存在或者要返回那么会将变量存储在数据段中，而如过仅仅只需在函数中存在或者传递参数就需要将数据保存在栈中。&lt;/li&gt;
&lt;/ul&gt;
"> 0925_综合研究3研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/0924_-zong-he-yan-jiu-2-yan-jiu-bao-gao/"" data-c="
          &lt;h2 id=&#34;研究问题&#34;&gt;研究问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在main函数中添加代码，打印出下列函数的段地址和偏移地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a;
void f1(void) { a = 1; }
void f2(void) { a = 2; }
void f3(void) { a = 3; }
main() {
    .....
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;研究过程&#34;&gt;研究过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为代码段地址是存储在&lt;code&gt;cs&lt;/code&gt;中的所以我们可以通过&lt;code&gt;printf(&amp;quot;\nCS: %x\n&amp;quot;, _CS);&lt;/code&gt;来打印出程序运行时的段地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数的标号就是对应的偏移地址我们可以通过&lt;code&gt;printf(&amp;quot;\nf1: %x\n&amp;quot;, f1);&lt;/code&gt;来打印出函数的偏移地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以修改&lt;code&gt;a.c&lt;/code&gt; 添加相应打印输出语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a;
void f1(void) { a = 1; }
void f2(void) { a = 2; }
void f3(void) { a = 3; }
main() {
    char *string = &amp;quot;--------------------&amp;quot;;
    printf(&amp;quot;\nCS: %x\n&amp;quot;, _CS);
    printf(&amp;quot;%s&amp;quot;, string);
    printf(&amp;quot;\nf1: %x\n&amp;quot;, f1);
    printf(&amp;quot;\nf2: %x\n&amp;quot;, f2);
    printf(&amp;quot;\nf3: %x\n&amp;quot;, f3);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译链接完后执行可执行文件可以分别看出&lt;strong&gt;3&lt;/strong&gt;个函数的偏移地址和段地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200924130620.png&#34; alt=&#34;image-20200924130620295&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后在DEBUG中验证输出结果是否正确&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200924130910.png&#34; alt=&#34;image-20200924130910136&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200924131638.png&#34; alt=&#34;image-20200924131638053&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现&lt;code&gt;DEBUG&lt;/code&gt;中执行&lt;code&gt;a.exe&lt;/code&gt; 打印出的&lt;code&gt;CS&lt;/code&gt; 的值和直接运行的结果不一致，剩下三个函数的偏移地址都一致但是&lt;code&gt;DEBUG&lt;/code&gt;中打印的&lt;code&gt;cs&lt;/code&gt; 的值是正确的，所以推测直接运行 &lt;code&gt;a.exe&lt;/code&gt;的结果也是正确的。可能是应为&lt;code&gt;DEBUG&lt;/code&gt;本身就是一个可执行程序所以在运行时系统就已经分配给&lt;code&gt;DEBUG&lt;/code&gt;一块内存然后&lt;code&gt;DEBUG&lt;/code&gt;再分配内存给&lt;code&gt;a.exe&lt;/code&gt;,而直接运行&lt;code&gt;a.exe&lt;/code&gt;的话就系统直接分配的内存所以两次的结果会不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;研究结果&#34;&gt;研究结果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数的名称就好像汇编程序里面的标号起到一个定位的作用，方便程序嵌套和跳转&lt;/li&gt;
&lt;/ul&gt;
"> 0924_综合研究2研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/0923_-zong-he-yan-jiu-1-yan-jiu-bao-gao/"" data-c="
          &lt;h2 id=&#34;研究问题&#34;&gt;研究问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 TC 2.0 提供的编译程序进行编译链接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;编译器： TCC.EXE&lt;/li&gt;
&lt;li&gt;链接器：TLINK.EXE&lt;/li&gt;
&lt;li&gt;相关文件：c0s.obj , cs.lib ,  emu.lib, maths.lib&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;研究过程&#34;&gt;研究过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新建目录 &lt;code&gt;31prj_c&lt;/code&gt;将相关文件导入该目录下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923182246.png&#34; alt=&#34;image-20200923182246342&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改&lt;strong&gt;DosBox&lt;/strong&gt;配置文件将 &lt;code&gt;F:\gitee\ThreeOneProject\31prj_c&lt;/code&gt; 挂在到 &lt;code&gt;c:&lt;/code&gt;下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923182308.png&#34; alt=&#34;image-20200923182308106&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写 &lt;code&gt;a.c&lt;/code&gt;程序来测试&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main ()
{
	printf(&amp;quot;hello world!\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行测试&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编译链接&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923182935.png&#34; alt=&#34;image-20200923182935034&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923183006.png&#34; alt=&#34;image-20200923183006580&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;完成研究实验的基本环境搭建&lt;/p&gt;
"> 0923_综合研究1研究报告</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验1-5补充/"" data-c="
          &lt;h1 id=&#34;0622-研究试验&#34;&gt;0622-研究试验&lt;/h1&gt;
&lt;h2 id=&#34;修改c0sobj&#34;&gt;修改c0s.obj&lt;/h2&gt;
&lt;p&gt;按书上的汇编代码编译完生成的c0s.obj&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试函数(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;f()
{
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;
}

main(){
    int a=0;
    int b=0;
    f();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622162009509.png&#34; alt=&#34;image-20200622162009509&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;测试函数(2)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;f();

main(){
    int a=0;
    int b=0;
    f();
}

f()
{
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622161853903.png&#34; alt=&#34;image-20200622161853903&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到测试函数1是先调用 &lt;code&gt;f()&lt;/code&gt; 而 测试函数2 先调用 &lt;code&gt;main()&lt;/code&gt;还是没思路&lt;/p&gt;
&lt;h2 id=&#34;自己编写的printf&#34;&gt;自己编写的printf&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myPrintf(char *, ...);

main()
{
    myPrintf(&amp;quot; char: %c%n int: %d&amp;quot;, &#39;x&#39;, 5);
}

void myPrintf(char *str, ...)
{
    int stackIndex = 0;
    int stringIndex = 0;
    int screenIndex = 0;
    int screenBenchmark = 160 * 10;

    while (str[stringIndex] != 0)
    {
        if (str[stringIndex] == &#39;%&#39;)
        {
            if (str[stringIndex + 1] == &#39;c&#39;)
            {
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex);
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;
                screenIndex += 2;
                stringIndex += 2;
                stackIndex += 2;
            }
            else if (str[stringIndex + 1] == &#39;d&#39;)
            {
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex) + 0x30;
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;

                stackIndex += 2;
                screenIndex += 2;
                stringIndex += 2;
            }
            else if (str[stringIndex + 1] == &#39;n&#39;)
            {
                screenBenchmark += 160;
                screenIndex = 0;
                stringIndex += 2;
            }
        }
        else
        {
            *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = str[stringIndex];
            *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;

            screenIndex += 2;
            stringIndex += 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622115336023.png&#34; alt=&#34;image-20200622115336023&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;各种数据类型是通过什么返回的&#34;&gt;各种数据类型是通过什么返回的&lt;/h2&gt;
&lt;h3 id=&#34;float-注释中为对应的汇编代码&#34;&gt;float( 注释中为对应的汇编代码 )&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float f(float, float);

/*
_main	proc	near
	push	bp
	mov	bp,sp
	sub	sp,12
*/
main()
{
        // ax=cccd dx= 400c    
    float c = 2.2, a = 1.1, b = 1.1; /*
                                        mov	dx,16396
                                        mov	ax,-13107
                                        mov	word ptr [bp-10],dx
                                        mov	word ptr [bp-12],ax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下图为2.2对应的十六进制&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622152326481.png&#34; alt=&#34;image-20200622152326481&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;                                   /* ;	?debug	L 11
                                        mov	dx,16268
                                        mov	ax,-13107
                                        mov	word ptr [bp-6],dx
                                        mov	word ptr [bp-8],ax
                                    ;	?debug	L 11
                                        mov	dx,16268
                                        mov	ax,-13107
                                        mov	word ptr [bp-2],dx
                                        mov	word ptr [bp-4],ax
                                    */

    c = f(a, b); /*
                                    	mov	dx,word ptr [bp-2]
                                        mov	ax,word ptr [bp-4]
                                        push	dx
                                        push	ax
                                        mov	dx,word ptr [bp-6]
                                        mov	ax,word ptr [bp-8]
                                        push	dx
                                        push	ax
                                        call	near ptr _f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跳转到 _f 函数（在下一段）执行，然后返回到此处在执行&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#f&#34;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;ret&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;                                     /*   add	sp,8
                                        FSTP	dword ptr [bp-12]
                                        FWAIT
                                    */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终结果在栈中&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622154424383.png&#34; alt=&#34;image-20200622154424383&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a name=&#34;f&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
_f	proc	near
	push	bp
	mov	bp,sp
	sub	sp,4
*/
float f(float a, float b)
{
    float ab = a + b;   /*
                            FLD	dword ptr [bp+4]
                            FLD	dword ptr [bp+8]
                            FADD	
                            FSTP	dword ptr [bp-4]
                            FWAIT
                        */
    
    return ab;          /*
                        	FLD	dword ptr [bp-4]
                            jmp	short @2
                        @2: */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回前的各个寄存器的值&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622151535488.png&#34; alt=&#34;image-20200622151535488&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对应汇编代码中的 &lt;code&gt;[bp-4]&lt;/code&gt; 查看 &lt;code&gt;ss:ffc4&lt;/code&gt; 中的值&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622151831557.png&#34; alt=&#34;image-20200622151831557&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;                        /*
						;	?debug	L 50
                            mov	sp,bp
                            pop	bp
                            ret	
                        */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;#ret&#34;&gt;返回&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;结构体注释中为对应的汇编代码&#34;&gt;结构体（注释中为对应的汇编代码）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct returnStruct
{
    int i_num;
    float f_num;
    double d_num;
};

struct returnStruct f(struct returnStruct);


/*
	proc	near
	push	bp
	mov	bp,sp
	sub	sp,28
*/

main()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时各个寄存器的值&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622134618756.png&#34; alt=&#34;image-20200622134618756&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;{
    struct returnStruct s;
    struct returnStruct r;

    s.i_num = 1;		//	mov	word ptr [bp-28],1
    s.f_num = 1.1;		/*
    						mov	dx,16268
    						mov	ax,-13107
							mov	word ptr [bp-24],dx
							mov	word ptr [bp-26],ax
    					*/
    s.d_num = 1.11;		/*
    						mov	word ptr [bp-16],16369
							mov	word ptr [bp-18],-15729
							mov	word ptr [bp-20],23592
							mov	word ptr [bp-22],-2621
    					*/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据入栈后&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622135318316.png&#34; alt=&#34;image-20200622135318316&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    r=f(s);  	/*
	    			lea	bx,word ptr [bp-14]
					push	ss
					push	bx
					lea	bx,word ptr [bp-28]
					mov	dx,ss
					mov	ax,bx
					mov	cx,14
					call	far ptr SPUSH@
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SPUSH@执行前后对应寄存器的变化&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622135746933.png&#34; alt=&#34;image-20200622135746933&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到栈顶指针变了然后看对应的栈空间&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622140029293.png&#34; alt=&#34;image-20200622140029293&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到 SPUSH@ 的功能是 把 保存的数据再在栈空间中复制一份&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;				//	call	near ptr _f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;_f 执行前后对应寄存器的变化&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622140528110.png&#34; alt=&#34;image-20200622140528110&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到&lt;code&gt;ax&lt;/code&gt; 值改变，然后查看对应内存空间的值&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622141532472.png&#34; alt=&#34;image-20200622141532472&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以发现和在call near ptr _f 中最后 &lt;code&gt;lea	bx,word ptr [bp+4]&lt;/code&gt; 执行完后的栈空间的数据一样&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622142146357.png&#34; alt=&#34;image-20200622142146357&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;				//	add	sp,14
				*/
}

/*
	proc	near
	push	bp
	mov	bp,sp
*/
struct returnStruct f(struct returnStruct r){
    r.i_num++;		/*
    					inc	word ptr [bp+4]
    				*/
    r.f_num++;		/*
    					FLD	dword ptr [bp+6]  			FLD类似于   PUSH指令
    					FADD	qword ptr DGROUP:s@+9	FADD类似于  ADD指令
    					FSTP	dword ptr [bp+6]		FSTP类似于  POP指令
    					FWAIT
				    */
    r.d_num++;		/*
    					FLD	qword ptr [bp+10]
						FADD	qword ptr DGROUP:s@+9
						FSTP	qword ptr [bp+10]
						FWAIT	
    				*/

    return r;		/*
    					mov	bx,offset DGROUP:b@
						push	ds
						push	bx
						lea	bx,word ptr [bp+4]
						push	ss
						push	bx
						mov	cx,14
						call	far ptr SCOPY@
						;	?debug	L 29
						mov	ax,offset DGROUP:b@
						jmp	short @2
						@2:
						;	?debug	L 30
						pop	bp
						ret	
    				*/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现，结构体返回是把结果复制到内存空间中然后返回该内存空间的首地址。&lt;/p&gt;
">研究试验1-5补充</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验4-5补充/"" data-c="
          &lt;h1 id=&#34;研究试验4-5&#34;&gt;研究试验4-5&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;连接。c0s中的什么操作使main函数不管放在程序哪里都可以调用？ 改写自己的c0s，实现main函数在文件中任意位置，也可以准确定位main函数。
&lt;ol&gt;
&lt;li&gt;没有实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;c0s还有什么其他功能？
&lt;ol&gt;
&lt;li&gt;相关初始化&lt;/li&gt;
&lt;li&gt;申请资源&lt;/li&gt;
&lt;li&gt;设置DS、SS等寄存器&lt;/li&gt;
&lt;li&gt;在MAIN函数结束后进行相关资源的释放、环境恢复等工作&lt;/li&gt;
&lt;li&gt;调用DOS的21H程序返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;参数什么时候入栈，a.c中&lt;code&gt;[bp+2][bp+4][bp+6]&lt;/code&gt;表示什么？
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;[bp+2]&lt;/code&gt;  是  &lt;code&gt;call 子程序&lt;/code&gt;的下一条指令的&lt;code&gt;ip&lt;/code&gt;地址（在执行call 指令时把把当前的ip入栈，此时的&lt;code&gt;ip&lt;/code&gt;为下一条指令的&lt;code&gt;ip&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[bp+4]&lt;/code&gt; 是 字母 &lt;code&gt;a&lt;/code&gt; 对应的十六进制的 ASCII 码，在子程序执行开始时入栈。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[bp+6]&lt;/code&gt; 是 颜色对应的 十六进制，在子程序执行开始时入栈。
&lt;ol&gt;
&lt;li&gt;&lt;mark&gt;不同&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200621165803400.png&#34; alt=&#34;image-20200621165803400&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;了解printf函数的实现机制，编写可接收任意参数的printf函数。
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt;可能是根据传入的&lt;code&gt;%&lt;/code&gt;的个数来确定打印的字符数，读入一个&lt;code&gt;%&lt;/code&gt;就会读取后面一个字符来确定打印的方式，当读出一个&lt;code&gt;0&lt;/code&gt;时打印结束&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Printf和malloc函数在哪个库中存储（注意可表示int的范围-32768到32767）？
&lt;ol&gt;
&lt;li&gt;c0s.obj 用上自己修改的 c0s.obj 后printf无效果。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;cs.lib(小模式中的库函数)&lt;/mark&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;#define Buffer((char &lt;em&gt;)&lt;/em&gt;(int far *)).....里面的char 后面加far后，能正确编译连接吗？如果不能，修改一步使其成功编译
&lt;ol&gt;
&lt;li&gt;不能。（Lvalue Required in Function Main）&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;把 int( 16位) 改为 long（32位）&lt;/mark&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">研究试验4-5补充</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验5/"" data-c="
          &lt;h1 id=&#34;研究试验5&#34;&gt;研究试验5&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;函数如何接受不确定参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;编写ac-解答-相关问题&#34;&gt;编写&lt;code&gt;a.c&lt;/code&gt; ，解答 相关问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt; 是如何给 &lt;code&gt;showchar&lt;/code&gt; 传递参数的?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;showchar&lt;/code&gt; 是如何接受参数？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ac&#34;&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;c 代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void showchar(char a, int b);

main()
{
    showchar(&#39;a&#39;, 2);
}

void showchar(char a, int b)
{
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编代码&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091533.png&#34; alt=&#34;image-20200611091835656&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091538.png&#34; alt=&#34;image-20200611091940357&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;问题解答&#34;&gt;问题解答&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt;函数通过 栈 给 &lt;code&gt;showchar&lt;/code&gt; 传递参数&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091543.png&#34; alt=&#34;image-20200611093446099&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;showchar&lt;/code&gt; 应该也是从栈中获取的但是汇编代码中没有相关的栈操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;编写-bc-思考相关问题&#34;&gt;编写 &lt;code&gt;b.c&lt;/code&gt; 思考相关问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;showchar&lt;/code&gt; 函数是要如何知道呀显示多少个字符的？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt;函数是如何知道有多少个参数的？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;bc&#34;&gt;&lt;code&gt;b.c&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;c 代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void showchar(int, int, ...);

main()
{
    showchar(8, 2, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;);
}

void showchar(int n, int color, ...)
{
    int a;
    for (a = 0; a != n; a++)
    {
        *(char far *)(0xb8000000 + 160 * 10 + 80 + a + a) = *(int *)(_BP + 8 + a + a);
        *(char far *)(0xb8000000 + 160 * 10 + 81 + a + a) = color;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编代码&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091546.png&#34; alt=&#34;image-20200611100510959&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091551.png&#34; alt=&#34;image-20200611100524352&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091612.png&#34; alt=&#34;image-20200611100549657&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091618.png&#34; alt=&#34;image-20200611100619466&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091621.png&#34; alt=&#34;image-20200611100647742&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;printf-函数是如何知道有多少给参数&#34;&gt;&lt;code&gt;printf&lt;/code&gt; 函数是如何知道有多少给参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先写一个 &lt;code&gt;printf.c&lt;/code&gt; 的测试用例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main(){
    printf(&amp;quot;%c,%c,%c,%c&amp;quot;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;);
    printf(&amp;quot;%d,%d,%d,%d&amp;quot;,1,2,3,4);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个&lt;code&gt;printf&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091624.png&#34; alt=&#34;image-20200611104837574&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个 &lt;code&gt;printf&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091627.png&#34; alt=&#34;image-20200611105231039&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过对照 &lt;code&gt;printf&lt;/code&gt; 函数 可以猜想 &lt;code&gt;mov ax,0194;&lt;/code&gt;和 &lt;code&gt;mov ax 01a0&lt;/code&gt; 因该是 &lt;code&gt;printf&lt;/code&gt;的第一个参数，然后通过 &lt;code&gt;debug&lt;/code&gt; 可以验证猜想是正确的&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091630.png&#34; alt=&#34;image-20200611110541403&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过观察可以看到 &lt;code&gt;25 63 2c 25 63 2c 25 63 2c 25 63 2c 25 63 00&lt;/code&gt; 对应 字符串 &lt;code&gt;%c,%c,%c,%c&lt;/code&gt; 和 &lt;code&gt;25 64 2c 25 64 2c 25 64 2c 25 64 00&lt;/code&gt; 对应字符串 &lt;code&gt;%d,%d,%d,%d&lt;/code&gt;,，故根据以往编程经验猜想 &lt;code&gt;00&lt;/code&gt; 为终止条件。所以把第三个 &lt;code&gt;%c&lt;/code&gt; 对应的汇编代码开头改变为 &lt;code&gt;00&lt;/code&gt;，看看是不是只输出两个字符 通过下图可以看出猜想正确。所以可以得出&lt;code&gt;printf&lt;/code&gt;可能是根据传入的&lt;code&gt;%&lt;/code&gt;的个数来确定打印的字符数，读入一个&lt;code&gt;%&lt;/code&gt;就会读取后面一个字符来确定打印的方式，当读出一个&lt;code&gt;0&lt;/code&gt;时打印结束&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091633.png&#34; alt=&#34;image-20200611111912747&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;问题解答-2&#34;&gt;问题解答&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;第一个参数 &lt;code&gt;n&lt;/code&gt; 就是告知函数 &lt;code&gt;showchar&lt;/code&gt;显示多少给字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt;是通过 &lt;code&gt;%&lt;/code&gt;的个数来得知有多少个参数，通过 &lt;code&gt;00&lt;/code&gt;来判断结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现一个简单的-printf-函数-只需支持-cd-即可&#34;&gt;实现一个简单的 &lt;code&gt;printf&lt;/code&gt; 函数 只需支持 &lt;code&gt;%c,%d&lt;/code&gt; 即可&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myPrintf(char *, ...);

main()
{
    myPrintf(&amp;quot;xxxxx%c,%n,ddddd%d&amp;quot;, &#39;x&#39;, 5);
}

void myPrintf(char *str, ...)
{
    int stackIndex = 0;
    int stringIndex = 0;
    int screenIndex = 0;
    int screenBenchmark = 160 * 10;

    while (str[stringIndex] != 0)
    {
        if (str[stringIndex] == &#39;%&#39;)
        {
            if (str[stringIndex + 1] == &#39;c&#39;)
            {
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex); /*跨 push call 第一个参数 才能取到相应的值*/
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;
                screenIndex += 2;
                stringIndex += 2;
                stackIndex += 2;
            }
            else if (str[stringIndex + 1] == &#39;d&#39;)
            {
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex) + 0x30;
                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;

                stackIndex += 2;
                screenIndex += 2;
                stringIndex += 2;
            }
            else if (str[stringIndex + 1] == &#39;n&#39;)
            {
                screenBenchmark += 160;
                screenIndex = 0;
                stringIndex += 2;
            }
        }
        else
        {
            *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = str[stringIndex];
            *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;

            screenIndex += 2;
            stringIndex += 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
">研究试验5</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验1-3补充/"" data-c="
          &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;什么时候用小模式，中模式，大模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;小程序&lt;/th&gt;
&lt;th&gt;大程序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;小数据&lt;/td&gt;
&lt;td&gt;微，小&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;大数据&lt;/td&gt;
&lt;td&gt;紧凑&lt;/td&gt;
&lt;td&gt;大，巨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小程序&lt;/strong&gt;就是指程序只有一个程序段，大小不超过64KB，缺省的码（函数）指针是near（近程指针）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大程序&lt;/strong&gt;就是指程序只有多个程序段，每个程序段不超过64KB，但总程序量可超过64KB，缺省的码指针是far（远程指针）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小数据&lt;/strong&gt;就是指数据只有一个数据段，缺省的数据指针是near。&lt;strong&gt;大数据&lt;/strong&gt;就是指数据有多个数据段，缺省的数据指针是far。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TC跟TCC有什么区别？用TCC单步编译连接生成的文件和直接生成的可执行文件有什么区别？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从功能上来看，tcc.exe只能编译当前目录下已存在的文件，而TC2.0则支持文件的创建、修改、保存、编译、连接，是集成了tcc.exe和tlink.exe的一个c语言小型开发平台。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tc所需5个文件的作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C0S.OBJ 小模式启动代码&lt;/li&gt;
&lt;li&gt;EMU.LIB 8087仿真库&lt;/li&gt;
&lt;li&gt;MATHS.LIB 是运算相关的库&lt;/li&gt;
&lt;li&gt;GRAPHICS.LIB 图形库&lt;/li&gt;
&lt;li&gt;CS.LIB 小模式运行库&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;graphics.lib在tc编译链接（提示：在菜单中有相应的设置选项）和tcc分步编译链接时是不是必须的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不是必须的
&lt;ol&gt;
&lt;li&gt;&lt;mark&gt;把 graphics.lib 删除后在通过 TCC.EXE 编译链接程序后可以正常生成 可执行文件&lt;/mark&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译和连接有什么作用？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编译&lt;/strong&gt;，就是Compile，由C编译程序对你写的代码进行词法和句法分析，发现并报告错误，有错时编译不能通过。如若无错，则生成中间代码，&lt;strong&gt;扩展名为obj&lt;/strong&gt;，此时它便是二进制的了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接&lt;/strong&gt;，在汇编里称Link，在C里叫生成，即Build，它的作用是&lt;strong&gt;生成可执行的exe文件&lt;/strong&gt;。由于一个程序的源码可由多个文件组成。这些文件在第二步 中分别编译，生成各自的目标文件，这一步的作用便是将这些obj文件，以及程序中需要的其它库文件(dll除外），统一到一个文件中来，形成单个的exe 文件。此exe文件便可以在操作系统下直接运行了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局变量在什么时候就被分配内存 ？ 函数执行之前，还是函数执行之后？是预处理的时候分配的吗？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化的全局变量，在程序加载的时候，会从程序文件中，映射到内存的数据段。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预处理的作用是什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C语言预处理程序的作用是根据源代码中的预处理指令修改你的源代码。预处理指令是一种命令语句(如#define)，它指示预处理程序如何修改源代码。在对程序进行通常的编译处理之前，编译程序会自动运行预处理程序，对程序进行编译预处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预处理在什么时候被执行的？是在程序编译前还是可执行文件执行前&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序编译前&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;malloc函数是怎么开辟内存空间的，怎么返回的?它的实现原理是什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;malloc函数其实就是在内存中找一片指定大小的空间，然后将这个空间的首地址给一个指针变量并且返回&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浮点型数据和结构体作为返回值是存放在哪里返回的?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;float dx+ax&lt;/li&gt;
&lt;li&gt;结构体 暂未解决&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尝试使用tcc -S 命令或其他方式在C0S.OBJ文件中找到main函数的标号。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个连续的ret指令，第二个ret指令也会被执行到，那么第二个ret指令的作用是什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序返回&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义&lt;code&gt;#define Buffer (char *)*(int far*)0x200&lt;/code&gt; 的理解&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;(int far*)0x200&lt;/code&gt;表示为地址 &lt;code&gt;0200：0000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*(int far*)0x200&lt;/code&gt; 表示为地址所对应的内存里的值（s）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(char *)*(int far*)0x200&lt;/code&gt; 地址（s）对应的内存存储的char型数据大小为1个字节&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">研究试验1-3补充</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验4/"" data-c="
          &lt;h1 id=&#34;研究试验4&#34;&gt;研究试验4&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;不使用 main 函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;编写程序-fc&#34;&gt;编写程序 &lt;code&gt;f.c&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;f()
{
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-将程序保存在-minc-目录下-编译链接&#34;&gt;1. 将程序保存在 &lt;code&gt;minc&lt;/code&gt; 目录下 编译链接&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在连接过程中会出现问题
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608170212786.png&#34; alt=&#34;image-20200608170212786&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提示出的缺少 &lt;code&gt;_main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可能与 &lt;code&gt;C0S&lt;/code&gt; 有关&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-用学习汇编是的-linkexe-对-tcexe-生成的-fobj-进行连接-生成-fexe&#34;&gt;2. 用学习汇编是的 &lt;code&gt;link.exe&lt;/code&gt; 对 &lt;code&gt;tc.exe&lt;/code&gt; 生成的 &lt;code&gt;f.obj&lt;/code&gt; 进行连接 生成 &lt;code&gt;f.exe&lt;/code&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;由图中可见总共由 &lt;strong&gt;303&lt;/strong&gt; 个字节
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608170929124.png&#34; alt=&#34;image-20200608170929124&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数 &lt;code&gt;f&lt;/code&gt; 实现了其功能 在屏幕中打印出 &lt;strong&gt;a&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608171139742.png&#34; alt=&#34;image-20200608171139742&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;但是函数不能正常结束 Dosbox 会卡死后然后退出
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608171415211.png&#34; alt=&#34;image-20200608171415211&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;debug 后可见 &lt;code&gt;f&lt;/code&gt;函数的偏移地址为0
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608171625247.png&#34; alt=&#34;image-20200608171625247&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-写一个-mc-在-编译-连接&#34;&gt;3. 写一个 &lt;code&gt;m.c&lt;/code&gt; 在 编译 连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main()
{
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;
    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;由图可见代码总长为 &lt;strong&gt;4280&lt;/strong&gt; 个字节
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608172758289.png&#34; alt=&#34;image-20200608172758289&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由图可见  &lt;code&gt;m.exe&lt;/code&gt; 可以正常返回 因为在执行玩 &lt;code&gt;m.exe&lt;/code&gt; 后还可以在命令行输入新的命令
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608173027098.png&#34; alt=&#34;image-20200608173027098&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m.exe&lt;/code&gt; 的汇编代码中&lt;strong&gt;main&lt;/strong&gt; 的偏移地址为 &lt;strong&gt;01fa&lt;/strong&gt; 而 &lt;code&gt;f.exe&lt;/code&gt; 中 &lt;strong&gt;f&lt;/strong&gt; 的偏移地址为 &lt;strong&gt;0000&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608173341369.png&#34; alt=&#34;main&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;H:/Books/%25E7%25BB%25BC%25E5%2590%2588%25E7%25A0%2594%25E7%25A9%25B6/0608-%25E7%25A0%2594%25E7%25A9%25B6%25E8%25AF%2595%25E9%25AA%258C4-%25E5%25AE%25A3%25E8%25AE%25B2%25E4%25BC%259A%25E7%25A0%2594%25E7%25A9%25B6%25E6%258A%25A5%25E5%2591%258A-%25E5%25B0%25B9%25E5%25BF%25A0%25E6%2581%25A9.assets/image-20200608171625247.png&#34; alt=&#34;f&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-debug-对-mexe-进行跟踪&#34;&gt;4. debug 对 m.exe 进行跟踪&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;跳转到main函数开始地址
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608173857741.png&#34; alt=&#34;image-20200608173857741&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行到 ret 后 跳转到 了 &lt;code&gt;076a：011d&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608174106973.png&#34; alt=&#34;image-20200608174106973&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;由图可以看到 在 &lt;code&gt;07fa:011a&lt;/code&gt; 中调用 &lt;code&gt;main&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608174432350.png&#34; alt=&#34;image-20200608174432350&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在执行完&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608175623677.png&#34; alt=&#34;image-20200608175623677&#34; loading=&#34;lazy&#34;&gt;划红线的ret 然后一直按&lt;strong&gt;p&lt;/strong&gt; 会找到程序的返回指令为 &lt;code&gt;int 21&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608174723076.png&#34; alt=&#34;image-20200608174723076&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-思考问题&#34;&gt;5. 思考问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;main函数的调用指令和程序返回指令应该是c0s中对应的代码中调用的&lt;/li&gt;
&lt;li&gt;没有main 函数，提示错误信息中由 “c0s” 的相关信息，因该是 tc.exe 把 在搭建环境时所需要的 文件  和 用户的 &lt;code&gt;obj&lt;/code&gt; 生成 &lt;code&gt;.exe&lt;/code&gt; 而不单单是 一个 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 main 函数的指令 因该来自于 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;link.exe&lt;/code&gt; 连接 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;debug 后的 &lt;code&gt;c0s.exe&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608182441695.png&#34; alt=&#34;image-20200608182441695&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608182616287.png&#34; alt=&#34;image-20200608182616287&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;可以看见基本结构和由用户生成的包含main 函数的基本结构相似&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-用linkexe对-c0sobj-连接生成-c0sexe&#34;&gt;6. 用&lt;code&gt;link.exe&lt;/code&gt;对 &lt;code&gt;c0s.obj&lt;/code&gt; 连接生成 &lt;code&gt;c0s.exe&lt;/code&gt;&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;c0s.exe&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;m.exe&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608183128613.png&#34; alt=&#34;image-20200608183128613&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608184824390.png&#34; alt=&#34;image-20200608184824390&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608183211934.png&#34; alt=&#34;image-20200608183211934&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608184840521.png&#34; alt=&#34;image-20200608184840521&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608183244482.png&#34; alt=&#34;image-20200608183244482&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608184854759.png&#34; alt=&#34;image-20200608184854759&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由上图可知代码开头部分两者的开始部分都相同&lt;/p&gt;
&lt;h2 id=&#34;7-对比-mexe-和-c0sexe-中调用main函数的call指令的偏移地址的后10条指令&#34;&gt;7. 对比 &lt;code&gt;m.exe&lt;/code&gt; 和 &lt;code&gt;c0s.exe&lt;/code&gt; 中调用main函数的call指令的偏移地址的后10条指令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;c0s.exe&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;m.exe&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608190030232.png&#34; alt=&#34;image-20200608190030232&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608185534954.png&#34; alt=&#34;image-20200608185534954&#34; loading=&#34;lazy&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由上图可知前10行有3行调用的不同 第一个为调用main函数然后返回到 &lt;code&gt;c0s.obj&lt;/code&gt; 中的 &lt;strong&gt;076a:011d&lt;/strong&gt;，其余的call应该也是完成相关任务后返回 &lt;code&gt;c0s.oj&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-改写-c0sobj&#34;&gt;8. 改写 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写c0s.obj&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;assume cs:code
data segment

DB 128 dup(0)

data ends

code segment
start:
    mov ax,data
    mov ds,ax
    mov ss,ax
    mov sp,128

    call s

    mov ax,4c00h
    int 21h

    s:
code ends
end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;masm&lt;/code&gt; 生成 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;tc&lt;/code&gt;  中 打开 &lt;code&gt;f.c&lt;/code&gt; 编译 连接 后可以正常生成 &lt;code&gt;f.exe&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608192023362.png&#34; alt=&#34;image-20200608192023362&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;9-debug-fexe&#34;&gt;9 debug f.exe&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608192142927.png&#34; alt=&#34;image-20200608192142927&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608192223397.png&#34; alt=&#34;image-20200608192223397&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到程序正确的调用了 &lt;code&gt;f()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;疑问&#34;&gt;疑问：&lt;/h3&gt;
&lt;p&gt;为什么汇编代码中仅仅调用了 &lt;strong&gt;s&lt;/strong&gt; 然后 &lt;strong&gt;s&lt;/strong&gt; 什么都没用，连接完后就把&lt;strong&gt;f&lt;/strong&gt;函数自动填充过去到 s 处&lt;/p&gt;
&lt;h2 id=&#34;10-编写新的fc&#34;&gt;10 编写新的&lt;code&gt;f.c&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define Buffer ((char *)*(int far *)0x02000000)
f()
{
    Buffer = 0;
    Buffer[10] = 0;
    while (Buffer[10] != 8)
    {
        Buffer[Buffer[10]] = &#39;a&#39; + Buffer[10];
        Buffer[10]++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;debug 后的 f.exe&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608210836686.png&#34; alt=&#34;image-20200608210836686&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608210902645.png&#34; alt=&#34;image-20200608210902645&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608210921844.png&#34; alt=&#34;image-20200608210921844&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608211211498.png&#34; alt=&#34;image-20200608211211498&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到编译连结完debug后的代码逻辑和汇编代码逻辑基本一致&lt;/p&gt;
&lt;h2 id=&#34;感悟&#34;&gt;感悟&lt;/h2&gt;
&lt;p&gt;C0S.OBJ的功能就是进行相关初始化，申请资源、设置DS、SS等寄存器，并且在MAIN函数结束后进行相关资源的释放、环境恢复等工作，随后调用DOS的21H程序返回。&lt;/p&gt;
">研究试验4</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验3/"" data-c="
          &lt;h1 id=&#34;研究试验3&#34;&gt;研究试验3&lt;/h1&gt;
&lt;h2 id=&#34;学习过程&#34;&gt;学习过程&lt;/h2&gt;
&lt;h3 id=&#34;1&#34;&gt;（1）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200604201716625.png&#34; alt=&#34;image-20200604201716625&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200604202304616.png&#34; alt=&#34;image-20200604202304616&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2&#34;&gt;（2）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;main()
{
    *(char far *)0x0b80009B0 = 0x61;
    *(char far *)0x0b80009B1 = 0x2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3&#34;&gt;（3）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605124949972.png&#34; alt=&#34;image-20200605124949972&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125037239.png&#34; alt=&#34;image-20200605125037239&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4&#34;&gt;（4）&lt;/h3&gt;
&lt;p&gt;书上的代码转换为的汇编&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605131126692.png&#34; alt=&#34;image-20200605131126692&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605131157695.png&#34; alt=&#34;image-20200605131157695&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5&#34;&gt;（5）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132213671.png&#34; alt=&#34;image-20200605132213671&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132236127.png&#34; alt=&#34;image-20200605132236127&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132320486.png&#34; alt=&#34;image-20200605132320486&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132336619.png&#34; alt=&#34;image-20200605132336619&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;解决的问题&#34;&gt;解决的问题&lt;/h2&gt;
&lt;h3 id=&#34;2-2&#34;&gt;（2）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605124313108.png&#34; alt=&#34;image-20200605124313108&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-2&#34;&gt;（3）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;全局变量放在内存中
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125347415.png&#34; alt=&#34;image-20200605125347415&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;局部变量放在栈中
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125422103.png&#34; alt=&#34;image-20200605125422103&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每个函数开头的 &lt;code&gt;push bp mov bp sp&lt;/code&gt; 就是为了在函数中正确的使用局部变量
&lt;ol&gt;
&lt;li&gt;main程序开始 &lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125742479.png&#34; alt=&#34;image-20200605125742479&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;main程序结束 &lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125842195.png&#34; alt=&#34;image-20200605125842195&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-2&#34;&gt;（4）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;返回值存放在 &lt;strong&gt;ax&lt;/strong&gt; 中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//由于书上的代码返回值为0，不好对比。故将 a b 赋值为 1
int f(void);

int a, b, ab;

main()
{
    int c;
    c = f();
}

int f(void)
{
    a = b = 1;//返回值为2
    ab = a + b;
    return ab;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605130645458.png&#34; alt=&#34;image-20200605130645458&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605130830428.png&#34; alt=&#34;image-20200605130830428&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-2&#34;&gt;（5）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;void *malloc(long NumBytes)&lt;/code&gt;：该函数分配了&lt;code&gt;NumBytes&lt;/code&gt;个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void free(void *FirstByte)&lt;/code&gt;： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。&lt;/p&gt;
&lt;h2 id=&#34;研究体会&#34;&gt;研究体会&lt;/h2&gt;
&lt;p&gt;本次实验较前两实验略显复杂，需要大量编译链接分析工作，通过本次实验，认识的C语言分配内存的机制&lt;/p&gt;
">研究试验3</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验2/"" data-c="
          &lt;h1 id=&#34;研究试验2&#34;&gt;研究试验2&lt;/h1&gt;
&lt;h2 id=&#34;学习过程&#34;&gt;学习过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写号&lt;strong&gt;url.c&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164231003.png&#34; alt=&#34;image-20200531164231003&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;strong&gt;TC&lt;/strong&gt; 中 编译链接生成 &lt;strong&gt;url.exe&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164208010.png&#34; alt=&#34;image-20200531164208010&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;strong&gt;DEBUG&lt;/strong&gt; 调试 &lt;strong&gt;URL.EXE&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按下 &lt;strong&gt;U&lt;/strong&gt; 调试后不像是我所写的 url.c
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164532886.png&#34; alt=&#34;image-20200531164532886&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;观察了一会儿，我试着看了看 076a:01f8 的出的代码，看见下面几行是url.c 中所写的
&lt;ol&gt;
&lt;li&gt;
&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164747917.png&#34; alt=&#34;image-20200531164747917&#34; style=&#34;zoom:150%;&#34; /&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改url.c使其打印出main的地址（按十六进制）&lt;/p&gt;
&lt;p&gt;重新编译运行后答应出main函数的地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531165157632.png&#34; alt=&#34;image-20200531165157632&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以看到 &lt;code&gt;1fa&lt;/code&gt; 处对应的代码为 &lt;code&gt;push BP&lt;/code&gt;和 图 在第三步中观察到的一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写，编译，链接，debug &lt;code&gt;ur2.c&lt;/code&gt; ，跳转到main 函数执行位置可以看到在main函数中调用了子程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531170601321.png&#34; alt=&#34;image-20200531170601321&#34; style=&#34;zoom:150%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决的问题&#34;&gt;解决的问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;main函数在汇编语言的代码段中，&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531163450988.png&#34; alt=&#34;image-20200531163450988&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;图中的 &lt;code&gt;mov 01f8,dx&lt;/code&gt;为main的人口地址&lt;/li&gt;
&lt;li&gt;main函数应该也是一个代码段中的子功能&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;研究体会&#34;&gt;研究体会&lt;/h2&gt;
&lt;p&gt;c 语言的函数调用本质上就是包装了汇编中的调用子函数和子程序返回的相关指令&lt;/p&gt;
">研究试验2</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/研究试验1/"" data-c="
          &lt;h1 id=&#34;研究试验1&#34;&gt;研究试验1&lt;/h1&gt;
&lt;h2 id=&#34;1-学习过程&#34;&gt;1. 学习过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 tc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;minic&lt;/strong&gt;下导入&lt;strong&gt;tc.exe&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215125606.png&#34; alt=&#34;image-20200530215125606&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在dosbox中用 &lt;strong&gt;TC&lt;/strong&gt; 打开事先 写好的 &lt;strong&gt;Simple.c&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dosbox 的配置文件中添加下列三行&lt;/p&gt;
&lt;p&gt;​	MOUNT c: F:\GitHub\ASM-\minic&lt;/p&gt;
&lt;p&gt;​	c:&lt;/p&gt;
&lt;p&gt;​	tc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译 simple.c&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成obj文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215307318.png&#34; alt=&#34;image-20200530215307318&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215345246.png&#34; alt=&#34;image-20200530215345246&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215822177.png&#34; alt=&#34;image-20200530215822177&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215911676.png&#34; alt=&#34;image-20200530215911676&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215949585.png&#34; alt=&#34;image-20200530215949585&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220128341.png&#34; alt=&#34;image-20200530220128341&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220215027.png&#34; alt=&#34;image-20200530220215027&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220301146.png&#34; alt=&#34;image-20200530220301146&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220350556.png&#34; alt=&#34;image-20200530220350556&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-解决的问题&#34;&gt;2. 解决的问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;编译这个c文件，不需要&lt;strong&gt;tc&lt;/strong&gt;目录中所有的文件.只需再加5个就可以完成基本的c文件的链接。&lt;/li&gt;
&lt;li&gt;在option选项中吧dictionary中的配置的默认目录全部删除后就可以找到链接中新添加的文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-研究体会&#34;&gt;4. 研究体会&lt;/h2&gt;
&lt;p&gt;经过此次实验，我们顺利的找出了TC中和编译链接一个C语言程序相关的文件，熟悉了TC的使用&lt;/p&gt;
">研究试验1</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-外中断/"" data-c="
          &lt;h1 id=&#34;接口芯片和端口&#34;&gt;接口芯片和端口&lt;/h1&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;端口的读写只有&lt;strong&gt;in&lt;/strong&gt;,&lt;strong&gt;out&lt;/strong&gt; , 一个读一个写（CPU的视角来看）&lt;/li&gt;
&lt;li&gt;访问端口&lt;br&gt;
CPU 通过地址线 将 &lt;strong&gt;60h&lt;/strong&gt;的信息发出&lt;br&gt;
通过控制线发出读命令&lt;br&gt;
端口所在的芯片将&lt;strong&gt;60h&lt;/strong&gt;端口的数据通过数据总线将数据送入CPU&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;外中断&#34;&gt;外中断&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-可屏蔽中断&#34;&gt;1. 可屏蔽中断&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;IF=0 CPU 可以不响应可屏蔽中断&lt;/li&gt;
&lt;li&gt;IF=1 执行完当前指令后执行中断&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-不可屏蔽终端&#34;&gt;2. 不可屏蔽终端&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不可屏蔽中断的中断类型码固定为&lt;strong&gt;2&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;pc机键盘的处理过程&#34;&gt;PC机键盘的处理过程&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-键盘输入&#34;&gt;1. 键盘输入&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;扫描码（通码）送入 &lt;strong&gt;60h&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;断码 = 通码 + 80h&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-引发9号中断&#34;&gt;2. 引发9号中断&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有数据送入 &lt;strong&gt;60h&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;芯片向 &lt;strong&gt;CPU&lt;/strong&gt; 发出 中断类型码为 &lt;strong&gt;9&lt;/strong&gt;的可屏蔽中断&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;IF=1&lt;/strong&gt; CPU 执行中断例程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-执行9号中断例程&#34;&gt;3. 执行9号中断例程&lt;/h2&gt;
&lt;h3 id=&#34;int9-的基本键盘处理流程&#34;&gt;int9 的基本键盘处理流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;读出 &lt;strong&gt;60h&lt;/strong&gt; 的扫描码
&lt;ul&gt;
&lt;li&gt;如果是扫描码 将扫描码和字符码送入内存中的键盘缓冲区&lt;/li&gt;
&lt;li&gt;如果是控制键的扫描码则将其转变为状态字节存入内存中的状态字节的单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对键盘系统进行相关控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;编写中断例程&#34;&gt;编写中断例程&lt;/h1&gt;
&lt;p&gt;新的中断例程大概为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从60h端口读出键盘的输入
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;in al 60h&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;调用BIOS 的int9 的中断例程
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;pushf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call dword ptr cs:[200h] ;cs==0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;功能的实现&lt;/li&gt;
&lt;/ol&gt;
">汇编语言-外中断</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/13-int指令/"" data-c="
          &lt;h1 id=&#34;第13章-int-指令&#34;&gt;第13章 int 指令&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;属于内中断的一种&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;int指令&#34;&gt;int指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令格式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int n&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取中断类型码 &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;标志寄存器入栈，IF = 0，TF = 0&lt;/li&gt;
&lt;li&gt;CS:IP 入栈&lt;/li&gt;
&lt;li&gt;CS:IP 指向中断向量表中的中断地址&lt;/li&gt;
&lt;li&gt;转去执行终端程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;供程序调用的中断例程&#34;&gt;供程序调用的中断例程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;int 和 iret 配合使用 类似 call 和 ret&lt;/li&gt;
&lt;li&gt;注意把中断程序中用到的寄存器压到栈中，避免寄存器冲突&lt;/li&gt;
&lt;/ul&gt;
">13-int指令</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/MVC-EL-JSTL笔记/"" data-c="
          &lt;h1 id=&#34;mvc开发模式&#34;&gt;MVC:开发模式&lt;/h1&gt;
&lt;h2 id=&#34;1-jsp演变历史&#34;&gt;1. jsp演变历史&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;早期只有servlet，只能使用response输出标签数据，非常麻烦&lt;/li&gt;
&lt;li&gt;后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作&lt;/li&gt;
&lt;li&gt;再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2mvc&#34;&gt;2.MVC：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;M：Model，模型。JavaBean&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成具体的业务操作，如：查询数据库，封装对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;V：View，视图。JSP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展示数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C：Controller，控制器。Servlet&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取用户的输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数据交给视图进行展示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优缺点&#34;&gt;优缺点：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;耦合性低，方便维护，可以利于分工协作&lt;/li&gt;
&lt;li&gt;重用性高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;使得项目架构变得复杂，对开发人员要求高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;el表达式&#34;&gt;EL表达式&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念：&lt;/h2&gt;
&lt;p&gt;Expression Language 表达式语言&lt;/p&gt;
&lt;h2 id=&#34;作用&#34;&gt;作用：&lt;/h2&gt;
&lt;p&gt;替换和简化jsp页面中java代码的编写&lt;/p&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法：&lt;/h2&gt;
&lt;p&gt;${表达式}&lt;/p&gt;
&lt;h2 id=&#34;注意&#34;&gt;注意：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;jsp默认支持el表达式的。如果要忽略el表达式
&lt;ul&gt;
&lt;li&gt;设置jsp中page指令中：isELIgnored=&amp;quot;true&amp;quot; 忽略当前jsp页面中所有的el表达式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;\${表达式}&lt;/strong&gt; ：忽略当前这个el表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用：&lt;/h2&gt;
&lt;h3 id=&#34;1-运算&#34;&gt;1. 运算：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;运算符：
&lt;ol&gt;
&lt;li&gt;算数运算符： + - * /(div) %(mod)算数运算符： + - * /(div) %(mod)算数运算符： + - * /(div) %(mod)&lt;/li&gt;
&lt;li&gt;比较运算符： &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= == !=&lt;/li&gt;
&lt;li&gt;逻辑运算符： &amp;amp;&amp;amp;(and) ||(or) !(not)&lt;/li&gt;
&lt;li&gt;空运算符： empty
&lt;ul&gt;
&lt;li&gt;功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0&lt;/li&gt;
&lt;li&gt;${empty list}:判断字符串、集合、数组对象是否为null或者长度为0&lt;/li&gt;
&lt;li&gt;${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&amp;gt;0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-获取值&#34;&gt;2. 获取值&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;el表达式只能从域对象中获取值&lt;/li&gt;
&lt;li&gt;语法：
&lt;ol&gt;
&lt;li&gt;${域名称.键名}：从指定域中获取指定键的值&lt;/li&gt;
&lt;li&gt;域名称：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;pageScope      --&amp;gt; pageContext&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;requestScope   --&amp;gt; request&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sessionScope   --&amp;gt; session&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;applicationScope --&amp;gt; application（ServletContext）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;举例：在request域中存储了name=张三&lt;/li&gt;
&lt;li&gt;获取：${requestScope.name}&lt;/li&gt;
&lt;li&gt;${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。&lt;/li&gt;
&lt;li&gt;获取对象、List集合、Map集合的值&lt;/li&gt;
&lt;li&gt;对象：${域名称.键名.属性名}&lt;/li&gt;
&lt;li&gt;质上会去调用对象的getter方法&lt;/li&gt;
&lt;li&gt;List集合：${域名称.键名[索引]}&lt;/li&gt;
&lt;li&gt;Map集合：
&lt;ol&gt;
&lt;li&gt;${域名称.键名.key名称}&lt;/li&gt;
&lt;li&gt;${域名称.键名[&amp;quot;key名称&amp;quot;]}&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-隐式对象&#34;&gt;3. 隐式对象：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;el表达式中有11个隐式对象&lt;/li&gt;
&lt;li&gt;pageContext：&lt;/li&gt;
&lt;li&gt;获取jsp其他八个内置对象
&lt;ol&gt;
&lt;li&gt;${pageContext.request.contextPath}：动态获取虚拟目录&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;jstl&#34;&gt;JSTL&lt;/h1&gt;
&lt;h2 id=&#34;1-概念&#34;&gt;1. 概念：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JavaServer Pages Tag Library  JSP标准标签库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是由Apache组织提供的开源的免费的jsp标签        &amp;lt;标签&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-作用&#34;&gt;2.  作用：&lt;/h2&gt;
&lt;p&gt;**用于简化和替换jsp页面上的java代码     **&lt;/p&gt;
&lt;h2 id=&#34;3-使用步骤&#34;&gt;3. 使用步骤：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;导入jstl相关jar包&lt;/li&gt;
&lt;li&gt;引入标签库：taglib指令：  &amp;lt;%@ taglib %&amp;gt;&lt;/li&gt;
&lt;li&gt;使用标签&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-常用的jstl标签&#34;&gt;4 常用的JSTL标签&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;if:相当于java代码的if语句
&lt;ol&gt;
&lt;li&gt;属性：
&lt;ol&gt;
&lt;li&gt;test 必须属性，接受boolean表达式
&lt;ol&gt;
&lt;li&gt;如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容&lt;/li&gt;
&lt;li&gt;一般情况下，test属性值会结合el表达式一起使用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ol&gt;
&lt;li&gt;c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;choose:相当于java代码的switch语句
&lt;ol&gt;
&lt;li&gt;使用choose标签声明                  相当于switch声明&lt;/li&gt;
&lt;li&gt;使用when标签做判断                  相当于case&lt;/li&gt;
&lt;li&gt;使用otherwise标签做其他情况的声明        相当于default&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;foreach:相当于java代码的for语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;三层架构软件设计架构&#34;&gt;三层架构：软件设计架构&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑层：处理业务逻辑的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据访问层：操作数据存储文件。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;案例用户信息列表展示&#34;&gt;案例：用户信息列表展示&lt;/h1&gt;
">MVC&EL&JSTL笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/Cookie-Session/"" data-c="
          &lt;h1 id=&#34;会话技术&#34;&gt;会话技术&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;会话&lt;/strong&gt;：一次会话中包含多次请求和响应。
&lt;ul&gt;
&lt;li&gt;一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：在一次会话的范围内的多次请求间，共享数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方式&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;客户端会话技术：&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务器端会话技术：&lt;strong&gt;Session&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie：&lt;/h2&gt;
&lt;h3 id=&#34;1-概念&#34;&gt;1. 概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;客户端会话技术，将数据保存到客户端&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-快速入门&#34;&gt;2. 快速入门：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建Cookie对象，绑定数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Cookie(String name, String value) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送Cookie对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;response.addCookie(Cookie cookie) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取Cookie，拿到数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Cookie[]  request.getCookies()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-实现原理&#34;&gt;3.  实现原理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基于响应头set-cookie和请求头cookie实现&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-cookie的细节&#34;&gt;4. cookie的细节&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一次可不可以发送多个cookie?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以&lt;/p&gt;
&lt;p&gt;可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cookie在浏览器中保存多长时间？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认情况下，当浏览器关闭后，Cookie数据被销毁&lt;/li&gt;
&lt;li&gt;持久化存储：&lt;strong&gt;setMaxAge(int seconds)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;正数: 将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效&lt;/li&gt;
&lt;li&gt;负数：默认值&lt;/li&gt;
&lt;li&gt;零：删除cookie信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cookie能不能存中文？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在tomcat 8 之前 cookie中不能直接存储中文数据。
&lt;ul&gt;
&lt;li&gt;需要将中文数据转码---一般采用URL编码(%E3)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cookie共享问题？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？
&lt;ul&gt;
&lt;li&gt;默认情况下cookie不能共享&lt;/li&gt;
&lt;li&gt;setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录
&lt;ul&gt;
&lt;li&gt;如果要共享，则可以将path设置为&amp;quot;/&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同的tomcat服务器间cookie共享问题？
&lt;ul&gt;
&lt;li&gt;setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享
&lt;ul&gt;
&lt;li&gt;setDomain(&amp;quot;.baidu.com&amp;quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-cookie的特点和作用&#34;&gt;5. Cookie的特点和作用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;cookie存储数据在客户端浏览器&lt;/li&gt;
&lt;li&gt;浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;作用：
&lt;ul&gt;
&lt;li&gt;cookie一般用于存出少量的不太敏感的数据&lt;/li&gt;
&lt;li&gt;在不登录的情况下，完成服务器对客户端的身份识别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-案例记住上一次访问时间&#34;&gt;6. 案例：记住上一次访问时间&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以采用Cookie来完成&lt;/li&gt;
&lt;li&gt;在服务器中的Servlet判断是否有一个名为lastTime的cookie
&lt;ol&gt;
&lt;li&gt;有：不是第一次访问
&lt;ol&gt;
&lt;li&gt;响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20&lt;/li&gt;
&lt;li&gt;写回Cookie：lastTime=2018年6月10日11:50:01&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;没有：是第一次访问
&lt;ol&gt;
&lt;li&gt;响应数据：您好，欢迎您首次访问&lt;/li&gt;
&lt;li&gt;写回Cookie：lastTime=2018年6月10日11:50:01&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.itcast.cookie;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.Date;

@WebServlet(&amp;quot;/CookieTest&amp;quot;)
public class CookieTest extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //设置响应的消息体的数据格式以及编码
        response.setContentType(&amp;quot;text/html;charset=utf-8&amp;quot;);
        //1.获取所有Cookie
        Cookie[] cookies = request.getCookies();
        boolean flag = false;//没有cookie为lastTime
        //2.遍历cookie数组
        if(cookies != null &amp;amp;&amp;amp; cookies.length &amp;gt; 0){
            for (Cookie cookie : cookies) {
                //3.获取cookie的名称
                String name = cookie.getName();
                //4.判断名称是否是：lastTime
                if(&amp;quot;lastTime&amp;quot;.equals(name)){
                    //有该Cookie，不是第一次访问

                    flag = true;//有lastTime的cookie

                    //设置Cookie的value
                    //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
                    Date date  = new Date();
                    SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);
                    String str_date = sdf.format(date);
                    System.out.println(&amp;quot;编码前：&amp;quot;+str_date);
                    //URL编码
                    str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);
                    System.out.println(&amp;quot;编码后：&amp;quot;+str_date);
                    cookie.setValue(str_date);
                    //设置cookie的存活时间
                    cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
                    response.addCookie(cookie);


                    //响应数据
                    //获取Cookie的value，时间
                    String value = cookie.getValue();
                    System.out.println(&amp;quot;解码前：&amp;quot;+value);
                    //URL解码：
                    value = URLDecoder.decode(value,&amp;quot;utf-8&amp;quot;);
                    System.out.println(&amp;quot;解码后：&amp;quot;+value);
                    response.getWriter().write(&amp;quot;&amp;lt;h1&amp;gt;欢迎回来，您上次访问时间为:&amp;quot;+value+&amp;quot;&amp;lt;/h1&amp;gt;&amp;quot;);


                    break;

                }
            }
        }
        if(cookies == null || cookies.length == 0 || flag == false){
            //没有，第一次访问

            //设置Cookie的value
            //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
            Date date  = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);
            String str_date = sdf.format(date);
            System.out.println(&amp;quot;编码前：&amp;quot;+str_date);
            //URL编码
            str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);
            System.out.println(&amp;quot;编码后：&amp;quot;+str_date);

            Cookie cookie = new Cookie(&amp;quot;lastTime&amp;quot;,str_date);
            //设置cookie的存活时间
            cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
            response.addCookie(cookie);

            response.getWriter().write(&amp;quot;&amp;lt;h1&amp;gt;您好，欢迎您首次访问&amp;lt;/h1&amp;gt;&amp;quot;);
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;session主菜&#34;&gt;Session：主菜&lt;/h2&gt;
&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;快速入门&#34;&gt;快速入门：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取HttpSession对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;HttpSession session = request.getSession();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用HttpSession对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   Object getAttribute(String name)  
    void setAttribute(String name, Object value)
    void removeAttribute(String name)  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Session的实现是依赖于Cookie的。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当客户端关闭后，服务器不关闭，两次获取session是否为同一个？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;默认情况下。不是。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Cookie c = new Cookie(&amp;quot;JSESSIONID&amp;quot;,session.getId());
c.setMaxAge(60*60);
response.addCookie(c);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端不关闭，服务器关闭后，两次获取的session是同一个吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作
&lt;ul&gt;
&lt;li&gt;session的钝化：
&lt;ul&gt;
&lt;li&gt;在服务器正常关闭之前，将session对象系列化到硬盘上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;session的活化：
&lt;ul&gt;
&lt;li&gt;在服务器启动后，将session文件转化为内存中的session对象即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;session什么时候被销毁？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务器关闭&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;session对象调用invalidate() 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;session默认失效时间 30分钟&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;session-config&amp;gt;
        &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt;
    &amp;lt;/session-config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;session的特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;session用于存储一次会话的多次请求的数据，存在服务器端&lt;/li&gt;
&lt;li&gt;session可以存储任意类型，任意大小的数据(&lt;strong&gt;类比Cookie&lt;/strong&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;session与Cookie的区别：
&lt;ol&gt;
&lt;li&gt;session存储数据在服务器端，Cookie在客户端&lt;/li&gt;
&lt;li&gt;session没有数据大小限制，Cookie有&lt;/li&gt;
&lt;li&gt;session数据安全，Cookie相对于不安全&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;案例验证码&#34;&gt;案例：验证码&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;案例需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问带有验证码的登录页面login.jsp&lt;/li&gt;
&lt;li&gt;用户输入用户名，密码以及验证码。用户输入用户名，密码以及验证码。
&lt;ul&gt;
&lt;li&gt;如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误&lt;/li&gt;
&lt;li&gt;如果验证码输入有误，跳转登录页面，提示：验证码错误&lt;/li&gt;
&lt;li&gt;如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;login&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;
&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;login&amp;lt;/title&amp;gt;

    &amp;lt;script&amp;gt;
        window.onload = function(){
            document.getElementById(&amp;quot;img&amp;quot;).onclick = function(){
                this.src=&amp;quot;/day16_cookie_war_exploded/CheckCodeServlet&amp;quot;+new Date().getTime();
            }
        }


    &amp;lt;/script&amp;gt;

    &amp;lt;style&amp;gt;
        div{
            color: red;
        }

    &amp;lt;/style&amp;gt;


&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;form action=&amp;quot;/day16_cookie_war_exploded/LoginServlet&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    &amp;lt;table&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;用户名&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;密码&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;验证码&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;checkCode&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td colspan=&amp;quot;2&amp;quot;&amp;gt;&amp;lt;img id=&amp;quot;img&amp;quot; src=&amp;quot;/day16_cookie_war_exploded/CheckCodeServlet&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td colspan=&amp;quot;2&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;登录&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;


&amp;lt;/form&amp;gt;


&amp;lt;div&amp;gt;&amp;lt;%=request.getAttribute(&amp;quot;cc_error&amp;quot;) == null ? &amp;quot;&amp;quot; : request.getAttribute(&amp;quot;cc_error&amp;quot;)%&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;%=request.getAttribute(&amp;quot;login_error&amp;quot;) == null ? &amp;quot;&amp;quot; : request.getAttribute(&amp;quot;login_error&amp;quot;) %&amp;gt;&amp;lt;/div&amp;gt;


&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;success&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;
&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;success&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;&amp;lt;%=request.getSession().getAttribute(&amp;quot;user&amp;quot;)%&amp;gt;,欢迎您&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CheckCodeServlet&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.itcast.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

@WebServlet(&amp;quot;/CheckCodeServlet&amp;quot;)
public class CheckCodeServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        int width = 100;
        int height = 50;

        //1.创建一对象，在内存中图片(验证码图片对象)
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);


        //2.美化图片
        //2.1 填充背景色
        Graphics g = image.getGraphics();//画笔对象
        g.setColor(Color.PINK);//设置画笔颜色
        g.fillRect(0,0,width,height);

        //2.2画边框
        g.setColor(Color.BLUE);
        g.drawRect(0,0,width - 1,height - 1);

        String str = &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789&amp;quot;;
        //生成随机角标
        Random ran = new Random();
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i &amp;lt;= 4; i++) {
            int index = ran.nextInt(str.length());
            //获取字符
            char ch = str.charAt(index);//随机字符
            sb.append(ch);

            //2.3写验证码
            g.drawString(ch+&amp;quot;&amp;quot;,width/5*i,height/2);
        }
        String checkCode_session = sb.toString();
        //将验证码存入session
        request.getSession().setAttribute(&amp;quot;checkCode_session&amp;quot;,checkCode_session);

        //2.4画干扰线
        g.setColor(Color.GREEN);

        //随机生成坐标点

        for (int i = 0; i &amp;lt; 10; i++) {
            int x1 = ran.nextInt(width);
            int x2 = ran.nextInt(width);

            int y1 = ran.nextInt(height);
            int y2 = ran.nextInt(height);
            g.drawLine(x1,y1,x2,y2);
        }


        //3.将图片输出到页面展示
        ImageIO.write(image,&amp;quot;jpg&amp;quot;,response.getOutputStream());
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LoginServlet&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package cn.itcast.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebServlet(&amp;quot;/LoginServlet&amp;quot;)
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.设置request编码
        request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
        //2.获取参数
        String username = request.getParameter(&amp;quot;username&amp;quot;);
        String password = request.getParameter(&amp;quot;password&amp;quot;);
        String checkCode = request.getParameter(&amp;quot;checkCode&amp;quot;);
        //3.先获取生成的验证码
        HttpSession session = request.getSession();
        String checkCode_session = (String) session.getAttribute(&amp;quot;checkCode_session&amp;quot;);
        //删除session中存储的验证码
        session.removeAttribute(&amp;quot;checkCode_session&amp;quot;);
        //3.先判断验证码是否正确
        if(checkCode_session!= null &amp;amp;&amp;amp; checkCode_session.equalsIgnoreCase(checkCode)){
            //忽略大小写比较
            //验证码正确
            //判断用户名和密码是否一致
            if(&amp;quot;zhangsan&amp;quot;.equals(username) &amp;amp;&amp;amp; &amp;quot;123&amp;quot;.equals(password)){//需要调用UserDao查询数据库
                //登录成功
                //存储信息，用户信息
                session.setAttribute(&amp;quot;user&amp;quot;,username);
                //重定向到success.jsp
                response.sendRedirect(request.getContextPath()+&amp;quot;/success.jsp&amp;quot;);
            }else{
                //登录失败
                //存储提示信息到request
                request.setAttribute(&amp;quot;login_error&amp;quot;,&amp;quot;用户名或密码错误&amp;quot;);
                //转发到登录页面
                request.getRequestDispatcher(&amp;quot;/login.jsp&amp;quot;).forward(request,response);
            }


        }else{
            //验证码不一致
            //存储提示信息到request
            request.setAttribute(&amp;quot;cc_error&amp;quot;,&amp;quot;验证码错误&amp;quot;);
            //转发到登录页面
            request.getRequestDispatcher(&amp;quot;/login.jsp&amp;quot;).forward(request,response);

        }

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;jsp入门学习&#34;&gt;JSP：入门学习&lt;/h1&gt;
&lt;h2 id=&#34;概念-2&#34;&gt;概念：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java Server Pages： java服务器端页面&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于简化书写！！！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JSP本质上就是一个Servlet&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jsp的脚本jsp定义java代码的方式&#34;&gt;JSP的脚本：JSP定义Java代码的方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;&lt;strong&gt;%&lt;/strong&gt;  代码 %&amp;gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;strong&gt;%!&lt;/strong&gt; 代码 %&amp;gt;：定义的java代码，在jsp转换后的java类的成员位置。&lt;/li&gt;
&lt;li&gt;&amp;lt;%= 代码 %&amp;gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;jsp的内置对象&#34;&gt;JSP的内置对象：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在jsp页面中不需要获取和创建，可以直接使用的对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jsp一共有9个内置对象。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;今天学习3个：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;request&lt;/li&gt;
&lt;li&gt;response&lt;/li&gt;
&lt;li&gt;out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似
&lt;ul&gt;
&lt;li&gt;response.getWriter()和out.write()的区别：
&lt;ul&gt;
&lt;li&gt;在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。&lt;/li&gt;
&lt;li&gt;response.getWriter()数据输出永远在out.write()之前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;案例改造cookie案例&#34;&gt;案例:改造Cookie案例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;%@ page import=&amp;quot;java.util.Date&amp;quot; %&amp;gt;
&amp;lt;%@ page import=&amp;quot;java.text.SimpleDateFormat&amp;quot; %&amp;gt;
&amp;lt;%@ page import=&amp;quot;java.net.URLEncoder&amp;quot; %&amp;gt;
&amp;lt;%@ page import=&amp;quot;java.net.URLDecoder&amp;quot; %&amp;gt;
&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;home&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;


&amp;lt;%

    //1.获取所有Cookie
    Cookie[] cookies = request.getCookies();
    boolean flag = false;//没有cookie为lastTime
    //2.遍历cookie数组
    if(cookies != null &amp;amp;&amp;amp; cookies.length &amp;gt; 0){
        for (Cookie cookie : cookies) {
            //3.获取cookie的名称
            String name = cookie.getName();
            //4.判断名称是否是：lastTime
            if(&amp;quot;lastTime&amp;quot;.equals(name)){
                //有该Cookie，不是第一次访问

                flag = true;//有lastTime的cookie

                //设置Cookie的value
                //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
                Date date  = new Date();
                SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);
                String str_date = sdf.format(date);
                System.out.println(&amp;quot;编码前：&amp;quot;+str_date);
                //URL编码
                str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);
                System.out.println(&amp;quot;编码后：&amp;quot;+str_date);
                cookie.setValue(str_date);
                //设置cookie的存活时间
                cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
                response.addCookie(cookie);


                //响应数据
                //获取Cookie的value，时间
                String value = cookie.getValue();
                System.out.println(&amp;quot;解码前：&amp;quot;+value);
                //URL解码：
                value = URLDecoder.decode(value,&amp;quot;utf-8&amp;quot;);
                System.out.println(&amp;quot;解码后：&amp;quot;+value);
%&amp;gt;
&amp;lt;h1&amp;gt;欢迎回来，您上次访问时间为:&amp;lt;%=value%&amp;gt;&amp;lt;/h1&amp;gt;
&amp;lt;input&amp;gt;

&amp;lt;%



                break;

            }
        }
    }


    if(cookies == null || cookies.length == 0 || flag == false){
        //没有，第一次访问

        //设置Cookie的value
        //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
        Date date  = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);
        String str_date = sdf.format(date);
        System.out.println(&amp;quot;编码前：&amp;quot;+str_date);
        //URL编码
        str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);
        System.out.println(&amp;quot;编码后：&amp;quot;+str_date);

        Cookie cookie = new Cookie(&amp;quot;lastTime&amp;quot;,str_date);
        //设置cookie的存活时间
        cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
        response.addCookie(cookie);

%&amp;gt;

&amp;lt;h1&amp;gt;您好，欢迎您首次访问&amp;lt;/h1&amp;gt;
&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;

&amp;lt;%
    }

%&amp;gt;

&amp;lt;input&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;指令&#34;&gt;指令&lt;/h2&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用：用于配置JSP页面，导入资源文件&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;page      ： 配置JSP页面的&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;contentType：等同于response.setContentType()
&lt;ol&gt;
&lt;li&gt;设置响应体的mime类型以及字符集&lt;/li&gt;
&lt;li&gt;设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;import：导包&lt;/li&gt;
&lt;li&gt;errorPage：当前页面发生异常后，会自动跳转到指定的错误页面&lt;/li&gt;
&lt;li&gt;isErrorPage：标识当前也是是否是错误页面。
&lt;ul&gt;
&lt;li&gt;true：是，可以使用内置对象exception&lt;/li&gt;
&lt;li&gt;false：否。默认值。不可以使用内置对象exception&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;include   ： 页面包含的。导入页面的资源文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@include file=&amp;quot;top.jsp&amp;quot;%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;taglib    ： 导入资源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;html注释：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;!-- --&gt;:只能注释html代码片段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在网页源码中&lt;/li&gt;
&lt;li&gt;jsp注释：推荐使用
&lt;ol&gt;
&lt;li&gt;&amp;lt;%-- --%&amp;gt;：可以注释所有&lt;/li&gt;
&lt;li&gt;不会在网页源码中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;内置对象&#34;&gt;内置对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在jsp页面中不需要创建，直接使用的对象&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量名&lt;/th&gt;
&lt;th&gt;真实类型&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pageContext&lt;/td&gt;
&lt;td&gt;PageContext&lt;/td&gt;
&lt;td&gt;当前页面共享数据，还可以获取其他八个内置对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;HttpServletRequest&lt;/td&gt;
&lt;td&gt;一次请求访问的多个资源(转发)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;session&lt;/td&gt;
&lt;td&gt;HttpSession&lt;/td&gt;
&lt;td&gt;一次会话的多个请求间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;application&lt;/td&gt;
&lt;td&gt;ServletContext&lt;/td&gt;
&lt;td&gt;所有用户间共享数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;response&lt;/td&gt;
&lt;td&gt;HttpServletResponse&lt;/td&gt;
&lt;td&gt;响应对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;当前页面(Servlet)的对象  this&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;td&gt;JspWriter&lt;/td&gt;
&lt;td&gt;输出对象，数据输出到页面上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;ServletConfig&lt;/td&gt;
&lt;td&gt;Servlet的配置对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;exception&lt;/td&gt;
&lt;td&gt;Throwable&lt;/td&gt;
&lt;td&gt;异常对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Cookie&&Session</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/Python入门/"" data-c="
          &lt;h1 id=&#34;入门&#34;&gt;入门&lt;/h1&gt;
&lt;h1 id=&#34;python变量和数据类型&#34;&gt;Python变量和数据类型&lt;/h1&gt;
&lt;h2 id=&#34;1-python中数据类型&#34;&gt;1. Python中数据类型&lt;/h2&gt;
&lt;p&gt;计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;100&lt;/code&gt;，&lt;code&gt;-8080&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt;，等等。&lt;/p&gt;
&lt;p&gt;计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用&lt;code&gt;0x&lt;/code&gt;前缀和0-9，a-f表示，例如：&lt;code&gt;0xff00&lt;/code&gt;，&lt;code&gt;0xa5b4c3d2&lt;/code&gt;，等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10&lt;sup&gt;9和12.3x10&lt;/sup&gt;8是相等的。浮点数可以用数学写法，如&lt;code&gt;1.23&lt;/code&gt;，&lt;code&gt;3.14&lt;/code&gt;，&lt;code&gt;-9.01&lt;/code&gt;，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是&lt;strong&gt;1.23e9&lt;/strong&gt;，或者&lt;strong&gt;12.3e8&lt;/strong&gt;，0.000012可以写成&lt;strong&gt;1.2e-5&lt;/strong&gt;，等等。&lt;/p&gt;
&lt;p&gt;整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串是以&lt;code&gt;&#39;&#39;&lt;/code&gt;或&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;括起来的任意文本，比如**&#39;abc&#39;&lt;strong&gt;，&lt;/strong&gt;&amp;quot;xyz&amp;quot;&lt;strong&gt;等等。请注意，&lt;/strong&gt;&#39;&#39;&lt;strong&gt;或&lt;/strong&gt;&amp;quot;&amp;quot;**本身只是一种表示方式，不是字符串的一部分，因此，字符串&lt;code&gt;&#39;abc&#39;&lt;/code&gt;只有&lt;code&gt;a，b，c&lt;/code&gt;这3个字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、布尔值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;布尔值和布尔代数的表示完全一致，一个布尔值只有&lt;code&gt;True&lt;/code&gt;、&lt;code&gt;False&lt;/code&gt;两种值，要么是&lt;code&gt;True&lt;/code&gt;，要么是&lt;code&gt;False&lt;/code&gt;，在Python中，可以直接用&lt;code&gt;True&lt;/code&gt;、&lt;code&gt;False&lt;/code&gt;表示布尔值（请注意大小写），也可以通过布尔运算计算出来。&lt;/p&gt;
&lt;p&gt;布尔值可以用&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;not&lt;/code&gt;运算。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;and&lt;/code&gt;运算是与运算，只有所有都为 True，and运算结果才是 True。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;or&lt;/code&gt;运算是或运算，只要其中有一个为 True，or 运算结果就是 True。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;not&lt;/code&gt;运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、空值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空值是Python里一个特殊的值，用&lt;code&gt;None&lt;/code&gt;表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。&lt;/p&gt;
&lt;p&gt;此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到&lt;/p&gt;
&lt;h2 id=&#34;2-python之print语句&#34;&gt;2. Python之print语句&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;print&lt;/strong&gt;语句可以向屏幕上输出指定的文字。比如输出&#39;hello, world&#39;，用代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print &#39;hello, world&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.当我们在Python交互式环境下编写代码时，&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;是Python解释器的提示符，不是代码的一部分。&lt;/p&gt;
&lt;p&gt;2.当我们在文本编辑器中编写代码时，千万不要自己添加 &amp;gt;&amp;gt;&amp;gt;。&lt;/p&gt;
&lt;p&gt;print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print &#39;The quick brown fox&#39;, &#39;jumps over&#39;, &#39;the lazy dog&#39;
The quick brown fox jumps over the lazy dog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：&lt;/p&gt;
&lt;p&gt;{% asset_img 54055502000179c205060086.jpg %}&lt;/p&gt;
&lt;p&gt;print也可以打印整数，或者计算结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print 300
300    #运行结果
&amp;gt;&amp;gt;&amp;gt; print 100 + 200
300    #运行结果
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，我们可以把计算100 + 200的结果打印得更漂亮一点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print &#39;100 + 200 =&#39;, 100 + 200
100 + 200 = 300     #运行结果
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 对于100 + 200，Python解释器自动计算出结果300，但是，&#39;100 + 200 =&#39;是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。&lt;/p&gt;
&lt;h2 id=&#34;3-python的注释&#34;&gt;3. Python的注释&lt;/h2&gt;
&lt;p&gt;任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。&lt;/p&gt;
&lt;p&gt;Python的注释以&lt;code&gt;#&lt;/code&gt;开头，后面的文字直到行尾都算注释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 这一行全部都是注释...
print &#39;hello&#39; # 这也是注释
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 暂时不想运行下面一行代码:
# print &#39;hello, python.&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-python中什么是变量&#34;&gt;4. Python中什么是变量&lt;/h2&gt;
&lt;p&gt;在Python中，变量的概念基本上和初中代数的方程变量是一致的。&lt;/p&gt;
&lt;p&gt;例如，对于方程式 &lt;code&gt;y=x*x&lt;/code&gt;，&lt;code&gt;x&lt;/code&gt;就是变量。当&lt;code&gt;x=2&lt;/code&gt;时，计算结果是&lt;code&gt;4&lt;/code&gt;，当&lt;code&gt;x=5&lt;/code&gt;时，计算结果是&lt;code&gt;25&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。&lt;/p&gt;
&lt;p&gt;在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量&lt;code&gt;a&lt;/code&gt;是一个整数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;t_007 = &#39;T007&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量&lt;code&gt;t_007&lt;/code&gt;是一个字符串。&lt;/p&gt;
&lt;p&gt;在Python中，等号&lt;code&gt;=&lt;/code&gt;是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = 123    # a是整数
print a
a = &#39;imooc&#39;   # a变为字符串
print a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。&lt;/p&gt;
&lt;p&gt;静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;int a = 123; // a是整数类型变量
a = &amp;quot;mooc&amp;quot;; // 错误：不能把字符串赋给整型变量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和静态语言相比，动态语言更灵活，就是这个原因。&lt;/p&gt;
&lt;p&gt;请不要把赋值语句的等号等同于数学的等号。比如下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = 10
x = x + 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。&lt;/p&gt;
&lt;p&gt;最后，理解变量在计算机内存中的表示也非常重要。当我们写：&lt;code&gt;a = &#39;ABC&#39;&lt;/code&gt;时，Python解释器干了两件事情：&lt;/p&gt;
&lt;p&gt;\1. 在内存中创建了一个&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;的字符串；&lt;/p&gt;
&lt;p&gt;\2. 在内存中创建了一个名为&lt;code&gt;a&lt;/code&gt;的变量，并把它指向&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = &#39;ABC&#39;
b = a
a = &#39;XYZ&#39;
print b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一行打印出变量b的内容到底是&#39;ABC&#39;呢还是&#39;XYZ&#39;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&#39;XYZ&#39;，但实际上b的值是&#39;ABC&#39;，让我们一行一行地执行代码，就可以看到到底发生了什么事：&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;a = &#39;ABC&#39;&lt;/code&gt;，解释器创建了字符串  &#39;ABC&#39;和变量 a，并把a指向 &#39;ABC&#39;：&lt;/p&gt;
&lt;p&gt;{% asset_img 540581030001c11202360058.jpg %}&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;b = a&lt;/code&gt;，解释器创建了变量 b，并把b指向 a 指向的字符串&#39;ABC&#39;：&lt;/p&gt;
&lt;p&gt;{% asset_img 53fc5e880001399902360084.jpg %}&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;a = &#39;XYZ&#39;&lt;/code&gt;，解释器创建了字符串&#39;XYZ&#39;，并把a的指向改为&#39;XYZ&#39;，但b并没有更改：&lt;/p&gt;
&lt;p&gt;{% asset_img 53fc5e9f0001b98d02360090.jpg %}&lt;/p&gt;
&lt;p&gt;所以，最后打印变量&lt;code&gt;b&lt;/code&gt;的结果自然是&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;了。&lt;/p&gt;
&lt;h2 id=&#34;5python中定义字符串&#34;&gt;5.Python中定义字符串&lt;/h2&gt;
&lt;p&gt;前面我们讲解了什么是字符串。字符串可以用&lt;code&gt;&#39;&#39;&lt;/code&gt;或者&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;括起来表示。&lt;/p&gt;
&lt;p&gt;如果字符串本身包含&lt;code&gt;&#39;&lt;/code&gt;怎么办？比如我们要表示字符串&lt;code&gt;I&#39;m OK&lt;/code&gt;，这时，可以用&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt;括起来表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;I&#39;m OK&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似的，如果字符串包含&lt;code&gt;&amp;quot;&lt;/code&gt;，我们就可以用&lt;code&gt;&#39; &#39;&lt;/code&gt;括起来表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;Learn &amp;quot;Python&amp;quot; in imooc&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果字符串既包含&lt;code&gt;&#39;&lt;/code&gt;又包含&lt;code&gt;&amp;quot;&lt;/code&gt;怎么办？&lt;/p&gt;
&lt;p&gt;这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用&lt;code&gt;\&lt;/code&gt;进行转义。&lt;/p&gt;
&lt;p&gt;要表示字符串 &lt;code&gt;Bob said &amp;quot;I&#39;m OK&amp;quot;.&lt;/code&gt;&lt;br&gt;
由于 &#39; 和 &amp;quot; 会引起歧义，因此，我们在它前面插入一个&lt;code&gt;\&lt;/code&gt;表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;Bob said \&amp;quot;I\&#39;m OK\&amp;quot;.&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**注意：**转义字符 \ 不计入字符串的内容中。&lt;/p&gt;
&lt;p&gt;常用的转义字符还有：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;\n 表示换行
\t 表示一个制表符
\\ 表示 \ 字符本身
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6python中raw字符串与多行字符串&#34;&gt;6.Python中raw字符串与多行字符串&lt;/h2&gt;
&lt;p&gt;如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀&lt;code&gt;r&lt;/code&gt;，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;r&#39;\(~_~)/ \(~_~)/&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是&lt;code&gt;r&#39;...&#39;&lt;/code&gt;表示法不能表示多行字符串，也不能表示包含&lt;code&gt;&#39;&lt;/code&gt;和 &lt;code&gt;&amp;quot;&lt;/code&gt;的字符串（为什么？）&lt;/p&gt;
&lt;p&gt;如果要表示多行字符串，可以用&lt;code&gt;&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;&#39;&#39;Line 1
Line 2
Line 3&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个字符串的表示方法和下面的是完全一样的：&lt;/p&gt;
&lt;p&gt;&#39;Line 1\nLine 2\nLine 3&#39;&lt;/p&gt;
&lt;p&gt;还可以在多行字符串前面添加&lt;code&gt;r&lt;/code&gt;，把这个多行字符串也变成一个raw字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;r&#39;&#39;&#39;Python is created by &amp;quot;Guido&amp;quot;.
It is free and easy to learn.
Let&#39;s start learn Python in imooc!&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-python中unicode字符串&#34;&gt;7. Python中Unicode字符串&lt;/h2&gt;
&lt;p&gt;字符串还有一个编码问题。&lt;/p&gt;
&lt;p&gt;因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。&lt;/p&gt;
&lt;p&gt;如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。&lt;/p&gt;
&lt;p&gt;类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。&lt;/p&gt;
&lt;p&gt;Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。&lt;/p&gt;
&lt;p&gt;因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串&#39;ABC&#39;在Python内部都是ASCII编码的。&lt;/p&gt;
&lt;p&gt;Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u&#39;...&#39;表示，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print u&#39;中文&#39;
中文
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 不加 u ，中文就不能正常显示。&lt;/p&gt;
&lt;p&gt;Unicode字符串除了多了一个&lt;code&gt;u&lt;/code&gt;之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转义：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;u&#39;中文\n日文\n韩文&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;多行：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;u&#39;&#39;&#39;第一行
第二行&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;raw+多行：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ur&#39;&#39;&#39;Python的Unicode字符串支持&amp;quot;中文&amp;quot;,
&amp;quot;日文&amp;quot;,
&amp;quot;韩文&amp;quot;等多种语言&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为... 并选择UTF-8格式保存。&lt;/p&gt;
&lt;h2 id=&#34;python中整数和浮点数&#34;&gt;Python中整数和浮点数&lt;/h2&gt;
&lt;p&gt;Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。&lt;/p&gt;
&lt;p&gt;基本的运算：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;1 + 2 + 3   # ==&amp;gt; 6
4 * 5 - 6   # ==&amp;gt; 14
7.5 / 8 + 2.1   # ==&amp;gt; 3.0375
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;(1 + 2) * 3    # ==&amp;gt; 9
(2.2 + 3.3) / (1.5 * (9 - 0.3))    # ==&amp;gt; 0.42145593869731807
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;1 + 2    # ==&amp;gt; 整数 3
1.0 + 2.0    # ==&amp;gt; 浮点数 3.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是整数和浮点数混合运算的结果就变成浮点数了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;1 + 2.0    # ==&amp;gt; 浮点数 3.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么要区分整数运算和浮点数运算呢？这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如&lt;code&gt;0.1&lt;/code&gt;换成二进制表示就是无限循环小数。&lt;/p&gt;
&lt;p&gt;那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;11 / 4    # ==&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;11 % 4    # ==&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;11.0 / 4    # ==&amp;gt; 2.75
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-python中布尔类型&#34;&gt;8. Python中布尔类型&lt;/h2&gt;
&lt;p&gt;我们已经了解了Python支持布尔类型的数据，布尔类型只有&lt;code&gt;True&lt;/code&gt;和&lt;code&gt;False&lt;/code&gt;两种值，但是布尔类型有以下几种运算：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与运算&lt;/strong&gt;：只有两个布尔值都为 True 时，计算结果才为 True。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;True and True   # ==&amp;gt; True
True and False   # ==&amp;gt; False
False and True   # ==&amp;gt; False
False and False   # ==&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;或运算&lt;/strong&gt;：只要有一个布尔值为 True，计算结果就是 True。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;True or True   # ==&amp;gt; True
True or False   # ==&amp;gt; True
False or True   # ==&amp;gt; True
False or False   # ==&amp;gt; False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;非运算&lt;/strong&gt;：把True变为False，或者把False变为True：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;not True   # ==&amp;gt; False
not False   # ==&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。&lt;/p&gt;
&lt;p&gt;在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = True
print a and &#39;a=T&#39; or &#39;a=F&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;计算结果不是布尔类型，而是字符串 &#39;a=T&#39;，这是为什么呢？&lt;/p&gt;
&lt;p&gt;因为Python把&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;空字符串&#39;&#39;&lt;/code&gt;和&lt;code&gt;None&lt;/code&gt;看成 False，其他数值和非空字符串都看成 True，所以：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;True and &#39;a=T&#39; 计算结果是 &#39;a=T&#39;
继续计算 &#39;a=T&#39; or &#39;a=F&#39; 计算结果还是 &#39;a=T&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在计算&lt;code&gt;a and b&lt;/code&gt;时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在计算&lt;code&gt;a or b&lt;/code&gt;时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。&lt;/p&gt;
&lt;h1 id=&#34;list和tuple类型&#34;&gt;List和Tuple类型&lt;/h1&gt;
&lt;h2 id=&#34;1-python创建list&#34;&gt;1. Python创建list&lt;/h2&gt;
&lt;p&gt;Python内置的一种数据类型是列表：&lt;code&gt;list&lt;/code&gt;。list是一种有序的集合，可以随时添加和删除其中的元素。&lt;/p&gt;
&lt;p&gt;比如，列出班里所有同学的名字，就可以用一个list表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。&lt;/p&gt;
&lt;p&gt;构造list非常简单，按照上面的代码，直接用&lt;code&gt;[ ]&lt;/code&gt;把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
&amp;gt;&amp;gt;&amp;gt; classmates # 打印classmates变量的内容
[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Michael&#39;, 100, True]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个元素也没有的list，就是空list：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; empty_list = []
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-python按照索引访问list&#34;&gt;2. Python按照索引访问list&lt;/h2&gt;
&lt;p&gt;由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要特别注意的是&lt;/strong&gt;，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。&lt;/p&gt;
&lt;p&gt;因此，要打印第一名同学的名字，用 L[0]:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[0]
Adam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要打印第二名同学的名字，用 L[1]:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[1]
Lisa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要打印第三名同学的名字，用 L[2]:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[2]
Bart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要打印第四名同学的名字，用 L[3]:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[3]
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。&lt;/p&gt;
&lt;p&gt;所以，使用索引时，&lt;strong&gt;&lt;mark&gt;千万注意不要越界&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3-python之倒序访问list&#34;&gt;3.  Python之倒序访问list&lt;/h2&gt;
&lt;p&gt;我们还是用一个list按分数从高到低表示出班里的3个同学：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时，老师说，请分数最低的同学站出来。&lt;/p&gt;
&lt;p&gt;要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[2]
Bart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有没有更简单的方法？&lt;/p&gt;
&lt;p&gt;有！&lt;/p&gt;
&lt;p&gt;Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[-1]
Bart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bart同学表示躺枪。&lt;/p&gt;
&lt;p&gt;类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[-2]
Lisa
&amp;gt;&amp;gt;&amp;gt; print L[-3]
Adam
&amp;gt;&amp;gt;&amp;gt; print L[-4]
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。&lt;/p&gt;
&lt;p&gt;使用倒序索引时，也要注意**&lt;mark&gt;不要越界&lt;/mark&gt;**。&lt;/p&gt;
&lt;h2 id=&#34;4-python之添加新元素&#34;&gt;4. Python之添加新元素&lt;/h2&gt;
&lt;p&gt;现在，班里有3名同学：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？&lt;/p&gt;
&lt;p&gt;第一个办法是用 list 的&lt;code&gt;append()&lt;/code&gt;方法，把新同学追加到 list 的末尾：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&amp;gt;&amp;gt;&amp;gt; L.append(&#39;Paul&#39;)
&amp;gt;&amp;gt;&amp;gt; print L
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**&lt;mark&gt;append()&lt;/mark&gt;**总是把新的元素添加到 list 的尾部。&lt;/p&gt;
&lt;p&gt;如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？&lt;/p&gt;
&lt;p&gt;方法是用list的 **&lt;mark&gt;insert()&lt;/mark&gt;**方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&amp;gt;&amp;gt;&amp;gt; L.insert(0, &#39;Paul&#39;)
&amp;gt;&amp;gt;&amp;gt; print L
[&#39;Paul&#39;, &#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;L.insert(0, &#39;Paul&#39;)&lt;/strong&gt; 的意思是，&#39;Paul&#39;将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。&lt;/p&gt;
&lt;h2 id=&#34;5-python从list删除元素&#34;&gt;5. Python从list删除元素&lt;/h2&gt;
&lt;p&gt;Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？&lt;/p&gt;
&lt;p&gt;如果Paul同学排在最后一个，我们可以用list的&lt;code&gt;pop()&lt;/code&gt;方法删除：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]
&amp;gt;&amp;gt;&amp;gt; L.pop()
&#39;Paul&#39;
&amp;gt;&amp;gt;&amp;gt; print L
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**&lt;mark&gt;pop()&lt;/mark&gt;**方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 &#39;Paul&#39;。&lt;/p&gt;
&lt;p&gt;如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Paul&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用**&lt;mark&gt;&lt;code&gt;pop(2)&lt;/code&gt;&lt;/mark&gt;**把Paul删掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L.pop(2)
&#39;Paul&#39;
&amp;gt;&amp;gt;&amp;gt; print L
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-python中替换元素&#34;&gt;6.  Python中替换元素&lt;/h2&gt;
&lt;p&gt;假设现在班里仍然是3名同学：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。&lt;/p&gt;
&lt;p&gt;另一个办法是直接用Paul把Bart给替换掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[2] = &#39;Paul&#39;
&amp;gt;&amp;gt;&amp;gt; print L
L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Paul&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。&lt;/p&gt;
&lt;p&gt;由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[-1] = &#39;Paul&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-python之创建tuple&#34;&gt;7. Python之创建tuple&lt;/h2&gt;
&lt;p&gt;tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，&lt;mark&gt;但是，tuple一旦创建完毕，就不能修改了&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;同样是表示班里同学的名称，用tuple表示如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建tuple和创建list唯一不同之处是用**&lt;code&gt;( )&lt;/code&gt;替代了&lt;code&gt;[ ]&lt;/code&gt;。**&lt;/p&gt;
&lt;p&gt;现在，这个&lt;code&gt;t&lt;/code&gt;就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。&lt;/p&gt;
&lt;p&gt;获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t[0] = &#39;Paul&#39;
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: &#39;tuple&#39; object does not support item assignment
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-python之创建单元素tuple&#34;&gt;8. Python之创建单元素tuple&lt;/h2&gt;
&lt;p&gt;tuple和list一样，可以包含 0 个、1个和任意多个元素。&lt;/p&gt;
&lt;p&gt;包含多个元素的 tuple，前面我们已经创建过了。&lt;/p&gt;
&lt;p&gt;包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = ()
&amp;gt;&amp;gt;&amp;gt; print t
()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建包含1个元素的 tuple 呢？来试试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (1)
&amp;gt;&amp;gt;&amp;gt; print t
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好像哪里不对！t 不是 tuple ，而是整数1。&lt;strong&gt;为什么&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;()&lt;/code&gt;既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。&lt;/p&gt;
&lt;p&gt;正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (1,)
&amp;gt;&amp;gt;&amp;gt; print t
(1,)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。&lt;/p&gt;
&lt;p&gt;多元素 tuple 加不加这个额外的“,”效果是一样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (1, 2, 3,)
&amp;gt;&amp;gt;&amp;gt; print t
(1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-python之可变的tuple&#34;&gt;9. Python之“可变”的tuple&lt;/h2&gt;
&lt;p&gt;前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;到 t 有 3 个元素：&lt;strong&gt;&#39;a&#39;，&#39;b&#39;&lt;strong&gt;和一个list：&lt;/strong&gt;[&#39;A&#39;, &#39;B&#39;]&lt;/strong&gt;。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = t[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们把list的两个元素改一改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[0] = &#39;X&#39;
&amp;gt;&amp;gt;&amp;gt; L[1] = &#39;Y&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看看tuple的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print t
(&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不是说tuple一旦定义后就不可变了吗？怎么现在又变了？&lt;/p&gt;
&lt;p&gt;别急，我们先看看定义的时候tuple包含的3个元素：&lt;/p&gt;
&lt;p&gt;{% asset_img 540538d400010f4603500260.jpg %}&lt;/p&gt;
&lt;p&gt;当我们把list的元素**&#39;A&#39;和&#39;B&#39;&lt;strong&gt;修改为&lt;/strong&gt;&#39;X&#39;和&#39;Y&#39;**后，tuple变为：&lt;/p&gt;
&lt;p&gt;{% asset_img 540538e9000110c003500260.jpg %}&lt;br&gt;
表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。&lt;/p&gt;
&lt;p&gt;tuple一开始指向的list并没有改成别的list，所以，tuple所谓的**“不变”&lt;strong&gt;是说，tuple的每个元素，指向永远不变。即&lt;/strong&gt;指向&#39;a&#39;，就不能改成指向&#39;b&#39;**，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！&lt;/p&gt;
&lt;p&gt;理解了**“指向不变”**后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。&lt;/p&gt;
&lt;h1 id=&#34;条件判断和循环&#34;&gt;条件判断和循环&lt;/h1&gt;
&lt;h2 id=&#34;1-python之if语句&#34;&gt;1. Python之if语句&lt;/h2&gt;
&lt;p&gt;计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。&lt;/p&gt;
&lt;p&gt;比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;age = 20
if age &amp;gt;= 18:
    print &#39;your age is&#39;, age
    print &#39;adult&#39;
print &#39;END&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。&lt;/p&gt;
&lt;p&gt;缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: if 语句后接表达式，然后用&lt;code&gt;:&lt;/code&gt;表示代码块开始。&lt;/p&gt;
&lt;p&gt;如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; age = 20
&amp;gt;&amp;gt;&amp;gt; if age &amp;gt;= 18:
...     print &#39;your age is&#39;, age
...     print &#39;adult&#39;
...
your age is 20
adult
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-python之-if-else&#34;&gt;2. Python之 if-else&lt;/h2&gt;
&lt;p&gt;当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if age &amp;gt;= 18:
    print &#39;adult&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们想判断年龄在18岁以下时，打印出 &#39;teenager&#39;，怎么办？&lt;/p&gt;
&lt;p&gt;方法是再写一个 if:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if age &amp;lt; 18:
    print &#39;teenager&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者用 not 运算：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if not age &amp;gt;= 18:
    print &#39;teenager&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;细心的同学可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if ... else ... 语句把它们统一起来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if age &amp;gt;= 18:
    print &#39;adult&#39;
else:
    print &#39;teenager&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用 if ... else ... 语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;mark&gt;注意&lt;/mark&gt;:&lt;/strong&gt; else 后面有个“:”。&lt;/p&gt;
&lt;h2 id=&#34;3-python之-if-elif-else&#34;&gt;3. Python之 if-elif-else&lt;/h2&gt;
&lt;p&gt;有的时候，一个 if ... else ... 还不够用。比如，根据年龄的划分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;条件1：18岁或以上：adult
条件2：6岁或以上：teenager
条件3：6岁以下：kid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以用一个 if age &amp;gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &amp;gt;= 6 来判断是否符合条件2，否则，执行条件3：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if age &amp;gt;= 18:
    print &#39;adult&#39;
else:
    if age &amp;gt;= 6:
        print &#39;teenager&#39;
    else:
        print &#39;kid&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样写出来，我们就得到了一个两层嵌套的 if ... else ... 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if age &amp;gt;= 18:
    print &#39;adult&#39;
else:
    if age &amp;gt;= 6:
        print &#39;teenager&#39;
    else:
        if age &amp;gt;= 3:
            print &#39;kid&#39;
        else:
            print &#39;baby&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种缩进只会越来越多，代码也会越来越难看。&lt;/p&gt;
&lt;p&gt;要避免嵌套结构的 if ... else ...，我们可以用 if ... 多个elif ... else ... 的结构，一次写完所有的规则：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if age &amp;gt;= 18:
    print &#39;adult&#39;
elif age &amp;gt;= 6:
    print &#39;teenager&#39;
elif age &amp;gt;= 3:
    print &#39;kid&#39;
else:
    print &#39;baby&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别注意:&lt;/strong&gt; 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。&lt;/p&gt;
&lt;h3 id=&#34;请思考下面的代码&#34;&gt;请思考下面的代码：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;age = 8
if age &amp;gt;= 6:
    print &#39;teenager&#39;
elif age &amp;gt;= 18:
    print &#39;adult&#39;
else:
    print &#39;kid&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 age = 8 时，结果正确，但 age = 20 时，为什么没有打印出 adult？&lt;/p&gt;
&lt;p&gt;如果要修复，应该如何修复？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交换      print &#39;teenager&#39;     print &#39;adult&#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-python之-for循环&#34;&gt;4. Python之 for循环&lt;/h2&gt;
&lt;p&gt;list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
print L[0]
print L[1]
print L[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。&lt;/p&gt;
&lt;p&gt;这时，循环就派上用场了。&lt;/p&gt;
&lt;p&gt;Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
for name in L:
    print name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。&lt;/p&gt;
&lt;p&gt;这样一来，遍历一个list或tuple就非常容易了。&lt;/p&gt;
&lt;h2 id=&#34;5-python之-while循环&#34;&gt;5. Python之 while循环&lt;/h2&gt;
&lt;p&gt;和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。&lt;/p&gt;
&lt;p&gt;比如要从 0 开始打印不大于 N 的整数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;N = 10
x = 0
while x &amp;lt; N:
    print x
    x = x + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while循环每次先判断 x &amp;lt; N，如果为True，则执行循环体的代码块，否则，退出循环。&lt;/p&gt;
&lt;p&gt;在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &amp;lt; N 不成立而退出循环。&lt;/p&gt;
&lt;p&gt;如果没有这一个语句，&lt;strong&gt;while循环在判断 x &amp;lt; N 时总是为True&lt;/strong&gt;，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。&lt;/p&gt;
&lt;h2 id=&#34;6-python之-break退出循环&#34;&gt;6. Python之 break退出循环&lt;/h2&gt;
&lt;p&gt;用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。&lt;/p&gt;
&lt;p&gt;比如计算1至100的整数和，我们用while来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sum = 0
x = 1
while True:
    sum = sum + x
    x = x + 1
    if x &amp;gt; 100:
        break
print sum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &amp;gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。&lt;/p&gt;
&lt;h2 id=&#34;7-python之-continue继续循环&#34;&gt;7. Python之 continue继续循环&lt;/h2&gt;
&lt;p&gt;在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。&lt;/p&gt;
&lt;p&gt;假设我们已经写好了利用for循环计算平均分的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L = [75, 98, 59, 81, 66, 43, 69, 85]
sum = 0.0
n = 0
for x in L:
    sum = sum + x
    n = n + 1
print sum / n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在老师只想统计及格分数的平均分，就要把 x &amp;lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &amp;lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for x in L:
    if x &amp;lt; 60:
        continue
    sum = sum + x
    n = n + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-python之-多重循环&#34;&gt;8. Python之 多重循环&lt;/h2&gt;
&lt;p&gt;在循环内部，还可以嵌套循环，我们来看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for x in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
    for y in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]:
        print x + y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;x 每循环一次，y 就会循环 3 次，这样，我们可以打印出一个全排列：&lt;/p&gt;
&lt;p&gt;A1&lt;br&gt;
A2&lt;br&gt;
A3&lt;br&gt;
B1&lt;br&gt;
B2&lt;br&gt;
B3&lt;br&gt;
C1&lt;br&gt;
C2&lt;br&gt;
C3&lt;/p&gt;
&lt;h1 id=&#34;dict和set类型&#34;&gt;Dict和Set类型&lt;/h1&gt;
&lt;h2 id=&#34;1-python之什么是dict&#34;&gt;1. Python之什么是dict&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者考试的成绩列表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[95, 85, 59]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。&lt;/p&gt;
&lt;p&gt;如果把名字和分数关联起来，组成类似的查找表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;Adam&#39; ==&amp;gt; 95
&#39;Lisa&#39; ==&amp;gt; 85
&#39;Bart&#39; ==&amp;gt; 59
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给定一个名字，就可以直接查到分数。&lt;/p&gt;
&lt;p&gt;Python的 dict 就是专门干这件事的。用 &lt;strong&gt;dict&lt;/strong&gt; 表示**“名字”-“成绩”**的查找表如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = {
    &#39;Adam&#39;: 95,
    &#39;Lisa&#39;: 85,
    &#39;Bart&#39;: 59
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们把&lt;strong&gt;名字称为key&lt;/strong&gt;，对应的&lt;strong&gt;成绩称为value&lt;/strong&gt;，dict就是通过 &lt;strong&gt;key&lt;/strong&gt; 来查找 &lt;strong&gt;value&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;花括号 {} 表示这是一个dict，然后按照 &lt;strong&gt;key: value&lt;/strong&gt;, 写出来即可。最后一个 key: value 的逗号可以省略。&lt;/p&gt;
&lt;p&gt;由于dict也是集合，len() 函数可以计算任意集合的大小：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; len(d)
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 一个 key-value 算一个，因此，dict大小为3。&lt;/p&gt;
&lt;h2 id=&#34;2-python之访问dict&#34;&gt;2. Python之访问dict&lt;/h2&gt;
&lt;p&gt;我们已经能创建一个dict，用于表示名字和成绩的对应关系：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = {
    &#39;Adam&#39;: 95,
    &#39;Lisa&#39;: 85,
    &#39;Bart&#39;: 59
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，如何根据名字来查找对应的成绩呢？&lt;/p&gt;
&lt;p&gt;可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，&lt;strong&gt;list 必须使用索引返回对应的元素，而dict使用key：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d[&#39;Adam&#39;]
95
&amp;gt;&amp;gt;&amp;gt; print d[&#39;Paul&#39;]
Traceback (most recent call last):
  File &amp;quot;index.py&amp;quot;, line 11, in &amp;lt;module&amp;gt;
    print d[&#39;Paul&#39;]
KeyError: &#39;Paul&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。&lt;/p&gt;
&lt;p&gt;要避免 KeyError 发生，有两个办法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一是先判断一下 key 是否存在，用 in 操作符：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if &#39;Paul&#39; in d:
    print d[&#39;Paul&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 &#39;Paul&#39; 不存在，if语句判断为False，自然不会执行 print d[&#39;Paul&#39;] ，从而避免了错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d.get(&#39;Bart&#39;)
59
&amp;gt;&amp;gt;&amp;gt; print d.get(&#39;Paul&#39;)
None
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;任务&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;根据如下dict：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = {
    &#39;Adam&#39;: 95,
    &#39;Lisa&#39;: 85,
    &#39;Bart&#39;: 59
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请打印出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Adam: 95
Lisa: 85
Bart: 59
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-python中dict的特点&#34;&gt;3. Python中dict的特点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样&lt;/strong&gt;。而list的查找速度随着元素增加而逐渐下降。&lt;/p&gt;
&lt;p&gt;不过dict的查找速度快不是没有代价的，&lt;strong&gt;dict的缺点是占用内存大，还会浪费很多内容&lt;/strong&gt;，list正好相反，占用内存小，但是查找速度慢。&lt;/p&gt;
&lt;p&gt;由于dict是按 key 查找，所以，&lt;mark&gt;在一个dict中，key不能重复&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;**dict的第二个特点就是存储的key-value序对是没有顺序的！**这和list不一样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = {
    &#39;Adam&#39;: 95,
    &#39;Lisa&#39;: 85,
    &#39;Bart&#39;: 59
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们试图打印这个dict时：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d
{&#39;Lisa&#39;: 85, &#39;Adam&#39;: 95, &#39;Bart&#39;: 59}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同==，这说明dict内部是&lt;strong&gt;无序&lt;/strong&gt;的==，不能用dict存储有序的集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dict的第三个特点是作为 key 的元素必须不可变&lt;/strong&gt;，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。&lt;/p&gt;
&lt;p&gt;可以试试用list作为key时会报什么样的错误。&lt;/p&gt;
&lt;p&gt;不可变这个限制仅作用于key，value是否可变无所谓：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{
    &#39;123&#39;: [1, 2, 3],  # key 是 str，value是list
    123: &#39;123&#39;,  # key 是 int，value 是 str
    (&#39;a&#39;, &#39;b&#39;): True  # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最常用的key还是字符串，因为用起来最方便。&lt;/p&gt;
&lt;h2 id=&#34;4-python更新dict&#34;&gt;4. Python更新dict&lt;/h2&gt;
&lt;p&gt;dict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = {
    &#39;Adam&#39;: 95,
    &#39;Lisa&#39;: 85,
    &#39;Bart&#39;: 59
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要把新同学&#39;Paul&#39;的成绩 72 加进去，用赋值语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d[&#39;Paul&#39;] = 72
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看看dict的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d
{&#39;Lisa&#39;: 85, &#39;Paul&#39;: 72, &#39;Adam&#39;: 95, &#39;Bart&#39;: 59}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d[&#39;Bart&#39;] = 60
&amp;gt;&amp;gt;&amp;gt; print d
{&#39;Lisa&#39;: 85, &#39;Paul&#39;: 72, &#39;Adam&#39;: 95, &#39;Bart&#39;: 60}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-python之-遍历dict&#34;&gt;5. Python之 遍历dict&lt;/h2&gt;
&lt;p&gt;由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。&lt;/p&gt;
&lt;p&gt;直接使用for循环可以遍历 dict 的 key：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }
&amp;gt;&amp;gt;&amp;gt; for key in d:
...     print key
... 
Lisa
Adam
Bart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。&lt;/p&gt;
&lt;h2 id=&#34;6-python中什么是set&#34;&gt;6. Python中什么是set&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以查看 set 的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print s
set([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt;，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是&lt;strong&gt;无序&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;])
&amp;gt;&amp;gt;&amp;gt; print s
set([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])
&amp;gt;&amp;gt;&amp;gt; len(s)
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。&lt;/p&gt;
&lt;h2 id=&#34;7-python之-访问set&#34;&gt;7. Python之 访问set&lt;/h2&gt;
&lt;p&gt;由于&lt;strong&gt;set存储的是无序集合&lt;/strong&gt;，所以我们没法通过索引来访问。&lt;/p&gt;
&lt;p&gt;访问 set中的某个元素实际上就是判断一个元素是否在set中。&lt;/p&gt;
&lt;p&gt;例如，存储了班里同学名字的set：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以用 in 操作符判断：&lt;/p&gt;
&lt;p&gt;Bart是该班的同学吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;Bart&#39; in s
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bill是该班的同学吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;Bill&#39; in s
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bart是该班的同学吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;bart&#39; in s
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;看来大小写很重要&lt;/mark&gt;，&#39;Bart&#39; 和 &#39;bart&#39;被认为是两个不同的元素。&lt;/p&gt;
&lt;h2 id=&#34;8-python之-set的特点&#34;&gt;8. Python之 set的特点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;set的内部结构和dict很像，唯一区别是不存储value&lt;/strong&gt;，因此，判断一个元素是否在set中速度很快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set存储的元素和dict的key类似，必须是不变对象&lt;/strong&gt;，因此，任何可变对象是不能放入set中的。&lt;/p&gt;
&lt;p&gt;最后，set存储的元素也是没有顺序的。&lt;/p&gt;
&lt;p&gt;set的这些特点，可以应用在哪些地方呢？&lt;/p&gt;
&lt;p&gt;星期一到星期日可以用字符串&#39;MON&#39;, &#39;TUE&#39;, ... &#39;SUN&#39;表示。&lt;/p&gt;
&lt;p&gt;假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？&lt;/p&gt;
&lt;p&gt;可以用 &lt;strong&gt;if 语句&lt;/strong&gt;判断，但这样做非常繁琐：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = &#39;???&#39; # 用户输入的字符串
if x!= &#39;MON&#39; and x!= &#39;TUE&#39; and x!= &#39;WED&#39; ... and x!= &#39;SUN&#39;:
    print &#39;input error&#39;
else:
    print &#39;input ok&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**注意：**if 语句中的...表示没有列出的其它星期名称，测试时，请输入完整。&lt;/p&gt;
&lt;p&gt;如果事先创建好一个set，包含&#39;MON&#39; ~ &#39;SUN&#39;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weekdays = set([&#39;MON&#39;, &#39;TUE&#39;, &#39;WED&#39;, &#39;THU&#39;, &#39;FRI&#39;, &#39;SAT&#39;, &#39;SUN&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再判断输入是否有效，只需要判断该字符串是否在set中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = &#39;???&#39; # 用户输入的字符串
if x in weekdays:
    print &#39;input ok&#39;
else:
    print &#39;input error&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一来，代码就简单多了。&lt;/p&gt;
&lt;h2 id=&#34;9-python之-遍历set&#34;&gt;9. Python之 遍历set&lt;/h2&gt;
&lt;p&gt;由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。&lt;/p&gt;
&lt;p&gt;直接使用 for 循环可以遍历 set 的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;])
&amp;gt;&amp;gt;&amp;gt; for name in s:
...     print name
... 
Lisa
Adam
Bart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。&lt;/p&gt;
&lt;h2 id=&#34;python之-更新set&#34;&gt;Python之 更新set&lt;/h2&gt;
&lt;p&gt;由于&lt;strong&gt;set存储的是一组不重复的无序元素&lt;/strong&gt;，因此，更新set主要做两件事：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一是把新的元素添加到set中，二是把已有元素从set中删除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加元素时，用set的add()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s.add(4)
&amp;gt;&amp;gt;&amp;gt; print s
set([1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s.add(3)
&amp;gt;&amp;gt;&amp;gt; print s
set([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除set中的元素时，用set的remove()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3, 4])
&amp;gt;&amp;gt;&amp;gt; s.remove(4)
&amp;gt;&amp;gt;&amp;gt; print s
set([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果删除的元素不存在set中，remove()会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s.remove(4)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以用add()可以直接添加，而remove()前需要判断。&lt;/p&gt;
&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;h2 id=&#34;python之什么是函数&#34;&gt;Python之什么是函数&lt;/h2&gt;
&lt;p&gt;我们知道圆的面积计算公式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S = πr²
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r1 = 12.34
r2 = 9.08
r3 = 73.1
s1 = 3.14 * r1 * r1
s2 = 3.14 * r2 * r2
s3 = 3.14 * r3 * r3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。&lt;/p&gt;
&lt;p&gt;有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用 &lt;code&gt;s = area_of_circle(x)&lt;/code&gt;，而函数 area_of_circle 本身只需要写一次，就可以多次调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象&lt;/strong&gt;是数学中非常常见的概念。举个例子：&lt;/p&gt;
&lt;p&gt;计算数列的和，比如：&lt;strong&gt;1 + 2 + 3 + ... + 100&lt;/strong&gt;，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + ... + 100记作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;100
∑n
n=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。&lt;/p&gt;
&lt;p&gt;而且，这种抽象记法是可扩展的，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;100
∑(n²+1)
n=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还原成加法运算就变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。&lt;/p&gt;
&lt;p&gt;写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。&lt;/p&gt;
&lt;p&gt;Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。&lt;/p&gt;
&lt;h2 id=&#34;python之调用函数&#34;&gt;Python之调用函数&lt;/h2&gt;
&lt;p&gt;Python内置了很多有用的函数，我们可以直接调用。&lt;/p&gt;
&lt;p&gt;要调用一个函数，需要知道&lt;strong&gt;函数&lt;/strong&gt;的&lt;strong&gt;名称&lt;/strong&gt;和&lt;strong&gt;参数&lt;/strong&gt;，比如求绝对值的函数 abs，它接收一个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;可以直接从Python的官方网站查看文档：
http://docs.python.org/2/library/functions.html#abs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。&lt;/p&gt;
&lt;p&gt;调用 &lt;strong&gt;abs&lt;/strong&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs(100)
100
&amp;gt;&amp;gt;&amp;gt; abs(-20)
20
&amp;gt;&amp;gt;&amp;gt; abs(12.34)
12.34
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用函数的时候，如果传入的参数数量不对，会报&lt;strong&gt;TypeError&lt;/strong&gt;的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs(1, 2)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: abs() takes exactly one argument (2 given)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报&lt;strong&gt;TypeError&lt;/strong&gt;的错误，并且给出错误信息：str是错误的参数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs(&#39;a&#39;)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: bad operand type for abs(): &#39;str&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而比较函数 cmp(x, y) 就需要两个参数，如果 **x&amp;lt;y，返回 &lt;strong&gt;-1&lt;/strong&gt;，如果 &lt;strong&gt;x==y&lt;/strong&gt;，返回 &lt;strong&gt;0&lt;/strong&gt;，如果 &lt;strong&gt;x&amp;gt;y&lt;/strong&gt;，返回 &lt;strong&gt;1&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; cmp(1, 2)
-1
&amp;gt;&amp;gt;&amp;gt; cmp(2, 1)
1
&amp;gt;&amp;gt;&amp;gt; cmp(3, 3)
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python内置的常用函数还包括数据类型转换函数，比如  int()函数可以把其他数据类型转换为整数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;123&#39;)
123
&amp;gt;&amp;gt;&amp;gt; int(12.34)
12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;str()函数把其他类型转换成 str：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; str(123)
&#39;123&#39;
&amp;gt;&amp;gt;&amp;gt; str(1.23)
&#39;1.23&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python之编写函数&#34;&gt;Python之编写函数&lt;/h2&gt;
&lt;p&gt;在Python中，定义一个函数要使用 &lt;strong&gt;def&lt;/strong&gt; 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。&lt;/p&gt;
&lt;p&gt;我们以自定义一个求绝对值的 my_abs 函数为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def my_abs(x):
    if x &amp;gt;= 0:
        return x
    else:
        return -x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt;，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。&lt;/p&gt;
&lt;p&gt;如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。&lt;/p&gt;
&lt;p&gt;return None可以简写为return。&lt;/p&gt;
&lt;h3 id=&#34;任务-2&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;请定义一个 square_of_sum 函数，它接受一个list，返回list中每个元素平方的和。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def square_of_sum(L):
    return sum([i * i for i in L])

print square_of_sum([1, 2, 3, 4, 5])
print square_of_sum([-5, 0, 5, 15, 25])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python函数之返回多值&#34;&gt;Python函数之返回多值&lt;/h2&gt;
&lt;p&gt;函数可以返回多个值吗？答案是肯定的。&lt;/p&gt;
&lt;p&gt;比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;# math&lt;/strong&gt;包提供了**sin()**和 **cos()**函数，我们先用import引用它：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math
def move(x, y, step, angle):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样我们就可以同时获得返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x, y = move(100, 100, 60, math.pi / 6)
&amp;gt;&amp;gt;&amp;gt; print x, y
151.961524227 70.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但其实这只是一种假象，Python函数返回的仍然是单一值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; r = move(100, 100, 60, math.pi / 6)
&amp;gt;&amp;gt;&amp;gt; print r
(151.96152422706632, 70.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用print打印返回结果，原来返回值是一个&lt;strong&gt;tuple&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，&lt;strong&gt;Python的函数&lt;/strong&gt;返回多值其实就是&lt;strong&gt;返回一个tuple&lt;/strong&gt;，但写起来更方便。&lt;/p&gt;
&lt;h3 id=&#34;任务-3&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;一元二次方程的定义是：ax² + bx + c = 0&lt;/p&gt;
&lt;p&gt;请编写一个函数，返回一元二次方程的两个解。&lt;/p&gt;
&lt;p&gt;**注意：**Python的math包提供了sqrt()函数用于计算平方根。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math

def quadratic_equation(a, b, c):
    de=b**2-4*a*c
    if de&amp;gt;=0:
        x1=(-b+math.sqrt(de))/(2*a)
        x2=(-b-math.sqrt(de))/(2*a)
        return x1,x2
    else:
        return

print quadratic_equation(2, 3, 0)
print quadratic_equation(1, -6, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python之递归函数&#34;&gt;Python之递归函数&lt;/h2&gt;
&lt;p&gt;在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/p&gt;
&lt;p&gt;举个例子，我们来计算阶乘 &lt;strong&gt;n! = 1 * 2 * 3 * ... * n&lt;/strong&gt;，用函数 **fact(n)**表示，可以看出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，**fact(n)**可以表示为 &lt;strong&gt;n * fact(n-1)&lt;/strong&gt;，只有n=1时需要特殊处理。&lt;/p&gt;
&lt;p&gt;于是，fact(n)用递归的方式写出来就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面就是一个递归函数。可以试试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; fact(1)
1
&amp;gt;&amp;gt;&amp;gt; fact(5)
120
&amp;gt;&amp;gt;&amp;gt; fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们计算fact(5)，可以根据函数定义看到计算过程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;===&amp;gt; fact(5)
===&amp;gt; 5 * fact(4)
===&amp;gt; 5 * (4 * fact(3))
===&amp;gt; 5 * (4 * (3 * fact(2)))
===&amp;gt; 5 * (4 * (3 * (2 * fact(1))))
===&amp;gt; 5 * (4 * (3 * (2 * 1)))
===&amp;gt; 5 * (4 * (3 * 2))
===&amp;gt; 5 * (4 * 6)
===&amp;gt; 5 * 24
===&amp;gt; 120
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。&lt;/p&gt;
&lt;p&gt;使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。&lt;/p&gt;
&lt;h3 id=&#34;任务-4&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;汉诺塔 (http://baike.baidu.com/view/191666.htm) 的移动也可以看做是递归函数。&lt;/p&gt;
&lt;p&gt;我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为：&lt;/p&gt;
&lt;p&gt;如果a只有一个圆盘，可以直接移动到c；&lt;/p&gt;
&lt;p&gt;如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。&lt;/p&gt;
&lt;p&gt;请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤：&lt;/p&gt;
&lt;p&gt;move(n, a, b, c)&lt;/p&gt;
&lt;p&gt;例如，输入 move(2, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)，打印出：&lt;/p&gt;
&lt;p&gt;A --&amp;gt; B&lt;br&gt;
A --&amp;gt; C&lt;br&gt;
B --&amp;gt; C&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#-*- coding:utf-8 -*-
def move(n, x, y, z):
    if n==1:
        print x,&#39;--&amp;gt;&#39;,z
        return
    move(n-1,x,z,y)#将前n-1个盘子从x移动到y上
    move(1,x,y,z)#将最底下的最后一个盘子从x移动到z上
    move(n-1,y,x,z)#将y上的n-1个盘子移动到z上
move(4, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python之定义默认参数&#34;&gt;Python之定义默认参数&lt;/h2&gt;
&lt;p&gt;定义函数的时候，还可以有默认参数。&lt;/p&gt;
&lt;p&gt;例如Python自带的 &lt;strong&gt;int()&lt;/strong&gt; 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;123&#39;)
123
&amp;gt;&amp;gt;&amp;gt; int(&#39;123&#39;, 8)
83
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。&lt;/p&gt;
&lt;p&gt;可见，&lt;strong&gt;函数的默认参数的作用是简化调用&lt;/strong&gt;，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。&lt;/p&gt;
&lt;p&gt;我们来定义一个计算 x 的N次方的函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def power(x, n):
    s = 1
    while n &amp;gt; 0:
        n = n - 1
        s = s * x
    return s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def power(x, n=2):
    s = 1
    while n &amp;gt; 0:
        n = n - 1
        s = s * x
    return s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一来，计算平方就不需要传入两个参数了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; power(5)
25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于函数的参数按从左到右的顺序匹配，所以&lt;strong&gt;默认参数只能定义在必需参数的后面：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# OK:
def fn1(a, b=1, c=2):
    pass
# Error:
def fn2(a=1, b):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;任务-5&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;请定义一个 greet() 函数，它包含一个默认参数，如果没有传入，打印 &#39;Hello, world.&#39;，如果传入，打印 &#39;Hello, xxx.&#39;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def greet(a=&#39;world&#39;):
    print &#39;hello,&#39;,a,&#39;.&#39;

greet()
greet(&#39;Bart&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python之定义可变参数&#34;&gt;Python之定义可变参数&lt;/h2&gt;
&lt;p&gt;如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fn(*args):
    print args
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变参数的名字前面有个 ***** 号，我们可以传入0个、1个或多个参数给可变参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; fn()
()
&amp;gt;&amp;gt;&amp;gt; fn(&#39;a&#39;)
(&#39;a&#39;,)
&amp;gt;&amp;gt;&amp;gt; fn(&#39;a&#39;, &#39;b&#39;)
(&#39;a&#39;, &#39;b&#39;)
&amp;gt;&amp;gt;&amp;gt; fn(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。&lt;/p&gt;
&lt;p&gt;定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def average(*args):
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，在调用的时候，可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; average()
0
&amp;gt;&amp;gt;&amp;gt; average(1, 2)
1.5
&amp;gt;&amp;gt;&amp;gt; average(1, 2, 2, 3, 4)
2.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;任务-6&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;请编写接受可变参数的 average() 函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def average(*args):
    sum = 0.0
    if len(args) == 0:
        return sum
    for x in args:
        sum = sum + x
    return sum / len(args)
print average()
print average(1, 2)
print average(1, 2, 2, 3, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;切片&#34;&gt;切片&lt;/h1&gt;
&lt;h2 id=&#34;1-对list进行切片&#34;&gt;1 对list进行切片&lt;/h2&gt;
&lt;h2 id=&#34;对list进行切片&#34;&gt;对list进行切片&lt;/h2&gt;
&lt;p&gt;取一个list的部分元素是非常常见的操作。比如，一个list如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取前3个元素，应该怎么做？&lt;/p&gt;
&lt;p&gt;笨办法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [L[0], L[1], L[2]]
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之所以是笨办法是因为扩展一下，取前N个元素就没辙了。&lt;/p&gt;
&lt;p&gt;取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; r = []
&amp;gt;&amp;gt;&amp;gt; n = 3
&amp;gt;&amp;gt;&amp;gt; for i in range(n):
...     r.append(L[i])
... 
&amp;gt;&amp;gt;&amp;gt; r
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。&lt;/p&gt;
&lt;p&gt;对应上面的问题，取前3个元素，用一行代码就可以完成切片：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[0:3]
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。&lt;/p&gt;
&lt;p&gt;如果第一个索引是0，还可以省略：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[:3]
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以从索引1开始，取出2个元素出来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[1:3]
[&#39;Lisa&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只用一个 &lt;strong&gt;:&lt;/strong&gt; ，表示从头到尾：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[:]
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，L[:]实际上复制出了一个新list。&lt;/p&gt;
&lt;p&gt;切片操作还可以指定第三个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[::2]
[&#39;Adam&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。&lt;/p&gt;
&lt;p&gt;把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。&lt;/p&gt;
&lt;h3 id=&#34;任务-7&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;range()函数可以创建一个数列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; range(1, 101)
[1, 2, 3, ..., 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请利用切片，取出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前10个数；&lt;/li&gt;
&lt;li&gt;3的倍数；&lt;/li&gt;
&lt;li&gt;不大于50的5的倍数。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L = range(1, 101)

print L[:10]
print L[2::3]
print L[4:50:5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;倒序切片&#34;&gt;倒序切片&lt;/h2&gt;
&lt;p&gt;对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]

&amp;gt;&amp;gt;&amp;gt; L[-2:]
[&#39;Bart&#39;, &#39;Paul&#39;]

&amp;gt;&amp;gt;&amp;gt; L[:-2]
[&#39;Adam&#39;, &#39;Lisa&#39;]

&amp;gt;&amp;gt;&amp;gt; L[-3:-1]
[&#39;Lisa&#39;, &#39;Bart&#39;]

&amp;gt;&amp;gt;&amp;gt; L[-4:-1:2]
[&#39;Adam&#39;, &#39;Bart&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。&lt;/p&gt;
&lt;h3 id=&#34;任务-8&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;利用倒序切片对 1 - 100 的数列取出：&lt;/p&gt;
&lt;p&gt;* 最后10个数；&lt;/p&gt;
&lt;p&gt;* 最后10个5的倍数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L = range(1, 101)
print L[-10:]
print L[-46::5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;对字符串切片&#34;&gt;对字符串切片&lt;/h2&gt;
&lt;p&gt;字符串 &#39;xxx&#39;和 Unicode字符串 u&#39;xxx&#39;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[:3]
&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[-3:]
&#39;EFG&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[::2]
&#39;ACEG&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。&lt;/p&gt;
&lt;h3 id=&#34;任务-9&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;字符串有个方法 upper() 可以把字符变成大写字母：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.upper()
&#39;ABC&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。&lt;/p&gt;
&lt;p&gt;**提示：**利用切片操作简化字符串操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def firstCharUpper(s):
    return s[0].upper() + s[1:]
print firstCharUpper(&#39;hello&#39;)
print firstCharUpper(&#39;sunday&#39;)
print firstCharUpper(&#39;september&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;迭代&#34;&gt;迭代&lt;/h1&gt;
&lt;h2 id=&#34;什么是迭代&#34;&gt;什么是迭代&lt;/h2&gt;
&lt;p&gt;在Python中，如果给定一个&lt;strong&gt;list&lt;/strong&gt;或&lt;strong&gt;tuple&lt;/strong&gt;，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。&lt;/p&gt;
&lt;p&gt;在Python中，迭代是通过 for ... in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for (i=0; i&amp;lt;list.length; i++) {
    n = list[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，Python的for循环抽象程度要高于Java的for循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：
1. 有序集合：list，tuple，str和unicode；
2. 无序集合：set
3. 无序集合并且具有 key-value 对：dict
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而迭代是一个动词，它指的是一种操作，&lt;strong&gt;在Python中，就是 for 循环&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。&lt;/p&gt;
&lt;h3 id=&#34;任务-10&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;请用for循环迭代数列 1-100 并打印出7的倍数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1, 101):
    if i % 7 == 0:
        print i
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;索引迭代&#34;&gt;索引迭代&lt;/h2&gt;
&lt;p&gt;Python中，&lt;strong&gt;迭代永远是取出元素本身，而非元素的索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？&lt;/p&gt;
&lt;p&gt;方法是使用 &lt;strong&gt;enumerate() 函数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]
&amp;gt;&amp;gt;&amp;gt; for index, name in enumerate(L):
...     print index, &#39;-&#39;, name
... 
0 - Adam
1 - Lisa
2 - Bart
3 - Paul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变成了类似：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[(0, &#39;Adam&#39;), (1, &#39;Lisa&#39;), (2, &#39;Bart&#39;), (3, &#39;Paul&#39;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，迭代的每一个元素实际上是一个tuple：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for t in enumerate(L):
    index = t[0]
    name = t[1]
    print index, &#39;-&#39;, name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for index, name in enumerate(L):
    print index, &#39;-&#39;, name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样不但代码更简单，而且还少了两条赋值语句。&lt;/p&gt;
&lt;p&gt;可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。&lt;/p&gt;
&lt;h3 id=&#34;任务-11&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;zip()函数可以把两个 list 变成一个 list：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; zip([10, 20, 30], [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])
[(10, &#39;A&#39;), (20, &#39;B&#39;), (30, &#39;C&#39;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在迭代 [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。&lt;/p&gt;
&lt;p&gt;**提示：**考虑使用zip()函数和range()函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]
for index, name in zip(range(1, len(L)+1), L):
    print index, &#39;-&#39;, name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;迭代dict的value&#34;&gt;迭代dict的value&lt;/h2&gt;
&lt;p&gt;我们已经了解了&lt;strong&gt;dict对象&lt;/strong&gt;本身就是可&lt;strong&gt;迭代对象&lt;/strong&gt;，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。&lt;/p&gt;
&lt;p&gt;如果我们希望迭代 dict 对象的value，应该怎么做？&lt;/p&gt;
&lt;p&gt;dict 对象有一个 &lt;strong&gt;values() 方法&lt;/strong&gt;，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }
print d.values()
# [85, 95, 59]
for v in d.values():
    print v
# 85
# 95
# 59
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果仔细阅读Python的文档，还可以发现，dict除了**values()**方法外，还有一个 &lt;strong&gt;itervalues()&lt;/strong&gt; 方法，用 &lt;strong&gt;itervalues()&lt;/strong&gt; 方法替代 &lt;strong&gt;values()&lt;/strong&gt; 方法，迭代效果完全一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }
print d.itervalues()
# &amp;lt;dictionary-valueiterator object at 0x106adbb50&amp;gt;
for v in d.itervalues():
    print v
# 85
# 95
# 59
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那这两个方法有何不同之处呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\1. &lt;strong&gt;values()&lt;/strong&gt; 方法实际上把一个 dict 转换成了包含 value 的list。&lt;/p&gt;
&lt;p&gt;\2. 但是 &lt;strong&gt;itervalues()&lt;/strong&gt; 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。&lt;/p&gt;
&lt;p&gt;\3. 打印 itervalues() 发现它返回一个 &lt;dictionary-valueiterator&gt; 对象，这说明在Python中，&lt;strong&gt;for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等&lt;/strong&gt;，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;任务-12&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;给定一个dict：&lt;/p&gt;
&lt;p&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }&lt;/p&gt;
&lt;p&gt;请计算所有同学的平均分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }
sum = 0.0
for v in d.itervalues():
    sum = sum + v
print sum / len(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;迭代dict的key和value&#34;&gt;迭代dict的key和value&lt;/h2&gt;
&lt;p&gt;我们了解了如何&lt;strong&gt;迭代 dict&lt;/strong&gt; 的&lt;strong&gt;key&lt;/strong&gt;和&lt;strong&gt;value&lt;/strong&gt;，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。&lt;/p&gt;
&lt;p&gt;首先，我们看看 dict 对象的 &lt;strong&gt;items()&lt;/strong&gt; 方法返回的值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }
&amp;gt;&amp;gt;&amp;gt; print d.items()
[(&#39;Lisa&#39;, 85), (&#39;Adam&#39;, 95), (&#39;Bart&#39;, 59)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; for key, value in d.items():
...     print key, &#39;:&#39;, value
... 
Lisa : 85
Adam : 95
Bart : 59
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和 values() 有一个 itervalues() 类似， &lt;strong&gt;items()&lt;/strong&gt; 也有一个对应的 &lt;strong&gt;iteritems()&lt;/strong&gt;，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。&lt;/p&gt;
&lt;h3 id=&#34;任务-13&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;请根据dict：&lt;/p&gt;
&lt;p&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }&lt;/p&gt;
&lt;p&gt;打印出 name : score，最后再打印出平均分 average : score。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }
sum = 0.0
for k, v in d.iteritems():
    sum = sum + v
    print k, &#39;:&#39;, v
print &#39;average&#39;, &#39;:&#39;, sum / len(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;列表生成式&#34;&gt;列表生成式&lt;/h1&gt;
&lt;h2 id=&#34;生成列表&#34;&gt;生成列表&lt;/h2&gt;
&lt;p&gt;要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; range(1, 11)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = []
&amp;gt;&amp;gt;&amp;gt; for x in range(1, 11):
...    L.append(x * x)
... 
&amp;gt;&amp;gt;&amp;gt; L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。&lt;/p&gt;
&lt;p&gt;写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。&lt;/p&gt;
&lt;h3 id=&#34;任务-14&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, ..., 99x100]&lt;/p&gt;
&lt;p&gt;**提示：**range(1, 100, 2) 可以生成list [1, 3, 5, 7, 9,...]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print [x * (x + 1) for x in range(1, 100, 2)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;复杂表达式&#34;&gt;复杂表达式&lt;/h2&gt;
&lt;p&gt;使用&lt;strong&gt;for循环&lt;/strong&gt;的迭代不仅可以迭代普通的list，还可以迭代dict。&lt;/p&gt;
&lt;p&gt;假设有如下的dict：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tds = [&#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39; % (name, score) for name, score in d.iteritems()]
print &#39;&amp;lt;table&amp;gt;&#39;
print &#39;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;&#39;
print &#39;\n&#39;.join(tds)
print &#39;&amp;lt;/table&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**注：**字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。&lt;/p&gt;
&lt;p&gt;把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Lisa&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;85&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Adam&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;95&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Bart&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;59&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{% asset_img 540fcd2a0001ff4600940104.jpg %}&lt;/p&gt;
&lt;h3 id=&#34;任务-15&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;在生成的表格中，对于没有及格的同学，请把分数标记为红色。&lt;/p&gt;
&lt;p&gt;**提示：**红色可以用 &lt;td style=&#34;color:red&#34;&gt; 实现。&lt;/p&gt;
&lt;p&gt;{% asset_img 540fcd610001be6800940104.jpg%}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }
def generate_tr(name, score):
    if score &amp;lt; 60:
        return &#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td style=&amp;quot;color:red&amp;quot;&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39; % (name, score)
    return &#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39; % (name, score)
tds = [generate_tr(name, score) for name, score in d.iteritems()]
print &#39;&amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt;&#39;
print &#39;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;&#39;
print &#39;\n&#39;.join(tds)
print &#39;&amp;lt;/table&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;条件过滤&#34;&gt;条件过滤&lt;/h2&gt;
&lt;p&gt;列表生成式的 &lt;strong&gt;for 循环后面还可以加上 if 判断&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。&lt;/p&gt;
&lt;h3 id=&#34;任务-16&#34;&gt;任务&lt;/h3&gt;
&lt;p&gt;请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\1. isinstance(x, str) 可以判断变量 x 是否是字符串；&lt;/p&gt;
&lt;p&gt;\2. 字符串的 upper() 方法可以返回大写的字母。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def toUppers(L):
    return [x.upper() for x in L if isinstance(x, str)]
print toUppers([&#39;Hello&#39;, &#39;world&#39;, 101])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多层表达式&#34;&gt;多层表达式&lt;/h2&gt;
&lt;p&gt;for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。&lt;/p&gt;
&lt;p&gt;对于字符串 &#39;ABC&#39; 和 &#39;123&#39;，可以使用两层循环，生成全排列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [m + n for m in &#39;ABC&#39; for n in &#39;123&#39;]
[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;翻译成循环代码就像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;L = []
for m in &#39;ABC&#39;:
    for n in &#39;123&#39;:
        L.append(m + n)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print [100 * n1 + 10 * n2 + n3 for n1 in range(1, 10) for n2 in range(10) for n3 in range(10) if n1==n3]
&lt;/code&gt;&lt;/pre&gt;
">Python入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/JDBC连接池-JDBCTemplate/"" data-c="
          &lt;h1 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h1&gt;
&lt;h2 id=&#34;1-概念&#34;&gt;1. 概念：&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;其实就是一个容器(集合)，存放数据库连接的容器。&lt;/li&gt;
&lt;li&gt;当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-好处&#34;&gt;2. 好处：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;节约资源&lt;/li&gt;
&lt;li&gt;用户访问高效&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-实现&#34;&gt;3. 实现：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;标准接口：DataSource   javax.sql包下的
&lt;ol&gt;
&lt;li&gt;方法：
&lt;ol&gt;
&lt;li&gt;获取连接：getConnection()&lt;/li&gt;
&lt;li&gt;归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;一般我们不去实现它，有数据库厂商来实现
&lt;ol&gt;
&lt;li&gt;C3P0：数据库连接池技术&lt;/li&gt;
&lt;li&gt;Druid：数据库连接池实现技术，由阿里巴巴提供的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-c3p0数据库连接池技术&#34;&gt;4. C3P0：数据库连接池技术&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不要忘记导入数据库驱动jar包&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;定义配置文件：
&lt;ol&gt;
&lt;li&gt;名称： c3p0.properties 或者 c3p0-config.xml&lt;/li&gt;
&lt;li&gt;路径：直接将文件放在src目录下即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; //1.创建数据库连接池对象
 DataSource ds  = new ComboPooledDataSource();
  //2. 获取连接对象
  Connection conn = ds.getConnection();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-druid数据库连接池实现技术由阿里巴巴提供的&#34;&gt;5. Druid：数据库连接池实现技术，由阿里巴巴提供的&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导入jar包 druid-1.0.9.jar&lt;/li&gt;
&lt;li&gt;定义配置文件：
&lt;ol&gt;
&lt;li&gt;是properties形式的&lt;/li&gt;
&lt;li&gt;可以叫任意名称，可以放在任意目录下&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;加载配置文件。Properties&lt;/li&gt;
&lt;li&gt;获取数据库连接池对象：通过&lt;strong&gt;工厂&lt;/strong&gt;来来获取  &lt;strong&gt;DruidDataSourceFactory&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;获取连接：&lt;strong&gt;getConnection&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		 //3.加载配置文件
	        Properties pro = new Properties();
	        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&amp;quot;druid.properties&amp;quot;);
	        pro.load(is);
	        //4.获取连接池对象
	        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
	        //5.获取连接
	        Connection conn = ds.getConnection();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义工具类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义一个类 JDBCUtils&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供静态代码块加载配置文件，初始化连接池对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取连接方法：通过数据库连接池获取连接&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;li&gt;获取连接池的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JDBCUtils {

			    //1.定义成员变量 DataSource
			    private static DataSource ds ;
			
			    static{
			        try {
			            //1.加载配置文件
			            Properties pro = new Properties();
			            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&amp;quot;druid.properties&amp;quot;));
			            //2.获取DataSource
			            ds = DruidDataSourceFactory.createDataSource(pro);
			        } catch (IOException e) {
			            e.printStackTrace();
			        } catch (Exception e) {
			            e.printStackTrace();
			        }
			    }
			
			    /**
			     * 获取连接
			     */
			    public static Connection getConnection() throws SQLException {
			        return ds.getConnection();
			    }
			
			    /**
			     * 释放资源
			     */
			    public static void close(Statement stmt,Connection conn){
			       /* if(stmt != null){
			            try {
			                stmt.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			        if(conn != null){
			            try {
			                conn.close();//归还连接
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }*/
			
			       close(null,stmt,conn);
			    }
			
			
			    public static void close(ResultSet rs , Statement stmt, Connection conn){
			
			
			        if(rs != null){
			            try {
			                rs.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			
			        if(stmt != null){
			            try {
			                stmt.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			        if(conn != null){
			            try {
			                conn.close();//归还连接
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			    }
			
			    /**
			     * 获取连接池方法
			     */
			
			    public static DataSource getDataSource(){
			        return  ds;
			    }
			
			}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;spring-jdbc&#34;&gt;Spring JDBC&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导入jar包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建JdbcTemplate对象。依赖于数据源DataSource&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JdbcTemplate template = new JdbcTemplate(ds);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用JdbcTemplate的方法来完成CRUD的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;update():执行DML语句。增、删、改语句&lt;/li&gt;
&lt;li&gt;queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：这个方法查询的结果集长度只能是1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;queryForList():查询结果将结果集封装为list集合
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;query():查询结果，将结果封装为JavaBean对象&lt;/li&gt;
&lt;li&gt;query的参数：RowMapper
&lt;ul&gt;
&lt;li&gt;一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装&lt;/li&gt;
&lt;li&gt;new BeanPropertyRowMapper&amp;lt;类型&amp;gt;(类型.class)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;queryForObject：查询结果，将结果封装为对象
&lt;ul&gt;
&lt;li&gt;一般用于聚合函数的查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改1号数据的 salary 为 10000&lt;/li&gt;
&lt;li&gt;添加一条记录&lt;/li&gt;
&lt;li&gt;删除刚才添加的记录&lt;/li&gt;
&lt;li&gt;查询id为1的记录，将其封装为Map集合&lt;/li&gt;
&lt;li&gt;查询所有记录，将其封装为List&lt;/li&gt;
&lt;li&gt;查询所有记录，将其封装为Emp对象的List集合&lt;/li&gt;
&lt;li&gt;查询总记录数&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;code&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    			import cn.itcast.domain.Emp;
    			import cn.itcast.utils.JDBCUtils;
    			import org.junit.Test;
    			import org.springframework.jdbc.core.BeanPropertyRowMapper;
    			import org.springframework.jdbc.core.JdbcTemplate;
    			import org.springframework.jdbc.core.RowMapper;

    			import java.sql.Date;
    			import java.sql.ResultSet;
    			import java.sql.SQLException;
    			import java.util.List;
    			import java.util.Map;

    			public class JdbcTemplateDemo2 {

    			    //Junit单元测试，可以让方法独立执行


    			    //1. 获取JDBCTemplate对象
    			    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
    			    /**
    			     * 1. 修改1号数据的 salary 为 10000
    			     */
    			    @Test
    			    public void test1(){

    			        //2. 定义sql
    			        String sql = &amp;quot;update emp set salary = 10000 where id = 1001&amp;quot;;
    			        //3. 执行sql
    			        int count = template.update(sql);
    			        System.out.println(count);
    			    }

    			    /**
    			     * 2. 添加一条记录
    			     */
    			    @Test
    			    public void test2(){
    			        String sql = &amp;quot;insert into emp(id,ename,dept_id) values(?,?,?)&amp;quot;;
    			        int count = template.update(sql, 1015, &amp;quot;郭靖&amp;quot;, 10);
    			        System.out.println(count);

    			    }

    			    /**
    			     * 3.删除刚才添加的记录
    			     */
    			    @Test
    			    public void test3(){
    			        String sql = &amp;quot;delete from emp where id = ?&amp;quot;;
    			        int count = template.update(sql, 1015);
    			        System.out.println(count);
    			    }

    			    /**
    			     * 4.查询id为1001的记录，将其封装为Map集合
    			     * 注意：这个方法查询的结果集长度只能是1
    			     */
    			    @Test
    			    public void test4(){
    			        String sql = &amp;quot;select * from emp where id = ? or id = ?&amp;quot;;
    			        Map&amp;lt;String, Object&amp;gt; map = template.queryForMap(sql, 1001,1002);
    			        System.out.println(map);
    			        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}

    			    }

    			    /**
    			     * 5. 查询所有记录，将其封装为List
    			     */
    			    @Test
    			    public void test5(){
    			        String sql = &amp;quot;select * from emp&amp;quot;;
    			        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = template.queryForList(sql);

    			        for (Map&amp;lt;String, Object&amp;gt; stringObjectMap : list) {
    			            System.out.println(stringObjectMap);
    			        }
    			    }

    			    /**
    			     * 6. 查询所有记录，将其封装为Emp对象的List集合
    			     */

    			    @Test
    			    public void test6(){
    			        String sql = &amp;quot;select * from emp&amp;quot;;
    			        List&amp;lt;Emp&amp;gt; list = template.query(sql, new RowMapper&amp;lt;Emp&amp;gt;() {

    			            @Override
    			            public Emp mapRow(ResultSet rs, int i) throws SQLException {
    			                Emp emp = new Emp();
    			                int id = rs.getInt(&amp;quot;id&amp;quot;);
    			                String ename = rs.getString(&amp;quot;ename&amp;quot;);
    			                int job_id = rs.getInt(&amp;quot;job_id&amp;quot;);
    			                int mgr = rs.getInt(&amp;quot;mgr&amp;quot;);
    			                Date joindate = rs.getDate(&amp;quot;joindate&amp;quot;);
    			                double salary = rs.getDouble(&amp;quot;salary&amp;quot;);
    			                double bonus = rs.getDouble(&amp;quot;bonus&amp;quot;);
    			                int dept_id = rs.getInt(&amp;quot;dept_id&amp;quot;);

    			                emp.setId(id);
    			                emp.setEname(ename);
    			                emp.setJob_id(job_id);
    			                emp.setMgr(mgr);
    			                emp.setJoindate(joindate);
    			                emp.setSalary(salary);
    			                emp.setBonus(bonus);
    			                emp.setDept_id(dept_id);

    			                return emp;
    			            }
    			        });


    			        for (Emp emp : list) {
    			            System.out.println(emp);
    			        }
    			    }

    			    /**
    			     * 6. 查询所有记录，将其封装为Emp对象的List集合
    			     */

    			    @Test
    			    public void test6_2(){
    			        String sql = &amp;quot;select * from emp&amp;quot;;
    			        List&amp;lt;Emp&amp;gt; list = template.query(sql, new BeanPropertyRowMapper&amp;lt;Emp&amp;gt;(Emp.class));
    			        for (Emp emp : list) {
    			            System.out.println(emp);
    			        }
    			    }

    			    /**
    			     * 7. 查询总记录数
    			     */

    			    @Test
    			    public void test7(){
    			        String sql = &amp;quot;select count(id) from emp&amp;quot;;
    			        Long total = template.queryForObject(sql, Long.class);
    			        System.out.println(total);
    			    }

    			}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
">JDBC连接池&JDBCTemplate</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-端口/"" data-c="
          &lt;h1 id=&#34;端口&#34;&gt;端口&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-端口读写指令&#34;&gt;1. 端口读写指令&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;in&lt;/li&gt;
&lt;li&gt;out&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;访问端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;in al , 60h;把60h中的数据读入al中
;1.cpu 通过地址线 将地址信息 60h 发出
;2.cpu 通过控制总线发出读命令 选择端口所在的芯片 并通知他 要从中读取数据
;3.端口所在的芯片 将60h端口中的数据通过数据线送入cpu
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2cmos-ram&#34;&gt;2.CMOS RAM&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;地址端口&lt;mark&gt;70h&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;数据端口 &lt;mark&gt;71h&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3shlshr&#34;&gt;3.shl,shr&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;移位指令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;左移&lt;/strong&gt;--&amp;gt;  *2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右移&lt;/strong&gt;–&amp;gt; \2&lt;/p&gt;
">汇编语言-端口</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-内中断/"" data-c="
          &lt;p&gt;内中断&lt;/p&gt;
&lt;h2 id=&#34;1产生&#34;&gt;1.产生&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;除法溢出&lt;/li&gt;
&lt;li&gt;单步执行&lt;/li&gt;
&lt;li&gt;执行into指令&lt;/li&gt;
&lt;li&gt;执行Int 指令&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-中断处理程序&#34;&gt;2. 中断处理程序&lt;/h2&gt;
&lt;h2 id=&#34;3-中断向量表&#34;&gt;3. 中断向量表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中断程序的入口地址&lt;/li&gt;
&lt;li&gt;存放256个中断程序入口地址&lt;/li&gt;
&lt;li&gt;存放在 &lt;strong&gt;0000:0000&lt;/strong&gt; 到 &lt;strong&gt;0000:03FF&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个表项占两个字，高-&amp;gt;段地址&lt;strong&gt;CS&lt;/strong&gt; 低-&amp;gt;偏移地址&lt;strong&gt;IP&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4中断的过程&#34;&gt;4.中断的过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;取得中断类型码N&lt;/li&gt;
&lt;li&gt;pushf&lt;/li&gt;
&lt;li&gt;TF=0,IF=0&lt;/li&gt;
&lt;li&gt;push CS&lt;/li&gt;
&lt;li&gt;push IP&lt;/li&gt;
&lt;li&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(IP)=(N*4),CS=(N*4)+2
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;开始执行中断程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5中断处理程序和iret指令&#34;&gt;5.中断处理程序和iret指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中断程序写法的常规步骤
&lt;ul&gt;
&lt;li&gt;保存要用的寄存器&lt;/li&gt;
&lt;li&gt;处理中断&lt;/li&gt;
&lt;li&gt;回复寄存器&lt;/li&gt;
&lt;li&gt;用iret指令返回 --&amp;gt; pop ip,pop cs,pop popf(pop psw)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-除法错误中断的处理&#34;&gt;6. 除法错误中断的处理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1. 出现溢出
2. 产生0号中断信息
3. 执行0号中断
4. 返回操作系统
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-编程处理0号中断&#34;&gt;7. 编程处理0号中断&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当发生除法溢出时，产生0号中断信息，从而引发中断过程
&lt;ol&gt;
&lt;li&gt;取得中断类型码N&lt;/li&gt;
&lt;li&gt;pushf&lt;/li&gt;
&lt;li&gt;TF=0,IF=0&lt;/li&gt;
&lt;li&gt;push CS&lt;/li&gt;
&lt;li&gt;push IP&lt;/li&gt;
&lt;li&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(IP)=(N*4),CS=(N*4)+2
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;发生0号中断时，Cpu转去执行中断处理程序
&lt;ol&gt;
&lt;li&gt;相关处理&lt;/li&gt;
&lt;li&gt;向显示缓冲区送字符串&lt;/li&gt;
&lt;li&gt;返回DOS&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;do0&lt;/mark&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;do0的程序应该放在那里
&lt;ol&gt;
&lt;li&gt;放在0号中断的向量表中0000:0200-0000:02FF&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;中断程序的入口地址放在那里
&lt;ol&gt;
&lt;li&gt;cs:0000:0002,ip:0000:0000&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写中断处理程序do0&lt;/li&gt;
&lt;li&gt;将do0送入0000:0200&lt;/li&gt;
&lt;li&gt;将do0的入口地址送到存储在中断向量表0号表项中&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;assume cs:code

code segment

start:	do0安装程序
		设置中断向量表
		mov ax,4c00h
		int 21h
do0:	显示字符串“overflow”
		mov ax,4c00h
		int 21h

code ends
end start
&lt;/code&gt;&lt;/pre&gt;
">汇编语言-内中断</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-标志寄存器/"" data-c="
          &lt;h1 id=&#34;标志寄存器&#34;&gt;标志寄存器&lt;/h1&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cf标志位carry-flag&#34;&gt;CF标志位&lt;strong&gt;Carry Flag&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;进位（最高位进位）add&lt;/li&gt;
&lt;li&gt;和运算相关的指令会影响标志位 like &lt;mark&gt;add , sub&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;把操作数当作无符号数字&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;zf标志位zero-flag&#34;&gt;ZF标志位&lt;strong&gt;Zero Flag&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断相等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后结果是否为零&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pf标志位pairty-flag&#34;&gt;PF标志位&lt;strong&gt;pairty Flag&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一的个数是否位偶数0 or 奇数1&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sf标志位sign-flag&#34;&gt;SF标志位&lt;strong&gt;Sign Flag&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;正0负1&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;计算的结果看陈整数和负数&lt;/li&gt;
&lt;li&gt;add sub 影响sf&lt;/li&gt;
&lt;li&gt;mul 不影响sf&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;of标志位overflow&#34;&gt;OF标志位&lt;strong&gt;Overflow&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;运算过程中看是否溢出&lt;/li&gt;
&lt;li&gt;两个操作数都当做有符号 运算过程中决定是否溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;adc-带进位的加法寄存器&#34;&gt;adc 带进位的加法寄存器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以对更大的数字进行加法运算&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sbb-带借位减法&#34;&gt;sbb 带借位减法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现对更大数的减法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cmp-比较指令&#34;&gt;cmp 比较指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类似于减法指令 只是不保存结果，只是影响相关的标志位寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以判断两个操作数的大小 通过 sf of 标志位&lt;/p&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;sf&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;of&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&amp;lt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&amp;lt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&amp;gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&amp;gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检测比较结果的转移指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和 cmp指令配合使用
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;指令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;检测相关的标志位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;je&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;equal&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;zf=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jne&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not equal&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;zf=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jb&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;below&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cf=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jnb&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not below&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cf=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ja&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;above&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cf=0 &amp;amp;&amp;amp; zf=1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jna&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;not above&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cf=1 || zf=1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;df-标志和串传送指令&#34;&gt;DF 标志和串传送指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;movsb&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;movsw&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配合rep 使用 rep like loop 由cx 的大小决定 执行 上述 两条指令的 次数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;exp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;-========movsb=====
mov cx,16
rep movsb
;循环16次 每次执行完后 si di ++
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;========movsw
mov cx,16
rep movsw
;循环16次每次 执行完 si,di --
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cld -&amp;gt; df==0**++**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;std -&amp;gt; df==1**--**&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pushf-popf&#34;&gt;pushf &amp;amp;&amp;amp; popf&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使 标志位寄存器 压栈和出栈&lt;/li&gt;
&lt;/ul&gt;
">汇编语言-标志寄存器</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-ret和call/"" data-c="
          &lt;h1 id=&#34;ret-和-call&#34;&gt;ret 和 call&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;指令执行过程
&lt;ul&gt;
&lt;li&gt;{% asset_img 20190928095954.png %}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通过栈中的数据来修改 cs  和 ip 同时还会 修改栈顶标志&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;ret用栈中的数据&#34;&gt;ret（用栈中的数据）&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;弹栈&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;近转移 ret 修改 IP &lt;em&gt;&lt;strong&gt;pop ip&lt;/strong&gt;&lt;/em&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(ip)=((ss)*16+(sp))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(sp)=(sp)+2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;远转移 retf 修改 cs:ip &lt;em&gt;&lt;strong&gt;pop ip,pop cs&lt;/strong&gt;&lt;/em&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(ip)=((ss)*16+(sp))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(sp)=(sp)+2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(cs)=((ss)*16+(sp))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(sp)=(sp)+2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;call不能实现短转移&#34;&gt;call(不能实现短转移)&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;类似&lt;strong&gt;jmp&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;call程序处理的数据一般要进行压栈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1根据位移进行转移&#34;&gt;1.根据位移进行转移&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;push ip
jmp near ptr 标号
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行过程 原理
&lt;ul&gt;
&lt;li&gt;call下一条指令的IP压栈后，转到标号处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2转移目的地址在指令中&#34;&gt;2.转移目的地址在指令中&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;call far ptr
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行过程 原理
&lt;ul&gt;
&lt;li&gt;call下一条指令的CS:IP压栈后，转到标号处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3转移地址在寄存器中&#34;&gt;3.转移地址在寄存器中&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;call 16 位 reg
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行过程 原理
&lt;ul&gt;
&lt;li&gt;call下一条指令的IP压栈后，转到&lt;mark&gt;reg&lt;/mark&gt; 处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-转移地址在内存中&#34;&gt;4. 转移地址在内存中&lt;/h3&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1&#34;&gt;1&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;call word ptr 内存单元地址
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行过程 原理
&lt;ul&gt;
&lt;li&gt;call下一条指令的IP压栈后，转到&lt;mark&gt;内存单元地址&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2&#34;&gt;2&lt;/h4&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;call dword ptr 内存单元地址
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行过程 原理
&lt;ul&gt;
&lt;li&gt;call下一条指令的CS:IP压栈后，转到标号处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;call-和-ret-共同应用&#34;&gt;call 和 ret 共同应用&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;就像函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;批量数据处理&#34;&gt;批量数据处理&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;assume cs:code,ds:data,ss:stack

data segment
	db &#39;conversation&#39;
data ends

stack segment
	db 16 dup(0)
stack ends

code segment


	start:  mov ax,data
			mov ds,ax
			mov si,0
			mov cx,12
			call capital
			mov ax,4c00h
			int 21h

	capital: and byte ptr ds:[si],11011111b
			 inc si;
			 loop capital
			 ret


code ends



end start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;寄存器冲突问题&#34;&gt;寄存器冲突问题&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;在子程序执行开头，把所需要用到的寄存器压栈&lt;/li&gt;
&lt;li&gt;在子程序完成后，从栈中弹出各个寄存其的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;assume cs:code,ds:data,ss:stack

data segment
	db &#39;word&#39;,0
	db &#39;unix&#39;,0
	db &#39;wind&#39;,0
	db &#39;good&#39;,0
data ends

stack segment
	db 128 dup(0)
stack ends

code segment


	start:  mov ax,data
			mov ds,ax

			mov cx,4
			mov bx,0

	s:      mov di,bx
			call capital
			add bx,5
			loop s

			mov ax,4c00h
			int 21h

	capital: push cx;执行子程序前压栈
			 push si

	change:	 mov cl,ds:[si]
			 mov ch,0
			 jcxz ok
			 and byte ptr ds:[si],11011111b
			 inc si
			 jmp change

		ok:	 pop si;执行完后弹栈
			 pop cx
			 ret


code ends



end start
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mul&#34;&gt;mul&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-8位&#34;&gt;1. 8位&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;一个默认放在&lt;mark&gt;AL&lt;/mark&gt;，另一个放在&lt;mark&gt;内存字节单元&lt;/mark&gt;或者&lt;mark&gt;8位reg&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;结果 默认 &lt;mark&gt;AX&lt;/mark&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-16位&#34;&gt;2. 16位&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一个默认放在&lt;mark&gt;AX&lt;/mark&gt;，另一个放在&lt;mark&gt;内存字单元&lt;/mark&gt;或者&lt;mark&gt;16位reg&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;结果 默认 高位在&lt;mark&gt;DX&lt;/mark&gt; ，低位在&lt;mark&gt;AX&lt;/mark&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;模块化程序设计&#34;&gt;模块化程序设计&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;mark&gt;ret&lt;/mark&gt;,&lt;mark&gt;call&lt;/mark&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参数和结果的传递&#34;&gt;参数和结果的传递&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;assume cs:code,ds:data,ss:stack

data segment
	dw 1,2,3,4,5,6,7,8
	dd 0,0,0,0,0,0,0,0
	db &#39;word&#39;,0
	db &#39;unix&#39;,0
	db &#39;wind&#39;,0
	db &#39;good&#39;,0
data ends

stack segment
	db 128 dup(0)
stack ends

code segment


	start:  mov ax,data
			mov ds,ax
			mov si,0
			mov bp,0
			call r_start


			mov ax,4c00h
			int 21h


	r_start:	mov bx,ds:[si]
				call cube
				mov ds:[16+bp],ax
				add si,2
				add bp,4
				loop r_start
				ret

		cube:	mov ax,bx
				mul bx
				mul bx
				ret

&lt;/code&gt;&lt;/pre&gt;
">汇编语言-ret和call</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-转移指令/"" data-c="
          &lt;h1 id=&#34;转移指令&#34;&gt;转移指令&lt;/h1&gt;
&lt;h2 id=&#34;1-操作符-offset&#34;&gt;1. 操作符 offset&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;取得标号的偏移地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-jmp-指令&#34;&gt;2. jmp 指令&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;无条件转移指令&lt;/li&gt;
&lt;li&gt;可同时修改 cs 和 ip 或者 ip&lt;/li&gt;
&lt;li&gt;给出两种信息
&lt;ul&gt;
&lt;li&gt;目的地址&lt;/li&gt;
&lt;li&gt;转移的距离（段间，段内短转移，段内近转移）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-依据位移进行的jmp指令&#34;&gt;3. 依据位移进行的jmp指令&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jmp-short-标号&#34;&gt;jmp short 标号&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;在编译是就已经处理好 要偏移的地址&lt;/li&gt;
&lt;li&gt;无论 本 命令在哪 只有 偏移地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jmp-near-ptr-标号&#34;&gt;jmp near ptr 标号&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;段内短转移&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-转移的目的地址在指令中的jmp指令&#34;&gt;4. 转移的目的地址在指令中的jmp指令&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;jmp-far-ptr-标号&#34;&gt;jmp far ptr 标号&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;同时修改 cs 和 ip&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-转移地址在寄存器中的jmp指令&#34;&gt;5. 转移地址在寄存器中的jmp指令&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;jmp ax&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-在内存中转移&#34;&gt;6 .在内存中转移&lt;/h2&gt;
&lt;hr&gt;
&lt;h4 id=&#34;jmp-word-ptr-标号&#34;&gt;jmp word ptr 标号&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;jmp word ptr ds:[0]&lt;/li&gt;
&lt;li&gt;只修改 IP&lt;/li&gt;
&lt;li&gt;段内转移&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;jmp-dword-ptr-标号&#34;&gt;jmp dword ptr 标号&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;段间转移&lt;/li&gt;
&lt;li&gt;ip[X+0],cs[X+2]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jcxz-短转移&#34;&gt;jcxz （短转移）&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;所有的有条件的跳转指令都是短转移&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;jmp cx zero&lt;/li&gt;
&lt;li&gt;只有在cx 为0 的情况下 才 执行 转移&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;loop短转移&#34;&gt;loop（短转移）&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;所有的循环指令都是短转移&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;cx 不为0 执行loop&lt;/li&gt;
&lt;/ul&gt;
">汇编语言-转移指令</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-数据处理的两个基本问题/"" data-c="
          &lt;h1 id=&#34;数据处理的两个基本问题&#34;&gt;数据处理的两个基本问题&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;sreg 段地址寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reg&lt;/strong&gt; 寄存器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;bxsidi和bp&#34;&gt;bx,si,di和bp&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;bx si/di组合&lt;/li&gt;
&lt;li&gt;bp si/di组合&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指令要处理的数据&#34;&gt;指令要处理的数据&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保存在CPU&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在内存中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在端口中&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据位置的表达&#34;&gt;数据位置的表达&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;立即数(idata)&lt;/li&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;段地址加偏移地址&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据的长度&#34;&gt;数据的长度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;byte 和 word&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在处理数据的时候要 告知 CPU 要处理的数据有多大可以通过一些方法来告知&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 通过寄存器来指明 如 &lt;mark&gt;ax&lt;/mark&gt;,代表对word操作而 &lt;mark&gt;al&lt;/mark&gt;,代表对byte 操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 无寄存器 则用 &lt;mark&gt;X ptr&lt;/mark&gt; 来表示 X 为byte 或者 word  如 ： mov word ptr ds:[0],1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.  用 push or pop 就不用 声明 因为 栈就是 对字进行操作&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;div-指令&#34;&gt;div 指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;除数&lt;/strong&gt; 有8位和16位 在一个reg或内存单元中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;被除数&lt;/strong&gt; 默认 放在 &lt;mark&gt;ax（16位）&lt;/mark&gt; 或者 &lt;mark&gt;dx（高16位） 和 ax（低16位）&lt;/mark&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;  &lt;mark&gt;al(商) ah(余数)&lt;/mark&gt; 或者 &lt;mark&gt;ax(商) dx(余数)&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;伪指令-dd-占两个字&#34;&gt;伪指令 dd (占两个字)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;相当于 两个 &lt;mark&gt;dw&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;四个 &lt;mark&gt;db&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dup&#34;&gt;dup&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用来重复数据&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;db 3 dup (0)  ==&amp;gt; db 0 ,0, 0&lt;/li&gt;
&lt;/ul&gt;
">汇编语言-数据处理的两个基本问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-定位内存地址的方法/"" data-c="
          &lt;h1 id=&#34;定位内存地址的方法&#34;&gt;定位内存地址的方法&lt;/h1&gt;
&lt;h2 id=&#34;and-和-or&#34;&gt;and 和 or&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;and 逻辑与  0  置为0
&lt;ol&gt;
&lt;li&gt;全为 &lt;strong&gt;1&lt;/strong&gt; 才出 &lt;strong&gt;1&lt;/strong&gt; 否则全部为 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可用于 对 二进制位的数字 设 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;or 逻辑或     1  置为1
&lt;ol&gt;
&lt;li&gt;只要有&lt;strong&gt;1&lt;/strong&gt; 就为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可用于对 二进制数字设 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;以字符的形式给出数据&#34;&gt;以字符的形式给出数据&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;like  ‘………’ 	其中单引号包含的 内容 编译器将把 其中的内容 转化为相应的 ASCII&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;大小写转换&#34;&gt;大小写转换&lt;/h2&gt;
&lt;p&gt;and 置为大写 1101 1111b&lt;/p&gt;
&lt;p&gt;or    置为小写 0100 0000b&lt;/p&gt;
&lt;h2 id=&#34;bxidata&#34;&gt;[bx+idata]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;idata 是立即数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;常用格式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mov ax,[200+bx]&lt;/li&gt;
&lt;li&gt;mov ax,200[bx]&lt;/li&gt;
&lt;li&gt;mov ax,[bx].200&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;可以处理数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;si-和-di&#34;&gt;SI 和 DI&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类似于&lt;strong&gt;BX&lt;/strong&gt; &lt;mark&gt;但是&lt;/mark&gt; 不能 分成两个 8 为寄存器&lt;/li&gt;
&lt;li&gt;全为偏移地址寄存器 &lt;strong&gt;&lt;mark&gt;bx为基址寄存器&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bxsi-和-bxdi&#34;&gt;[BX+SI] 	和 [BX+DI]&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;常用格式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mov ax,[bx] [si]&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;bxsiidata-和-bxdiidata&#34;&gt;[BX+SI+idata] 和 [bx+di+idata]&lt;/h2&gt;
">汇编语言-定位内存地址的方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-自己分配内存/"" data-c="
          &lt;h1 id=&#34;自己分配内存&#34;&gt;自己分配内存&lt;/h1&gt;
&lt;h2 id=&#34;自己分配内存-2&#34;&gt;自己分配内存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个 segement 最少占据 16 个字节&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;假设 数据段 有 N个字节 则 实际占用 $$(N/16 + 1)*16$$ 个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;都是 16 的倍数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Assembly&#34;&gt;//实验5
assume cs:codesg

a segment
		db 1,2,3,4,5,6,7,8
a ends

b segment
		db 1,2,3,4,5,6,7,8
b ends

c segment
		db 0,0,0,0,0,0,0,0
c ends

codesg segment

start:


		mov ax,c
		mov es,ax


		sub cx,cx
		sub bx,bx
		add cx,8

addnum: mov ax,a
		mov ds,ax

		sub dx,dx

		mov dl,ds:[bx] ;拿出第一个数据

		mov ax,b
		mov ds,ax

		add dl,ds:[bx]  ;拿出第二个数据,并且相加

		mov es:[bx],dl

		inc bx

		loop addnum



	mov ax,4c00h
	int 21h

codesg ends

end start
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;db 字节型&lt;/li&gt;
&lt;li&gt;dw 字型&lt;/li&gt;
&lt;/ul&gt;
">汇编语言-自己分配内存</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-第一个程序/"" data-c="
          &lt;h1 id=&#34;第一个程序&#34;&gt;第一个程序&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;编译和链接&#34;&gt;编译和链接&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;编译 masm .mas --&amp;gt; .obj&lt;/li&gt;
&lt;li&gt;链接 link .obj --&amp;gt; .exe&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;exe 文件 的描述信息中 保存的程序入口 地址&lt;br&gt;
然后 系统 通过 描述文件 来设置 cs:ip 和 其它内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;asm 文件 -- 汇编语言（&lt;strong&gt;1.汇编指令2.伪指令3.符号体系&lt;/strong&gt;）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;汇编指令 由编译器 翻译成010101 的机器指令 最后由 &lt;em&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;/em&gt; 执行&lt;/li&gt;
&lt;li&gt;伪指令和符号体系 由编译器执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;程序返回功能&lt;br&gt;
把系统加载程序的时候 给程序分配的内存 ， 设置的寄存器 返还给系统，因为 系统资源 是有限的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt; mov ax,4c00
 int 21H
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;程序的跟踪-debug-程序名&#34;&gt;程序的跟踪 debug + 程序名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;p 执行 int 指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;q 退出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cx == 程序长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PSP区 从 &lt;em&gt;&lt;strong&gt;ds:0&lt;/strong&gt;&lt;/em&gt; 开始的 256 个字节&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快速编译&#34;&gt;快速编译&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;字母型数字前面 必须加 0；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;默认代码（目前）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;assum cs:code

code segment

     ;填写内容

     mov ax,4c00H
     int 21H

code ends

end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;偏移地址寄存器-bx&#34;&gt;偏移地址寄存器 &lt;em&gt;&lt;strong&gt;bx&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
">汇编语言-第一个程序</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-寄存器（内存访问）/"" data-c="
          &lt;h1 id=&#34;寄存器内存访问&#34;&gt;寄存器（内存访问）&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3个段&#34;&gt;3个段&lt;/h4&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数据段&#34;&gt;数据段&lt;/h2&gt;
&lt;h3 id=&#34;1-字的存储&#34;&gt;1. 字的存储&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一次存放两个字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2&#34;&gt;2.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;内存地址由 &lt;strong&gt;段地址&lt;/strong&gt; 和 &lt;strong&gt;偏移地址&lt;/strong&gt; 构成&lt;br&gt;
其中段地址默认保存在DS寄存器当中&lt;br&gt;
偏移地址由 &lt;strong&gt;[address]&lt;/strong&gt; 保存告知&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-movaddsub-指令&#34;&gt;3. mov，add，sub 指令&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-d-段地址偏移地址&#34;&gt;4. -d 段地址：偏移地址&lt;/h3&gt;
&lt;h3 id=&#34;5-在内存中存放自己定义的数据通过-ds和-来-让cpu访问数据&#34;&gt;5. 在内存中存放自己定义的数据，通过 &lt;em&gt;&lt;strong&gt;ds和[]&lt;/strong&gt;&lt;/em&gt; 来 让CPU访问数据&lt;/h3&gt;
&lt;h2 id=&#34;代码段&#34;&gt;代码段&lt;/h2&gt;
&lt;h3 id=&#34;1-段地址存放在cs寄存器中&#34;&gt;1. 段地址存放在cs寄存器中&lt;/h3&gt;
&lt;h3 id=&#34;2-偏移地址存放在ip寄存器当中&#34;&gt;2. 偏移地址存放在ip寄存器当中&lt;/h3&gt;
&lt;h3 id=&#34;3-内存中存放代码&#34;&gt;3. 内存中存放代码&lt;/h3&gt;
&lt;h3 id=&#34;4-修改csip中的值就可使cpu执行代码&#34;&gt;4. 修改cs:ip中的值就可使CPU执行代码&lt;/h3&gt;
&lt;h2 id=&#34;栈段&#34;&gt;栈段&lt;/h2&gt;
&lt;h3 id=&#34;1-栈的作用&#34;&gt;1. 栈的作用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;临时性保存数据&lt;/li&gt;
&lt;li&gt;进行数据交换&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;-a
mov ax,1000
mov bx,2000
push ax
push bx
pop ax
pop bx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-栈的寄存器sssp&#34;&gt;2. 栈的寄存器ss:sp&lt;/h3&gt;
&lt;h3 id=&#34;3-操作指令puship&#34;&gt;3. 操作指令push&amp;amp;ip&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;push 执行过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.sp=sp-2（栈顶标记）&lt;br&gt;
2.传入字型数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pop 执行过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.传出字或字节&lt;br&gt;
2.sp=sp+2(栈顶标记）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;栈顶标记 在 数据（内存地址）的上面 的 内存地址&lt;br&gt;
sp 偏移地址寄存器 ss 段地址寄存器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-处理数据时要-临时存放数据&#34;&gt;4. 处理数据时要 ，临时存放数据&lt;/h3&gt;
&lt;h3 id=&#34;5-修改sssp中的值决定栈顶位置cpu在执行的过程中把我们定义的栈段当作栈使用&#34;&gt;5. 修改ss:sp中的值，决定栈顶位置，CPU在执行的过程中把我们定义的栈段当作栈使用&lt;/h3&gt;
&lt;h3 id=&#34;6-一段连续的内存地址&#34;&gt;6. 一段连续的内存地址&lt;/h3&gt;
&lt;h3 id=&#34;7-栈的容量的最大极限&#34;&gt;7. 栈的容量的最大极限&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;sp 的变化范围 0~ffffH 32768 个字型数据&lt;br&gt;
call 将指令IP 保存到内存的哪里？  ret 可以拿回&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;保存到栈中 为了让 ret 从栈中取回&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8每执行-一条-t-指令-就会将寄存器的值保存到-栈中&#34;&gt;8.每执行 一条 -t 指令 就会将寄存器的值保存到 栈中&lt;/h3&gt;
&lt;h2 id=&#34;内存的安全访问&#34;&gt;内存的安全访问&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安全空间 0：200~0: 2ffH&lt;/li&gt;
&lt;li&gt;内存分配的时间 1. 系统加载程序的时候 为程序分配的内存。2. 程序执行过程中，向系统再去要内存空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;承上启下&#34;&gt;承上启下&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;我们可以把内存任意的划分为 栈，数据，指令 ，他们可以是同一块内存，亦可以是不同的内存&lt;/li&gt;
&lt;li&gt;cpu 通过 ss:sp 所指向的 内存作为 栈&lt;/li&gt;
&lt;li&gt;ds:[] 所指向的 内存 作为数据&lt;/li&gt;
&lt;li&gt;cs:ip 所指向的 内存 作为指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;指令从哪里？数据从哪来？临时性的数据存放到哪里？&lt;/strong&gt;&lt;/p&gt;
">汇编语言-寄存器（内存访问）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/汇编语言-寄存器/"" data-c="
          &lt;h1 id=&#34;寄存器&#34;&gt;寄存器&lt;/h1&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小例子&lt;br&gt;
1.1 B800：0400 回车&lt;br&gt;
1.2 1空格 1空格&lt;br&gt;
1.3 2空格 2空格&lt;br&gt;
1.4    ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汇编程序员 就是 通过 汇编语言 中的 汇编指令 去修改 寄存器的值 从而 控制 CPU 控制整个计算机&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;通用寄存器&#34;&gt;通用寄存器&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;AX,BX,CX,DX&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;他们各自可分为两个 8 位寄存器(only)&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: Can&amp;#039;t use function &amp;#039;$&amp;#039; in math mode at position 9: ax=ah+al$̲$ $$(h==high,l=…&#39;&gt;ax=ah+al$$ $$(h==high,l==low)
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;1 byte = 8 bit(8位寄存器)==字节型数据&lt;br&gt;
2 byte =16 bit(16位寄存器)&lt;mark&gt;字型数据  &lt;code&gt;2个字节&lt;/code&gt;&lt;br&gt;
一个字型数据&lt;/mark&gt;2个字节型数据=高位字节+低位字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据与寄存器之间 要 保持一致性，8位寄存器给8位数据，16为寄存器给16位数据&lt;/strong&gt;&lt;br&gt;
&lt;mark&gt;不区&lt;/mark&gt;分大小写&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;地址寄存器指令寄存器-cs段地址和ip偏移地址&#34;&gt;（地址寄存器）指令寄存器 CS（段地址）和IP（偏移地址）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;jmp指令 jmp 2000:0 &lt;mark&gt;&lt;mark&gt;&amp;gt; cs&lt;/mark&gt;2000,ip&lt;/mark&gt;=0;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mov ax,1000&lt;br&gt;
jmp ax&lt;br&gt;
==&amp;gt; ip=1000;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只能用jmp指令修改cs,ip&lt;/p&gt;
&lt;p&gt;1.CPU从cs:ip 所指的内存单元中读取内容，存取到 指令缓存器当中&lt;br&gt;
2.然后IP跳转到下一个指令位置，并且在执行指令缓存器当中的指令&lt;br&gt;
3.重复1。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;段地址寄存器&lt;/th&gt;
&lt;th&gt;偏移地址寄存器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ds（内存）,es,ss（栈）,cs&lt;/td&gt;
&lt;td&gt;sp（栈）,bp,si,di,ip,bx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;指令的执行过程&#34;&gt;指令的执行过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CPU从cs:ip所指向的内存单元 读取 指令 然后 存放到 指令缓存器当中&lt;/li&gt;
&lt;li&gt;IP = IP + 所读指令的长度，从而指向下一条指令&lt;/li&gt;
&lt;li&gt;执行指令缓存器的内容，回到步骤1&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;debug&#34;&gt;debug&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;-r 查看和修改寄存器中的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-r cs&lt;br&gt;
cs value&lt;br&gt;
enter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-d 查看内存中的内容&lt;/strong&gt;  段地址加偏移地址&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-d ss:00&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;-v 将机器指令翻译成汇编指令&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;-a 以汇编指令的格式 在内存中写入一条汇编指令&lt;/strong&gt; 每次debug都的写&lt;br&gt;
&lt;strong&gt;-t 执行当前 cs:ip 所指的机器指令&lt;/strong&gt; 代码段&lt;br&gt;
&lt;strong&gt;-e 可以改写 内存中的内容（数据）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-p 快速执行完loop 指令&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;*-g 地址 ==== 一直执行到 地址 的 位置&lt;/em&gt;*&lt;/p&gt;
">汇编语言-寄存器</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/JDBC课堂笔记/"" data-c="
          &lt;h1 id=&#34;jdbc&#34;&gt;JDBC：&lt;/h1&gt;
&lt;h2 id=&#34;1-概念&#34;&gt;1. 概念：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2代码实现&#34;&gt;2.代码实现：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		  	//1. 导入驱动jar包
	        //2.注册驱动
	        Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
	        //3.获取数据库连接对象
	        Connection conn = DriverManager.getConnection(&amp;quot;jdbc:mysql://localhost:3306/db3&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);
	        //4.定义sql语句
	        String sql = &amp;quot;update account set balance = 500 where id = 1&amp;quot;;
	        //5.获取执行sql的对象 Statement
	        Statement stmt = conn.createStatement();
	        //6.执行sql
	        int count = stmt.executeUpdate(sql);
	        //7.处理结果
	        System.out.println(count);
	        //8.释放资源
	        stmt.close();
	        conn.close();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-详解各个对象&#34;&gt;3. 详解各个对象：&lt;/h2&gt;
&lt;h3 id=&#34;drivermanager驱动管理对象&#34;&gt;DriverManager：驱动管理对象&lt;/h3&gt;
&lt;h4 id=&#34;功能&#34;&gt;功能：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;注册驱动：告诉程序该使用哪一个数据库驱动jar&lt;/li&gt;
&lt;li&gt;获取数据库连接：&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;connection数据库连接对象&#34;&gt;Connection：数据库连接对象&lt;/h3&gt;
&lt;h4 id=&#34;功能-2&#34;&gt;功能：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;获取执行sql 的对象(&lt;strong&gt;Statement&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;管理事务：&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;statement执行sql的对象&#34;&gt;Statement：执行sql的对象&lt;/h3&gt;
&lt;h4 id=&#34;功能-3&#34;&gt;功能：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;执行sql&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;boolean execute(String sql) ：可以执行任意的sql 了解&lt;/li&gt;
&lt;li&gt;int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
&lt;ol&gt;
&lt;li&gt;返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 &lt;strong&gt;返回值&amp;gt;0&lt;/strong&gt;的则执行&lt;strong&gt;成功&lt;/strong&gt;，反之，则失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ResultSet executeQuery(String sql)  ：执行DQL（select)语句&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;/*
1. account表 添加一条记录
2. account表 修改记录	
3. account表 删除一条记录
*/

	    Statement stmt = null;
	    Connection conn = null;
	    try {
	        //1. 注册驱动
	        Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
	        //2. 定义sql
	        String sql = &amp;quot;insert into account values(null,&#39;王五&#39;,3000)&amp;quot;;
	        //3.获取Connection对象
	conn = DriverManager.getConnection(&amp;quot;jdbc:mysql:///db3&amp;quot;,&amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);
	        //4.获取执行sql的对象 Statement
	        stmt = conn.createStatement();
	        //5.执行sql
	        int count = stmt.executeUpdate(sql);//影响的行数
	        //6.处理结果
	        System.out.println(count);
	        if(count &amp;gt; 0){
	            System.out.println(&amp;quot;添加成功！&amp;quot;);
	        }else{
	            System.out.println(&amp;quot;添加失败！&amp;quot;);
	        }
	    } catch (ClassNotFoundException e) {
	        e.printStackTrace();
	    } catch (SQLException e) {
	        e.printStackTrace();
	    }finally {
	        //stmt.close();
	        //7. 释放资源
	        //避免空指针异常
	        if(stmt != null){
	            try {
	                stmt.close();
	            } catch (SQLException e) {
	                e.printStackTrace();
	            }
	        }
	        if(conn != null){
	            try {
	                conn.close();
	            } catch (SQLException e) {
	                e.printStackTrace();
	            }
	        }
	    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;resultset结果集对象封装查询结果&#34;&gt;ResultSet：结果集对象,封装查询结果&lt;/h3&gt;
&lt;h4 id=&#34;方法&#34;&gt;方法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true&lt;/li&gt;
&lt;li&gt;getXxx(参数):获取数据
&lt;ol&gt;
&lt;li&gt;Xxx：代表数据类型   如： int getInt() ,    String getString()&lt;/li&gt;
&lt;li&gt;参数：
&lt;ol&gt;
&lt;li&gt;int：代表列的编号,从1开始   如： getString(1)&lt;/li&gt;
&lt;li&gt;String：代表列名称。 如： getDouble(&amp;quot;balance&amp;quot;)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;注意：
&lt;ol&gt;
&lt;li&gt;使用步骤：
&lt;ol&gt;
&lt;li&gt;游标向下移动一行&lt;/li&gt;
&lt;li&gt;判断是否有数据&lt;/li&gt;
&lt;li&gt;获取数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;练习&#34;&gt;练习&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
	1. 定义Emp类
	2. 定义方法 public List&amp;lt;Emp&amp;gt; findAll(){}
	3. 实现方法 select * from emp;
*/
package cn.itcast.jdbc;

import cn.itcast.domain.Emp;
import cn.itcast.util.JDBCUtils;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
 */
public class JDBCDemo8 {

    public static void main(String[] args) {
        List&amp;lt;Emp&amp;gt; list = new JDBCDemo8().findAll2();
        System.out.println(list);
        System.out.println(list.size());
    }
    /**
     * 查询所有emp对象
     * @return
     */
    public List&amp;lt;Emp&amp;gt; findAll(){
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        List&amp;lt;Emp&amp;gt; list = null;
        try {
            //1.注册驱动
            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
            //2.获取连接
            conn = DriverManager.getConnection(&amp;quot;jdbc:mysql:///db3&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);
            //3.定义sql
            String sql = &amp;quot;select * from emp&amp;quot;;
            //4.获取执行sql的对象
            stmt = conn.createStatement();
            //5.执行sql
            rs = stmt.executeQuery(sql);
            //6.遍历结果集，封装对象，装载集合

            Emp emp = null;
            list = new ArrayList&amp;lt;Emp&amp;gt;();
            while(rs.next()){
                //获取数据
                int id = rs.getInt(&amp;quot;id&amp;quot;);
                String ename = rs.getString(&amp;quot;ename&amp;quot;);
                int job_id = rs.getInt(&amp;quot;job_id&amp;quot;);
                int mgr = rs.getInt(&amp;quot;mgr&amp;quot;);
                Date joindate = rs.getDate(&amp;quot;joindate&amp;quot;);
                double salary = rs.getDouble(&amp;quot;salary&amp;quot;);
                double bonus = rs.getDouble(&amp;quot;bonus&amp;quot;);
                int dept_id = rs.getInt(&amp;quot;dept_id&amp;quot;);
                // 创建emp对象,并赋值
                emp = new Emp();
                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                //装载集合
                list.add(emp);
            }

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(rs != null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(conn != null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
        return list;
    }


    /**
     * 演示JDBC工具类
     * @return
     */
    public List&amp;lt;Emp&amp;gt; findAll2(){
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        List&amp;lt;Emp&amp;gt; list = null;
        try {
           /* //1.注册驱动
            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
            //2.获取连接
            conn = DriverManager.getConnection(&amp;quot;jdbc:mysql:///db3&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);*/
            conn = JDBCUtils.getConnection();
            //3.定义sql
            String sql = &amp;quot;select * from emp&amp;quot;;
            //4.获取执行sql的对象
            stmt = conn.createStatement();
            //5.执行sql
            rs = stmt.executeQuery(sql);
            //6.遍历结果集，封装对象，装载集合
            Emp emp = null;
            list = new ArrayList&amp;lt;Emp&amp;gt;();
            while(rs.next()){
                //获取数据
                int id = rs.getInt(&amp;quot;id&amp;quot;);
                String ename = rs.getString(&amp;quot;ename&amp;quot;);
                int job_id = rs.getInt(&amp;quot;job_id&amp;quot;);
                int mgr = rs.getInt(&amp;quot;mgr&amp;quot;);
                Date joindate = rs.getDate(&amp;quot;joindate&amp;quot;);
                double salary = rs.getDouble(&amp;quot;salary&amp;quot;);
                double bonus = rs.getDouble(&amp;quot;bonus&amp;quot;);
                int dept_id = rs.getInt(&amp;quot;dept_id&amp;quot;);
                // 创建emp对象,并赋值
                emp = new Emp();
                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                //装载集合
                list.add(emp);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            /*if(rs != null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if(conn != null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }*/

            JDBCUtils.close(rs,stmt,conn);
        }
        return list;
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;preparedstatement执行sql的对象&#34;&gt;PreparedStatement：执行sql的对象&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题
&lt;ol&gt;
&lt;li&gt;输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a&lt;/li&gt;
&lt;li&gt;sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;解决sql注入问题：使用PreparedStatement对象来解决&lt;/li&gt;
&lt;li&gt;预编译的SQL：参数使用?作为占位符&lt;/li&gt;
&lt;li&gt;步骤：&lt;/li&gt;
&lt;li&gt;导入驱动jar包 mysql-connector-java-5.1.37-bin.jar&lt;/li&gt;
&lt;li&gt;注册驱动&lt;/li&gt;
&lt;li&gt;获取数据库连接对象 Connection&lt;/li&gt;
&lt;li&gt;定义sql
&lt;ol&gt;
&lt;li&gt;注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)&lt;/li&gt;
&lt;li&gt;给？赋值：
&lt;ol&gt;
&lt;li&gt;方法： setXxx(参数1,参数2)
&lt;ol&gt;
&lt;li&gt;参数1：？的位置编号 从1 开始&lt;/li&gt;
&lt;li&gt;参数2：？的值&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;执行sql，接受返回结果，不需要传递sql语句&lt;/li&gt;
&lt;li&gt;处理结果&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;li&gt;注意：后期都会使用PreparedStatement来完成增删改查的所有操作
&lt;ol&gt;
&lt;li&gt;可以防止SQL注入&lt;/li&gt;
&lt;li&gt;效率更高&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;抽取jdbc工具类-jdbcutils&#34;&gt;抽取JDBC工具类 ： JDBCUtils&lt;/h1&gt;
&lt;h3 id=&#34;目的简化书写&#34;&gt;目的：简化书写&lt;/h3&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;注册驱动也抽取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽取一个方法获取连接对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需求：不想传递参数（麻烦），还得保证工具类的通用性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决：配置文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;jdbc.properties&lt;/p&gt;
&lt;p&gt;​                    url=&lt;/p&gt;
&lt;p&gt;​                    user=&lt;/p&gt;
&lt;p&gt;​                    password=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽取一个方法释放资源&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;代码实现&#34;&gt;代码实现：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JDBCUtils {
	    private static String url;
	    private static String user;
	    private static String password;
	    private static String driver;
	    /**
	     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块
	     */
	    static{
	        //读取资源文件，获取值。
	
	        try {
	            //1. 创建Properties集合类。
	            Properties pro = new Properties();
	
	            //获取src路径下的文件的方式---&amp;gt;ClassLoader 类加载器
	            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
	            URL res  = classLoader.getResource(&amp;quot;jdbc.properties&amp;quot;);
	            String path = res.getPath();
	            System.out.println(path);
	            //2. 加载文件
	            pro.load(new FileReader(path));
	
	            //3. 获取数据，赋值
	            url = pro.getProperty(&amp;quot;url&amp;quot;);
	            user = pro.getProperty(&amp;quot;user&amp;quot;);
	            password = pro.getProperty(&amp;quot;password&amp;quot;);
	            driver = pro.getProperty(&amp;quot;driver&amp;quot;);
	            //4. 注册驱动
	            Class.forName(driver);
	        } catch (IOException e) {
	            e.printStackTrace();
	        } catch (ClassNotFoundException e) {
	            e.printStackTrace();
	        }
	    }
	
	
	    /**
	     * 获取连接
	     * @return 连接对象
	     */
	    public static Connection getConnection() throws SQLException {
	
	        return DriverManager.getConnection(url, user, password);
	    }
	
	    /**
	     * 释放资源
	     * @param stmt
	     * @param conn
	     */
	    public static void close(Statement stmt,Connection conn){
	        if( stmt != null){
	            try {
	                stmt.close();
	            } catch (SQLException e) {
	                e.printStackTrace();
	            }
	        }
	
	        if( conn != null){
	            try {
	                conn.close();
	            } catch (SQLException e) {
	                e.printStackTrace();
	            }
	        }
	    }
	
	
	    /**
	     * 释放资源
	     * @param stmt
	     * @param conn
	     */
	    public static void close(ResultSet rs,Statement stmt, Connection conn){
	        if( rs != null){
	            try {
	                rs.close();
	            } catch (SQLException e) {
	                e.printStackTrace();
	            }
	        }
	
	        if( stmt != null){
	            try {
	                stmt.close();
	            } catch (SQLException e) {
	                e.printStackTrace();
	            }
	        }
	
	        if( conn != null){
	            try {
	                conn.close();
	            } catch (SQLException e) {
	                e.printStackTrace();
	            }
	        }
	    }
	
	}
&lt;/code&gt;&lt;/pre&gt;
">JDBC课堂笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/常用API/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;常用api&#34;&gt;常用API&lt;/h1&gt;
&lt;h1 id=&#34;api&#34;&gt;API&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给 我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学 习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。&lt;/p&gt;
&lt;h2 id=&#34;api使用过程&#34;&gt;API使用过程&lt;/h2&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;打开帮助文档。&lt;/li&gt;
&lt;li&gt;点击显示，找到索引，看到输入框。&lt;/li&gt;
&lt;li&gt;你要找谁？在输入框里输入，然后回车。&lt;/li&gt;
&lt;li&gt;看包。java.lang下的类不需要导包，其他需要。&lt;/li&gt;
&lt;li&gt;看类的解释和说明。&lt;/li&gt;
&lt;li&gt;学习构造方法。&lt;/li&gt;
&lt;li&gt;使用成员方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;scanner类&#34;&gt;Scanner类&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;读取一个数&#34;&gt;读取一个数&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Scanner sc = new Scanner(System.in);
int num = sc.nextInt();
System.out.println(num);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;random类&#34;&gt;Random类&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;产生随机数&#34;&gt;产生随机数&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Random rm = new Random();
int num = rm.nextInt();
System.out.println(num);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;产生-0n-之间的随机数&#34;&gt;产生 [0，n) 之间的随机数&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int num = rm.nextInt(10);
System.out.println(num);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;arraylist类&#34;&gt;ArrayList类&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;对象数组&#34;&gt;对象数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo01 {
    public static void main(String[] args) {
        Person[] array = new Person[3];

        Person one = new Person(&amp;quot;01&amp;quot;,1);
        Person two = new Person(&amp;quot;02&amp;quot;,2);
        Person three = new Person(&amp;quot;03&amp;quot;,3);

        array[0]=one;//把one的地址值存到array[0]中
        array[1]=two;
        array[2]=three;

        System.out.println(array[0]);
        System.out.println(array[0].getName());//
        System.out.println(one.getAge());//

        for(int x=0;x&amp;lt;array.length;x++){
            System.out.println(array[x].getName()+&amp;quot; ---- &amp;quot;+array[x].getAge());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;alt + insert&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;arraylist容器&#34;&gt;ArrayList容器&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是&lt;strong&gt;大小可变的数组的实现&lt;/strong&gt;，存储在内的数据称为元素。此类提供一些方法来操作内部存储 的元素。 ArrayList 中可不断添加元素，其&lt;strong&gt;大小也自动增长&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛型只能是&lt;strong&gt;引用类型&lt;/strong&gt;，&lt;strong&gt;不&lt;/strong&gt;能是&lt;strong&gt;基本类型&lt;/strong&gt;，要在array list中存储基本类型数据，必须使用基本类型对应的&lt;strong&gt;包装类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;包装类&lt;/strong&gt; 位于Java lang 下，不需要导包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本类型&lt;/th&gt;
&lt;th&gt;包装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;常用方法&#34;&gt;常用方法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean add(E e)//向集合中添加元素，参数类型和泛型一致

public E get(int index)//从集合中获取元素，参数是索引编号，从0开始，返回值为对应位置的元素，不删除
    
public E remove(int index)//从集合中删除元素，参数是索引编号，返回值就是所删除的元素
    
public int size() //获取集合的长度，返回值是集合中包含的元素个数
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;string-类&#34;&gt;String 类&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;注意&#34;&gt;注意&lt;/h2&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;String类代表字符串&lt;/li&gt;
&lt;li&gt;字符串都是常量，在创建后不可改变，&lt;mark&gt;如果要改变StringBuilder类对象&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;字符串可共享使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;创建字符串31种&#34;&gt;创建字符串&lt;em&gt;3+1&lt;/em&gt;种&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;mark&gt;三种构造方法，一种直接创建&lt;/mark&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: Can&amp;#039;t use function &amp;#039;$&amp;#039; in math mode at position 7: public$̲$     $$String(…&#39;&gt;public$$     $$String()$$  创建空白字符串
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: Can&amp;#039;t use function &amp;#039;$&amp;#039; in math mode at position 7: public$̲$  $$String(byt…&#39;&gt;public$$  $$String(byte[]$$   $$array$$$$)$$ 根据字节数组来创建字符串
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;字符串常量池堆中&#34;&gt;字符串常量池（堆中）&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;双引号直接创建的字符串在常量池&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于基本类型来说 ，==是值的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于引用类型来说， ==是地址值的比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024324.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串比较&#34;&gt;字符串比较&lt;/h2&gt;
&lt;h3 id=&#34;内容比较&#34;&gt;内容比较&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;public boolean  equals(Object obj) &lt;strong&gt;参数可以是任何对象，但只有字符串且相等才返回true&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;比较双方无序&lt;/li&gt;
&lt;li&gt;一个常量和一个变量 推荐 用常量调用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;public boolean equalsIgnoreCase(Object obj)  &lt;strong&gt;忽略大小写&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;mark&gt;alt + enter&lt;/mark&gt; local variable&lt;/p&gt;
&lt;h2 id=&#34;字符串相关信息获取&#34;&gt;字符串相关信息获取&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;int length（）；获取长度&lt;/li&gt;
&lt;li&gt;String contact（String str）；拼接字符串，返回拼接后的字符串&lt;/li&gt;
&lt;li&gt;char charAt(int index);获取指定位置的字符&lt;/li&gt;
&lt;li&gt;int indexOf(String str);返回字符串中首次出现str的index&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串的截取&#34;&gt;字符串的截取&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;public String substring(int index),//截取从index开始直到末尾&lt;/li&gt;
&lt;li&gt;public String substring（int begin,int end）//截取==[begin ,end)==&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串的转换&#34;&gt;字符串的转换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;public char[] toCharArray();//返回字符数组&lt;/li&gt;
&lt;li&gt;public byte[] getBytes(); //返回字节数据&lt;/li&gt;
&lt;li&gt;public String replace(CharSequence  oldstring,CharSequence newstring);// 替换，返回结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串的分割&#34;&gt;字符串的分割&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;String[] s = str3.split(&amp;quot; &amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;static静态&#34;&gt;static静态&lt;/h1&gt;
&lt;h2 id=&#34;关键字概述&#34;&gt;关键字概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个类成员变量或者方法，一旦使用&lt;strong&gt;static&lt;/strong&gt; 那么其内容不在属于 对象 ，而是属于 类本身&lt;/li&gt;
&lt;li&gt;凡是本类对象，共享同一份 数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关键字修饰成员变量&#34;&gt;关键字修饰成员变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class studentdemotest {
    public static void main(String[] args) {
        Student one = new Student(&amp;quot;001&amp;quot;,1);
        one.room=&amp;quot;100&amp;quot;;
        System.out.println(one.getName()+&amp;quot; &amp;quot;+one.getAge()+&amp;quot; &amp;quot;+one.getId()+&amp;quot; &amp;quot;+one.room);

        Student two = new Student(&amp;quot;002&amp;quot;,2);
        System.out.println(two.getName()+&amp;quot; &amp;quot;+two.getAge()+&amp;quot; &amp;quot;+two.getId()+&amp;quot; &amp;quot;+two.room);
    }
}
package cn.itcast.day07.static_demo;

public class Student {
    private  String name;
    private int age;
    private int id;
    static String room;
    private static int id_counter=0;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        this.id=++id_counter;
    }

    public Student() {
        id_counter++;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;arrays&#34;&gt;Arrays&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;java.until.Arrays 与数组相关的工具类，提供大量静态方法 来实现操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-将数组转换为字符串&#34;&gt;1. 将数组转换为字符串&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;默认输出&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;			int[] a = {1,2,3,444,56};
        String str = Arrays.toString(a);
        System.out.println(str);
//[1, 2, 3, 444, 56]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2排序&#34;&gt;2.排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;升序(从小到大)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;			int[] a = {1,2,3,444,56};
			Arrays.sort(a);
        String str1 = Arrays.toString(a);
        System.out.println(str1);
//[1, 2, 3, 56, 444]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;练习&#34;&gt;练习&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串排序后倒序输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Arrays;

public class practise {
    public static void main(String[] args) {
        String str = &amp;quot;sadfsfaleuwaefhlefaksfa&amp;quot;;

        char[] chars = str.toCharArray();
        Arrays.sort(chars);

        for (int i = chars.length - 1; i &amp;gt;= 0; i--) {
            System.out.println(chars[i]);
        }
    }
}
//wusssllkhfffffeeedaaaaa
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;math类&#34;&gt;Math类&lt;/h1&gt;
&lt;h2 id=&#34;1abs绝对值&#34;&gt;1.abs绝对值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; System.out.println(Math.abs(-5));//5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-ceil-向上取整&#34;&gt;2. ceil 向上取整&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(Math.ceil(4.1));//5.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-floor-向下取整&#34;&gt;3. floor 向下取整&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(Math.floor(4.8));//4.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-round-四舍五入&#34;&gt;4. round 四舍五入&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; System.out.println(Math.round(4.5));//5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;练习-2&#34;&gt;练习&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024236.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;objects&#34;&gt;objects&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-tostring方法&#34;&gt;1. toString方法&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;如果类中没重写，则打印输出的为地址值，否则则为其它&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2equals方法&#34;&gt;2.equals方法&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;默认比较两个对象的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;空指针安全&#34;&gt;空指针安全&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;null 不能调用方法，会抛出空指针异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;data类&#34;&gt;Data类&lt;/h1&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;unti&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;精确到毫秒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;日期和毫秒可相互转换&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日期-》毫秒 === 当前日期到时间原点的毫秒值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;毫秒-》日期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;getime()  把日期转换为毫秒&lt;/li&gt;
&lt;li&gt;Data（Long Date）long型数据 毫秒------带参构造&lt;/li&gt;
&lt;li&gt;Data（）–---------无参构造&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dataformat类抽象类&#34;&gt;DataFormat类(抽象类)&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;text&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;时间和字符串之间来转换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;system类&#34;&gt;System类&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;获取ms&#34;&gt;获取ms&lt;/h2&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public static void test01(){
        //获取毫秒值
        long b = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 9999; i++) {
            System.out.println(i);
        }
        long e = System.currentTimeMillis();
        System.out.println(&amp;quot;共计：&amp;quot;+(e-b)+&amp;quot;ms&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;copy-数组&#34;&gt;copy 数组&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void test02(){

        int [] s={1,2,3,4,5,};
        int [] d={6,7,8,9,10,};

        System.out.println(&amp;quot;befor copy:&amp;quot;+ Arrays.toString(d));
        System.arraycopy(s,0,d,0,3);
        System.out.println(&amp;quot;after cpoy:&amp;quot;+ Arrays.toString(d));

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;stringbuilder&#34;&gt;StringBuilder&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;java.lang.StringBUilder&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;mark&gt;字符串缓冲区&lt;/mark&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;//构造方法//StringBuilder()默认长度16//StringBuilder(str)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;constructor&#34;&gt;Constructor&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; StringBuilder bu1 = new StringBuilder();
        System.out.println(&amp;quot;bu1: &amp;quot;+bu1);

        StringBuilder bu2=new StringBuilder(&amp;quot;abc&amp;quot;);
        System.out.println(&amp;quot;bu2: &amp;quot;+bu2);
        /**
         * bu1:
         * bu2: abc
         */
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;methord&#34;&gt;methord&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;append&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) {
        //创建
        StringBuilder bu1=new StringBuilder();
		
        //String --&amp;gt; StringBuilder
        StringBuilder bu2 = bu1.append(&amp;quot;abc&amp;quot;);

        System.out.println(&amp;quot;bu1:&amp;quot;+bu1+&amp;quot; bu2: &amp;quot;+bu2+&amp;quot; &amp;quot;+(bu1==bu2));
        /*
        * bu1:abc bu2: abc true
        * */
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;toString()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        //StringBuilder---&amp;gt;String
        String s=bu1.toString();
        System.out.println(s);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;包装类&#34;&gt;包装类&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;把基本数据类型打包就可以使用相应的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int  ===&amp;gt; Integer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;char ==&amp;gt; Character&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其余全部为首字母大写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;装箱&#34;&gt;装箱&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//装箱
        //构造方法
        Integer in1 = new Integer(5);
        Integer in2 = new Integer(&amp;quot;4&amp;quot;);

        System.out.println(&amp;quot;in1: &amp;quot;+in1+&amp;quot; in2: &amp;quot;+in2);

        //静态方法
        Integer in3 = Integer.valueOf(1);
        System.out.println(&amp;quot;in3: &amp;quot;+in3);

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;拆箱&#34;&gt;拆箱&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; //拆箱
        int int1=in1.intValue();
        int int2=in2.intValue();
        int int3=in3.intValue();

        System.out.println(&amp;quot;in1: &amp;quot;+in1+&amp;quot; in2: &amp;quot;+in2);
        System.out.println(&amp;quot;in3: &amp;quot;+in3);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自动拆箱于装箱&#34;&gt;自动拆箱于装箱&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
        Integer integer = new Integer(5);
        integer=integer+2;//自动拆箱
        System.out.println(&amp;quot;integer: &amp;quot;+integer);

        ArrayList&amp;lt;Integer&amp;gt; al1=new ArrayList&amp;lt;&amp;gt;(1);
        //自动装箱
        al1.add(1);//al1.add(new Integer(1))
        int one=al1.get(0);//al1.get(1).valueOf ();
        int two=al1.get(0).intValue();
        System.out.println(&amp;quot;one: &amp;quot;+one+&amp;quot; two:&amp;quot;+two);

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本数据类型于字符串之间的相互转换&#34;&gt;基本数据类型于字符串之间的相互转换&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) {
        //基本类型转换成字符串
            //1.基本类型的值+“string”
        int int1 = 100;
        String s1 = int1 + &amp;quot;200&amp;quot;;
        System.out.println(&amp;quot;s1: &amp;quot;+s1);
            //包装类的静态方法toString(args)
        String s2 = Integer.toString(100);
        System.out.println(&amp;quot;s2: &amp;quot;+s2+100);
            //string类的静态方法valueOf()
        String s3=String.valueOf(200);
        System.out.println(&amp;quot;s3: &amp;quot;+s3+100);

        //String--&amp;gt;基本类型
            //使用包装类的静态方法paresXXX()
        int i = Integer.parseInt(s1);
        System.out.println(&amp;quot;s1: &amp;quot;+(i-200));

    }
&lt;/code&gt;&lt;/pre&gt;
">常用API</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/面向对象和封装/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;面向对象&#34;&gt;面向对象&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1概念&#34;&gt;1.概念&lt;/h2&gt;
&lt;p&gt;当实现一个功能的时候，不考虑具体的每一步该怎么做，而是让一个有该功能的人来做&lt;br&gt;
区别 &lt;strong&gt;面向过程&lt;/strong&gt;--每一步都亲历亲为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码用例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;      //面向过程
      System.out.print(&amp;quot;[&amp;quot;);
      for (int i = 0; i &amp;lt; arr.length; i++) {
          if (i == arr.length - 1) {
              System.out.println(arr[i] + &amp;quot;]&amp;quot;);
          } else
              System.out.print(arr[i] + &amp;quot;, &amp;quot;);
      }
      System.out.println(&amp;quot;*********************&amp;quot;);
      //面向对象
      System.out.println(Arrays.toString(arr));
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2基本特征&#34;&gt;2.基本特征&lt;/h2&gt;
&lt;h3 id=&#34;1封装&#34;&gt;1.&lt;strong&gt;封装&lt;/strong&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;方法就是封装&lt;/p&gt;
&lt;p&gt;private关键字也是一种分封装，修饰成员变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;间接访问成员变量，就必须定义一对方法  getter\setter&lt;/p&gt;
&lt;p&gt;封装就是隐藏细节信息，对外界不可见&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2继承&#34;&gt;2.&lt;strong&gt;继承&lt;/strong&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;*继承是多态的前提&lt;br&gt;
*没有继承就没有多态&lt;br&gt;
*共性抽取&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;父类&lt;/th&gt;
&lt;th&gt;子类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基类，超类&lt;/td&gt;
&lt;td&gt;派生类&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果子类与父类成员变量重名，则会有两种访问成员变量的方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;1.间接&lt;/th&gt;
&lt;th&gt;2. 直接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;方法属于谁，优先用，若无则向上找&lt;/td&gt;
&lt;td&gt;等号左边优先使用，属于本类若无则向上找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;如果子类，父类和局部成员变量重名&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;局部变量&lt;/th&gt;
&lt;th&gt;直接写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;本类的成员变量&lt;/td&gt;
&lt;td&gt;this.成员变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;父类的成员变量&lt;/td&gt;
&lt;td&gt;super.成员变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;子类方法的返回值必须 &amp;lt;= 父类的返回值&lt;br&gt;
子类方法的权限必须 &amp;gt;= 父类的权限&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;public &amp;gt; protected &amp;gt; (default) &amp;gt; private&lt;/p&gt;
&lt;p&gt;子类的构造方法中默认调用父类的构造方法super（）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3多态&#34;&gt;3.&lt;strong&gt;多态&lt;/strong&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;多种形态  秀明为学生又是人，既有学生形态，又有人类形态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;格式polymorphic &lt;strong&gt;左父右子  $$fatherclassName- obj = new- childclassName()$$&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3类和对象&#34;&gt;3.类和对象&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;类 是抽象的（设计图纸）&lt;br&gt;
对象 是具体的（手里的产品）&lt;br&gt;
类是对象的模板，对象是类的实体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1类的定义&#34;&gt;1.类的定义&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;类和事务的对比&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;世界&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;行为&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;现实&lt;/td&gt;
&lt;td&gt;事务的状态信息&lt;/td&gt;
&lt;td&gt;事务可以干什么&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;成员变量&lt;/td&gt;
&lt;td&gt;成员方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;类的定义实例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public class student {
     //成员变量
     String name;
     int age;
     //成员方法
     public void eat(){
         System.out.println(&amp;quot;eaaaaaaaaaaaaaaat&amp;quot;);
     }
     public  void  sleep(){
         System.out.println(&amp;quot;sleeeeeeeeeeeeeeep&amp;quot;);
     }
     public void study(){
         System.out.println(&amp;quot;stuuuuuuuuuuuuuuuudy&amp;quot;);
     }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2类的使用&#34;&gt;2.类的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;     //1.导包
     //2.创建
     student mike = new student();

     String name=&amp;quot;root&amp;quot;;
     mike.name=name;
     mike.age=18;

     System.out.println(mike.name);
     System.out.println(mike.age);

     mike.eat();
     mike.sleep();
     mike.study();
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当一个对象作为参数，传递到方法中，实际上是传递的对象的地址值&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;        返回值，其实就是返回对象的地址值
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4成员变量与局部变量&#34;&gt;4.成员变量与局部变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;成员变量相当于c里的全局变量&lt;/li&gt;
&lt;li&gt;生存期不同&lt;/li&gt;
&lt;li&gt;所处的内存区不同&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5this-类似于c的this指针&#34;&gt;5.this 类似于c++的this指针&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;参数的名字和成员变量的名字相同的时候用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-标准的类组成java-bean&#34;&gt;6. 标准的类组成（Java bean）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;all 成员变量都有private关键字&lt;/li&gt;
&lt;li&gt;为每一个成员变量编写 (getter和setter)&lt;/li&gt;
&lt;li&gt;编写一个无参构造函数和一个有参构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-快速生成代码&#34;&gt;7. 快速生成代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;code -&amp;gt; generate -&amp;gt; getter &amp;amp; setter&lt;/li&gt;
&lt;li&gt;or constructor&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8-继承代码规范&#34;&gt;8. 继承代码规范&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;父类就是普通的类&lt;/li&gt;
&lt;li&gt;子类格式为&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;public class 子类名 &lt;mark&gt;extends&lt;/mark&gt; 父类名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;9-匿名对象&#34;&gt;9. 匿名对象&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;new 类名（）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;10-final关键字最终的不可变的&#34;&gt;10. final关键字，最终的不可变的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以修饰一个类&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public final class name(){
    ....
    }
    翻译不能有任何子类（太监类）
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;可以修饰一个方法,则该方法不可被子类覆盖重写（override）不可和abstract关键字同时使用&lt;/li&gt;
&lt;li&gt;可以修饰局部变量，一次赋值，终身不变，只能赋值一次&lt;/li&gt;
&lt;li&gt;可以修饰成员变量，此变量不可变，必须手动直接赋值或者通过构造赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-內部类&#34;&gt;4. 內部类&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一个事务内包含另一个事务，一个类中包含另一个类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;身体和心脏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;类中套类，类随便用外，但是外用内需要局部类对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.成员内部类&lt;br&gt;
2.局部內部类（匿名内部类）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//1.成员内部类
修饰符 class 外部类名称{
  ·······
  修饰符 class 內部类名称{
  ·····
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;内部类访问&#34;&gt;内部类访问&lt;/h3&gt;
&lt;p&gt;1.直接访问&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//间接访问内部类
        body body = new body(&amp;quot;Jim&amp;quot;);
        body.methonBody();//外部类对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.间接访问&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//直接访问
        body.heart heart= new body(&amp;quot;Tom&amp;quot;).new heart();
        heart.methonHeart();
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;重名变量访问&lt;mark&gt;outer&lt;/mark&gt;&lt;br&gt;
&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
局部内部类（方法里面的类）&lt;br&gt;
&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;类定义的权限修饰符规则&#34;&gt;类定义的权限修饰符规则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;外部类&lt;/th&gt;
&lt;th&gt;成员內部类&lt;/th&gt;
&lt;th&gt;局部内部类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public（/default）&lt;/td&gt;
&lt;td&gt;全部都可&lt;/td&gt;
&lt;td&gt;什么都不写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;匿名内部类（重点）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;接口名 对象名 = new 接口名（）{&lt;br&gt;
@override&lt;br&gt;
方法实现&lt;br&gt;
}&lt;br&gt;
&lt;img src=&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;注意事项&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
">面向对象和封装</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/shell编程/"" data-c="
          &lt;h1 id=&#34;shell编程&#34;&gt;shell编程&lt;/h1&gt;
&lt;h2 id=&#34;编写简单的脚本&#34;&gt;&lt;strong&gt;编写简单的脚本&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# vim example.sh
#!/bin/bash 
#For Example BY linuxprobe.com 
pwd 
ls -al
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;​	Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三、四行的可执行语句也就是我们平时执行的Linux命令了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bash xxxxx.sh &lt;em&gt;执行&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接收用户的参数&#34;&gt;&lt;strong&gt;接收用户的参数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板了。为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。&lt;/p&gt;
&lt;p&gt;其实，Linux系统中的Shell脚本语言早就考虑到了这些，已经内设了用于接收参数的变量，变量之间可以使用空格间隔。例如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;对&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;应&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;当&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;前&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;脚&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;本&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;名&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;称&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0对应的是当前Shell脚本程序的名称，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;对&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;应&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;当&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;前&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;脚&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;本&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;序&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;名&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;称&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;#对应的是总共有几个参数，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;对&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;应&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;所&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;位&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;置&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;*对应的是所有位置的参数值，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;对&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;应&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;所&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;位&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;置&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第N个位置的参数值，如图4-15所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/Shell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE%E5%8F%98%E9%87%8F.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图4-15  Shell脚本程序中的参数位置变量&lt;/p&gt;
&lt;p&gt;理论过后我们来练习一下。尝试编写一个脚本程序示例，通过引用上面的变量参数来看下真实效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo &amp;quot;当前脚本名称为$0&amp;quot;
echo &amp;quot;总共有$#个参数，分别是$*。&amp;quot;
echo &amp;quot;第1个参数为$1，第5个为$5。&amp;quot;
[root@linuxprobe ~]# sh example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;判断用户的参数&#34;&gt;&lt;strong&gt;判断用户的参数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在本书前面章节中讲到，系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。条件测试语法的执行格式如图4-16所示。切记，条件表达式两边均应有一个空格。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图4-16  条件测试语句的执行格式&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;按照测试对象来划分，条件测试语句可以分为4种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文件测试语句；&lt;/p&gt;
&lt;p&gt;逻辑测试语句；&lt;/p&gt;
&lt;p&gt;整数值比较语句；&lt;/p&gt;
&lt;p&gt;字符串比较语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表4-3所示。&lt;/p&gt;
&lt;p&gt;表4-3                                                    文件测试所用的参数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;测试文件是否为目录类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;测试文件是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;判断是否为一般文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;测试当前用户是否有权限读取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;测试当前用户是否有权限写入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;测试当前用户是否有权限执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着目录不存在：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再使用文件测试语句来判断/etc/fstab是否为一般文件，如果返回值为0，则代表文件存在，且为一般文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# [ -f /etc/fstab ]
[root@linuxprobe ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&amp;amp;&amp;amp;，&lt;strong&gt;它表示当前面的命令执行成功后才会执行它后面的命令&lt;/strong&gt;，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# [ -e /dev/cdrom ] &amp;amp;&amp;amp; echo &amp;quot;Exist&amp;quot;
Exist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了逻辑“与”外，还有逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的&lt;strong&gt;命令执行失败后才会执行它后面的命令&lt;/strong&gt;，因此可以用来结合系统环境变量USER来判断当前登录的用户是否为非管理员身份：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# echo $USER
root
[root@linuxprobe ~]# [ $USER = root ] || echo &amp;quot;user&amp;quot;
[root@linuxprobe ~]# su - linuxprobe 
[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo &amp;quot;user&amp;quot;
user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三种逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果则将其变成正确的。&lt;/p&gt;
&lt;p&gt;我们现在切换回到root管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[linuxprobe@linuxprobe ~]$ exit
logout
[root@linuxprobe root]# [ $USER != root ] || echo &amp;quot;administrator&amp;quot;
administrator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就技术图书的写作来讲，一般有两种套路：让读者真正搞懂技术了；让读者觉得自己搞懂技术了。因此市面上很多浅显的图书会让读者在学完之后感觉进步特别快，这基本上是作者有意为之，目的就是让您觉得“图书很有料，自己收获很大”，但是在步入工作岗位后就露出短板吃大亏。所以刘遄老师决定继续提高难度，为读者增加一个综合的示例，一方面作为前述知识的总结，另一方面帮助读者夯实基础，能够在今后工作中更灵活地使用逻辑符号。&lt;/p&gt;
&lt;p&gt;当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的USER变量名称是否等于root，然后用逻辑运算符“非”进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运算符输出user字样；或条件不满足则会通过逻辑“或”运算符输出root字样，而如果前面的&amp;amp;&amp;amp;不成立才会执行后面的||符号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# [ $USER != root ] &amp;amp;&amp;amp; echo &amp;quot;user&amp;quot; || echo &amp;quot;root&amp;quot;
root
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表4-4所示。&lt;/p&gt;
&lt;p&gt;表4-4                                                  可用的整数比较运算符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-eq&lt;/td&gt;
&lt;td&gt;是否等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ne&lt;/td&gt;
&lt;td&gt;是否不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-gt&lt;/td&gt;
&lt;td&gt;是否大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-lt&lt;/td&gt;
&lt;td&gt;是否小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-le&lt;/td&gt;
&lt;td&gt;是否等于或小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ge&lt;/td&gt;
&lt;td&gt;是否大于或等于&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;接下来小试牛刀。我们先测试一下10是否大于10以及10是否等于10（通过输出的返回值内容来判断）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?
1
[root@linuxprobe ~]# [ 10 -eq 10 ]
[root@linuxprobe ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在2.4节曾经讲过free命令，它可以用来获取当前系统正在使用及可用的内存量信息。接下来先使用free -m命令查看内存使用量情况（单位为MB），然后通过grep Mem:命令过滤出剩余内存量的行，再用awk &#39;{print $4}&#39;命令只保留第四列，最后用FreeMem=&lt;code&gt;语句&lt;/code&gt;的方式把语句内执行的结果赋值给变量。&lt;/p&gt;
&lt;p&gt;这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# free -m
            total     used     free     shared     buffers     cached
Mem:        1826      1244     582      9          1           413
-/+ buffers/cache:    830 996
Swap:       2047      0        2047
[root@linuxprobe ~]# free -m | grep Mem:
Mem:        1826      1244     582      9 
[root@linuxprobe ~]# free -m | grep Mem: | awk &#39;{print $4}&#39;
582
[root@linuxprobe ~]# FreeMem=`free -m | grep Mem: | awk &#39;{print $4}&#39;`
[root@linuxprobe ~]# echo $FreeMem 
582
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于1024，若小于则会提示“Insufficient Memory”（内存不足）的字样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# [ $FreeMem -lt 1024 ] &amp;amp;&amp;amp; echo &amp;quot;Insufficient Memory&amp;quot;
Insufficient Memory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;字符串&lt;/code&gt;比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表4-5所示。&lt;/p&gt;
&lt;p&gt;表4-5                                                常见的字符串比较运算符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;比较字符串内容是否相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;比较字符串内容是否不同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-z&lt;/td&gt;
&lt;td&gt;判断字符串内容是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;接下来通过判断String变量是否为空值，进而判断是否定义了这个变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# [ -z $String ]
[root@linuxprobe ~]# echo $?
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值LANG不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# echo $LANG
en_US.UTF-8
[root@linuxprobe ~]# [ $LANG != &amp;quot;en.US&amp;quot; ] &amp;amp;&amp;amp; echo &amp;quot;Not en.US&amp;quot;
Not en.US
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;流程控制语句&#34;&gt;&lt;strong&gt;流程控制语句&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;if、for、while、case这4种流程控制语句来学习编写难度更大、功能更强的Shell脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;if条件测试语句&#34;&gt;&lt;strong&gt;if条件测试语句&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;if条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。&lt;/p&gt;
&lt;p&gt;if条件语句的单分支结构由if、then、fi关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的if语句属于最简单的一种条件判断结构，语法格式如图4-17所示。&lt;br&gt;
&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8D%95%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-2.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;图4-17  单分支的if语句&lt;/p&gt;
&lt;p&gt;下面使用单分支的if条件语句来判断/media/cdrom文件是否存在，若存在就结束条件判断和整个Shell脚本，反之则去创建这个目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# vim mkcdrom.sh
#!/bin/bash
DIR=&amp;quot;/media/cdrom&amp;quot;
if [ ! -e $DIR ]
then
mkdir -p $DIR
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于第5章才讲解用户身份与权限，因此这里继续用“bash 脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用ls命令验证/media/cdrom目录是否已经成功创建：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# bash mkcdrom.sh
[root@linuxprobe ~]# ls -d /media/cdrom
/media/cdrom
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if条件语句的双分支结构也是一种很简单的判断结构，语法格式如图4-18所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8F%8C%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-1.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图4-18 双分支的if条件语句&lt;/p&gt;
&lt;p&gt;下面使用双分支的if条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用ping命令来测试与对方主机的网络联通性，而Linux系统中的ping命令不像Windows一样尝试4次就结束，因此为了避免用户等待时间过长，需要通过-c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &amp;amp;&amp;gt; /dev/null
if [ $? -eq 0 ]
then
echo &amp;quot;Host $1 is On-line.&amp;quot;
else
echo &amp;quot;Host $1 is Off-line.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在4.2.3小节中用过&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;作&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;显&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;示&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;次&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;命&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;令&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;返&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;回&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;值&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;。&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;若&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;前&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;面&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;那&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;条&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;语&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;句&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;则&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;作&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;显&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;示&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;次&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;命&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;令&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;返&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;回&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;值&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;若&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;前&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;面&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;那&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;条&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;语&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;句&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;成&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;功&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为0，从而获知那条语句的最终判断情况。这里的服务器IP地址为192.168.10.10，我们来验证一下脚本的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
[root@linuxprobe ~]# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图4-19所示。&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%A4%9A%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-2.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;图 4-19 多分支的if条件语句&lt;/p&gt;
&lt;p&gt;下面使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如Excellent、Pass、Fail等提示信息。在Linux系统中，read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于向用户显示一定的提示信息。在下面的脚本示例中，只有当用户输入的分数大于等于85分且小于等于100分，才输出Excellent字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于70分且小于等于84分，如果是，则输出Pass字样；若两次都落空（即两次的匹配操作都失败了），则输出Fail字样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@linuxprobe ~]# vim chkscore.sh
#!/bin/bash
read -p &amp;quot;Enter your score（0-100）：&amp;quot; GRADE
if [ $GRADE -ge 85 ] &amp;amp;&amp;amp; [ $GRADE -le 100 ] ; then
echo &amp;quot;$GRADE is Excellent&amp;quot;
elif [ $GRADE -ge 70 ] &amp;amp;&amp;amp; [ $GRADE -le 84 ] ; then
echo &amp;quot;$GRADE is Pass&amp;quot;
else
echo &amp;quot;$GRADE is Fail&amp;quot; 
fi
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
[root@linuxprobe ~]# bash chkscore.sh 
Enter your score（0-100）：80
80 is Pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面执行该脚本。当用户输入的分数分别为30和200时，其结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# bash chkscore.sh  
Enter your score（0-100）：30
30 is Fail
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：200 
200 is Fail
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么输入的分数为200时，依然显示Fail呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于100或小于0的分数时，给予Error报错字样的提示。&lt;/p&gt;
&lt;h3 id=&#34;for条件循环语句&#34;&gt;&lt;strong&gt;for条件循环语句&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;or循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用for循环语句再适合不过了。for循环语句的语法格式如图4-20所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/for%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图4-20  for循环语句的语法格式&lt;/p&gt;
&lt;p&gt;下面使用for循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# vim users.txt
andy
barry
carl
duke
eric
george
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来编写Shell脚本Example.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id 用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。&lt;/p&gt;
&lt;p&gt;需要多说一句，/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# vim Example.sh
#!/bin/bash
read -p &amp;quot;Enter The Users Password : &amp;quot; PASSWD
for UNAME in `cat users.txt`
do
id $UNAME &amp;amp;&amp;gt; /dev/null
if [ $? -eq 0 ]
then
echo &amp;quot;Already exists&amp;quot;
else
useradd $UNAME &amp;amp;&amp;gt; /dev/null
echo &amp;quot;$PASSWD&amp;quot; | passwd --stdin $UNAME &amp;amp;&amp;gt; /dev/null
if [ $? -eq 0 ]
then
echo &amp;quot;$UNAME , Create success&amp;quot;
else
echo &amp;quot;$UNAME , Create failure&amp;quot;
fi
fi
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行批量创建用户的Shell脚本Example.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后不会有其他内容。&lt;/p&gt;
&lt;p&gt;在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# bash Example.sh
Enter The Users Password : linuxprobe
andy , Create success
barry , Create success
carl , Create success
duke , Create success
eric , Create success
george , Create success
[root@linuxprobe ~]# tail -6 /etc/passwd
andy:x:1001:1001::/home/andy:/bin/bash
barry:x:1002:1002::/home/barry:/bin/bash
carl:x:1003:1003::/home/carl:/bin/bash
duke:x:1004:1004::/home/duke:/bin/bash
eric:x:1005:1005::/home/eric:/bin/bash
george:x:1006:1006::/home/george:/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您还记得在学习双分支if条件语句时，用到的那个测试主机是否在线的脚本么？既然我们现在已经掌握了for循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。&lt;/p&gt;
&lt;p&gt;首先创建一个主机列表文件ipadds.txt：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# vim ipadds.txt
192.168.10.10
192.168.10.11
192.168.10.12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后前面的双分支if条件语句与for循环语句相结合，让脚本从主机列表文件ipadds.txt中自动读取IP地址（用来表示主机）并将其赋值给HLIST变量，从而通过判断ping命令执行后的返回值来逐个测试主机是否在线。脚本中出现的$（命令）是一种完全类似于第3章的转义字符中反引号&lt;code&gt;命令&lt;/code&gt;的Shell操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# vim CheckHosts.sh
#!/bin/bash
HLIST=$(cat ~/ipadds.txt)
for IP in $HLIST
do
ping -c 3 -i 0.2 -W 3 $IP &amp;amp;&amp;gt; /dev/null
if [ $? -eq 0 ] ; then
echo &amp;quot;Host $IP is On-line.&amp;quot;
else
echo &amp;quot;Host $IP is Off-line.&amp;quot;
fi
done
[root@linuxprobe ~]# ./CheckHosts.sh
Host 192.168.10.10 is On-line.
Host 192.168.10.11 is Off-line.
Host 192.168.10.12 is Off-line.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;while条件循环语句&#34;&gt;&lt;strong&gt;while条件循环语句&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while语句的语法格式如图4-21所示。&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/while%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;图4-21  while循环语句的语法格式&lt;/p&gt;
&lt;p&gt;接下来结合使用多分支的if条件测试语句与while条件循环语句，编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们当前要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，这两者相等之后才运行exit 0命令，终止脚本的执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo &amp;quot;商品实际价格为0-999之间，猜猜看是多少？&amp;quot;
while true
do
read -p &amp;quot;请输入您猜测的价格数目：&amp;quot; INT
let TIMES++
if [ $INT -eq $PRICE ] ; then
echo &amp;quot;恭喜您答对了，实际价格是 $PRICE&amp;quot;
echo &amp;quot;您总共猜测了 $TIMES 次&amp;quot;
exit 0
elif [ $INT -gt $PRICE ] ; then
echo &amp;quot;太高了！&amp;quot;
else
echo &amp;quot;太低了！&amp;quot;
fi
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个Guess.sh脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到let TIMES++命令时都会让TIMES变量内的数值加1，用来统计循环总计执行了多少次。这可以让用户得知总共猜测了多少次之后，才猜对价格。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# bash Guess.sh
商品实际价格为0-999之间，猜猜看是多少？
请输入您猜测的价格数目：500
太低了！
请输入您猜测的价格数目：800
太高了！
请输入您猜测的价格数目：650
太低了！
请输入您猜测的价格数目：720
太高了！
请输入您猜测的价格数目：690
太低了！
请输入您猜测的价格数目：700
太高了！
请输入您猜测的价格数目：695
太高了！
请输入您猜测的价格数目：692
太高了！
请输入您猜测的价格数目：691
恭喜您答对了，实际价格是 691
您总共猜测了 9 次
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;case条件测试语句&#34;&gt;&lt;strong&gt;case条件测试语句&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果您之前学习过C语言，看到这一小节的标题肯定会会心一笑“这不就是switch语句嘛！”是的，case条件测试语句和switch语句的功能非常相似！case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。case语句的语法结构如图4-22所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/case%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png&#34; alt=&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图4-22  case条件测试语句的语法结构&lt;/p&gt;
&lt;p&gt;在前文介绍的Guess.sh脚本中有一个致命的弱点—只能接受数字！您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a是否大于等于3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。&lt;/p&gt;
&lt;p&gt;通过在脚本中组合使用case条件测试语句和通配符（详见第3章），完全可以满足这里的需求。接下来我们编写脚本Checkkeys.sh，提示用户输入一个字符并将其赋值给变量KEY，然后根据变量KEY的值向用户显示其值是字母、数字还是其他字符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@linuxprobe ~]# vim Checkkeys.sh
#!/bin/bash
read -p &amp;quot;请输入一个字符，并按Enter键确认：&amp;quot; KEY
case &amp;quot;$KEY&amp;quot; in
[a-z]|[A-Z])
echo &amp;quot;您输入的是 字母。&amp;quot;
;;
[0-9])
echo &amp;quot;您输入的是 数字。&amp;quot;
;;
*)
echo &amp;quot;您输入的是 空格、功能键或其他控制字符。&amp;quot;
esac
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：6
您输入的是 数字。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：p
您输入的是 字母。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：^[[15~
您输入的是 空格、功能键或其他控制字符。
&lt;/code&gt;&lt;/pre&gt;
">shell编程</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/常用命令/"" data-c="
          &lt;h1 id=&#34;文件处理命令&#34;&gt;文件处理命令&lt;/h1&gt;
&lt;h2 id=&#34;文件处理命令ls&#34;&gt;文件处理命令：ls&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：ls&lt;/p&gt;
&lt;p&gt;命令英文原意：list&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/ls&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;功能描述：显示目录文件&lt;/p&gt;
&lt;p&gt;语法：ls  选项[-ald]  [文件或目录]&lt;/p&gt;
&lt;p&gt;-a    显示所有文件，包括隐藏文件&lt;/p&gt;
&lt;p&gt;-l    详细信息显示(具体)&lt;/p&gt;
&lt;p&gt;-d  查看目录属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令cd&#34;&gt;文件处理命令：cd&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：cd&lt;/p&gt;
&lt;p&gt;命令英文原意：change directory&lt;/p&gt;
&lt;p&gt;命令所在路径：shell内置命令&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：cd [目录]&lt;/p&gt;
&lt;p&gt;功能描述：切换目录&lt;/p&gt;
&lt;p&gt;范例： $ cd  / 切换到根目录&lt;/p&gt;
&lt;p&gt;$ cd  ..回到上一级目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令touch&#34;&gt;文件处理命令：touch&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：touch&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/touch&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：touch  [文件名]&lt;/p&gt;
&lt;p&gt;功能描述：创建空文件&lt;/p&gt;
&lt;p&gt;范例： $ touch newfile&lt;/p&gt;
&lt;p&gt;有些服务器日志文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令mkdir&#34;&gt;文件处理命令：mkdir&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：mkdir&lt;/p&gt;
&lt;p&gt;命令英文原意：make directories&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/mkdir&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：mkdir  [目录名]&lt;/p&gt;
&lt;p&gt;功能描述：创建新目录&lt;/p&gt;
&lt;p&gt;范例： $ mkdir newdir&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令cp&#34;&gt;文件处理命令：cp&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：cp&lt;/p&gt;
&lt;p&gt;命令英文原意：copy&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/cp&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：cp  -R  [源文件或目录] [目的目录]&lt;/p&gt;
&lt;p&gt;​                   -R    复制目录&lt;/p&gt;
&lt;p&gt;功能描述：复制文件或目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cp  file1 file2  dir1 &lt;strong&gt;将文件file1、file2复制到目录dir1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cp  -R dir1 dir2 &lt;strong&gt;将dir1下的所有文件及子目录复制到dir2&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令mv&#34;&gt;文件处理命令：mv&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;文件处理命令：mv&lt;/p&gt;
&lt;p&gt;命令英文原意：move&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/mv&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：mv  [源文件或目录]  [目的目录]&lt;/p&gt;
&lt;p&gt;功能描述：移动文件、更名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;mv  file1 file3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将当前目录下文件file1更名为file3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mv  file2  dir2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将文件file2移动到目录dir2下&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令rm&#34;&gt;文件处理命令：rm&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：rm&lt;/p&gt;
&lt;p&gt;命令英文原意：remove&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/rm&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：rm  -r   [文件或目录]&lt;/p&gt;
&lt;p&gt;​					-r 删除目录&lt;/p&gt;
&lt;p&gt;功能描述：删除文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;$ rm file3 &lt;strong&gt;删除文件file3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rm -r dir1&lt;strong&gt;删除目录dir1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rm -f 强制不提问删除&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;rmdir命令&#34;&gt;rmdir命令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;nrmdir 命令参数说明：&lt;/p&gt;
&lt;p&gt;n-p 表示递归删除目录，如果子目录删除后若其父目录为空，则将一同删除；&lt;/p&gt;
&lt;p&gt;n比如rmdir  -p ccc/new表示删除ccc/目录中的new目录，若ccc也为空，则ccc目录也将被删除后。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令cat&#34;&gt;文件处理命令：cat&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：cat&lt;/p&gt;
&lt;p&gt;命令英文原意：concatenate and display files&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/cat&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：cat 文件名&lt;/p&gt;
&lt;p&gt;功能描述：显示文件内容&lt;/p&gt;
&lt;p&gt;范例： $ cat  /etc/issue&lt;/p&gt;
&lt;p&gt;​             $ cat  /etc/services&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令more&#34;&gt;文件处理命令：more&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：more&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/more&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：more  文件名&lt;/p&gt;
&lt;p&gt;(空格) 或f  	  显示下一页&lt;/p&gt;
&lt;p&gt;(Enter)			显示下一行&lt;/p&gt;
&lt;p&gt;q或Q			 退出&lt;/p&gt;
&lt;p&gt;功能描述：分页显示文件内容&lt;/p&gt;
&lt;p&gt;范例：   $ more  /etc/services&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理指令head&#34;&gt;文件处理指令：head&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;文件处理指令：head&lt;/p&gt;
&lt;p&gt;指令所在路径：/bin/head&lt;/p&gt;
&lt;p&gt;执行权限：All User&lt;/p&gt;
&lt;p&gt;语法：head  -num  [文件名]&lt;/p&gt;
&lt;p&gt;​					  -num  显示文件的前num行&lt;/p&gt;
&lt;p&gt;功能描述：查看文件的前几行&lt;/p&gt;
&lt;p&gt;范例：$ head  -20  /etc/services&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理指令tail&#34;&gt;文件处理指令：tail&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;指令名称：tail&lt;/p&gt;
&lt;p&gt;指令所在路径：/bin/tail&lt;/p&gt;
&lt;p&gt;执行权限：All User&lt;/p&gt;
&lt;p&gt;语法：tail  -num  [文件名]&lt;/p&gt;
&lt;p&gt;​					  -num  显示文件的后num行&lt;/p&gt;
&lt;p&gt;​					-f   	动态显示文件内容&lt;/p&gt;
&lt;p&gt;功能描述：查看文件的后几行&lt;/p&gt;
&lt;p&gt;范例： $ tail  -30  /etc/services&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;catmore-less-命令差异&#34;&gt;cat,more, less 命令差异&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;n这三者命令均具有查看文件内容之功能。&lt;/p&gt;
&lt;p&gt;ncat命令一次显示所有文件内容，而后两者可与用户交换以方便用户查看。&lt;/p&gt;
&lt;p&gt;ncat命令还具有合并文件之功能。&lt;/p&gt;
&lt;p&gt;nless允许用户后翻查看已经阅读过的内容；less并未在一开始就读入文件所有内容，因此其在查看文件时比vi速度快。&lt;/p&gt;
&lt;p&gt;nless比more支持更多的控制命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件处理命令ln&#34;&gt;文件处理命令：ln&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：ln&lt;/p&gt;
&lt;p&gt;命令英文原意：link&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/ln&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：ln  -s  [源文件]  [目标文件]&lt;/p&gt;
&lt;p&gt;​			-s  创建软链接&lt;/p&gt;
&lt;p&gt;功能描述：产生链接文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569395728536.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;权限管理命令&#34;&gt;权限管理命令&lt;/h1&gt;
&lt;h2 id=&#34;权限管理命令chmod&#34;&gt;权限管理命令：chmod&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569395787748.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569395805127.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代表字符&lt;/th&gt;
&lt;th&gt;权限&lt;/th&gt;
&lt;th&gt;对文件的含义&lt;/th&gt;
&lt;th&gt;对目录的含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;读权限&lt;/td&gt;
&lt;td&gt;可以查看文件   内容&lt;/td&gt;
&lt;td&gt;可以列出目录中   的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;写权限&lt;/td&gt;
&lt;td&gt;可以修改文件   内容&lt;/td&gt;
&lt;td&gt;可以在目录中创   建、删除文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;执行权限&lt;/td&gt;
&lt;td&gt;可以执行文件&lt;/td&gt;
&lt;td&gt;可以进入目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;权限管理命令chown&#34;&gt;权限管理命令：chown&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569395894091.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;权限管理命令chgrp&#34;&gt;权限管理命令：chgrp&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569395920736.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;权限管理命令umask&#34;&gt;权限管理命令：umask&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569395952435.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件搜索命令which&#34;&gt;文件搜索命令：which&lt;/h2&gt;
&lt;p&gt;{% asset_img 1569395976657.png  %}&lt;/p&gt;
&lt;h1 id=&#34;文件搜索命令&#34;&gt;文件搜索命令&lt;/h1&gt;
&lt;h2 id=&#34;文件搜索命令find&#34;&gt;文件搜索命令：find&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396005329.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396018569.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396030692.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件搜索指令locate&#34;&gt;文件搜索指令：locate&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396058511.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件搜索指令updatedb&#34;&gt;文件搜索指令：updatedb&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396210406.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件搜索命令grep&#34;&gt;文件搜索命令：grep&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396232647.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;帮助命令&#34;&gt;帮助命令&lt;/h1&gt;
&lt;h2 id=&#34;帮助命令man&#34;&gt;帮助命令：man&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396254275.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396293782.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;帮助指令info&#34;&gt;帮助指令：info&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396339210.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ninfo命令浏览系统在线帮助文档&lt;/p&gt;
&lt;p&gt;ninfo可通过链接和交叉引用来浏览文档&lt;/p&gt;
&lt;p&gt;ninfo也可直接跳转到相关章节&lt;/p&gt;
&lt;p&gt;ninfo命令用法： info command&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;帮助指令whatis&#34;&gt;帮助指令：whatis&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;指令名称：whatis  apropos  makewhatis&lt;/p&gt;
&lt;p&gt;指令英文原义：search the whatis database for strings&lt;/p&gt;
&lt;p&gt;指令所在路径：/usr/bin/whatis apropos&lt;/p&gt;
&lt;p&gt;​						  /usr/sbin/makewhatis&lt;/p&gt;
&lt;p&gt;执行权限：All User， All User，root&lt;/p&gt;
&lt;p&gt;语法：whatis apropos [任何关键字]&lt;/p&gt;
&lt;p&gt;功能描述：获得索引的简短说明信息&lt;/p&gt;
&lt;p&gt;范例：$whatis ls&lt;/p&gt;
&lt;p&gt;​				apropos fstab   &lt;mark&gt;相当于man -k&lt;/mark&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;压缩解压命令&#34;&gt;压缩解压命令&lt;/h1&gt;
&lt;h2 id=&#34;压缩解压命令gzip&#34;&gt;压缩解压命令：gzip&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396473842.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;压缩解压命令gunzip&#34;&gt;压缩解压命令：gunzip&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396499742.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;压缩解压命令tar&#34;&gt;压缩解压命令：tar&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：tar&lt;/p&gt;
&lt;p&gt;命令所在路径：/bin/tar&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：tar  选项[cvf]  [目录]&lt;/p&gt;
&lt;p&gt;​				  -c    产生.tar打包文件&lt;/p&gt;
&lt;p&gt;​				  -v显示详细信息&lt;/p&gt;
&lt;p&gt;​					-f  指定压缩后的文件名&lt;/p&gt;
&lt;p&gt;​					-z  打包同时压缩&lt;/p&gt;
&lt;p&gt;功能描述：打包目录&lt;/p&gt;
&lt;p&gt;压缩后文件格式：.tar.gz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396569481.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;tar命令解压缩语法：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396599104.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;压缩解压命令zip&#34;&gt;压缩解压命令：zip&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命令名称：zip&lt;/p&gt;
&lt;p&gt;命令所在路径：/usr/bin/zip&lt;/p&gt;
&lt;p&gt;执行权限：所有用户&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;zip  选项[-r]  [压缩后文件名称]  [文件或目录]&lt;/p&gt;
&lt;p&gt;​				-r 压缩目录&lt;/p&gt;
&lt;p&gt;功能描述：压缩文件或目录&lt;/p&gt;
&lt;p&gt;压缩后文件格式：.zip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396692106.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;压缩解压命令unzip&#34;&gt;压缩解压命令：unzip&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396725382.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;压缩解压命令bzip2&#34;&gt;压缩解压命令：bzip2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396753381.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;压缩解压命令bunzip2&#34;&gt;压缩解压命令：bunzip2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396783950.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;网络通信命令&#34;&gt;网络通信命令&lt;/h1&gt;
&lt;h2 id=&#34;网络通信指令write&#34;&gt;网络通信指令：write&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396810754.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;网络通信指令wall&#34;&gt;网络通信指令：wall&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396832808.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;网络通信命令ping&#34;&gt;网络通信命令：ping&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396959724.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;网络通信命令ifconfig&#34;&gt;网络通信命令：ifconfig&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569396978054.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h1 id=&#34;系统关机命令&#34;&gt;系统关机命令&lt;/h1&gt;
&lt;h2 id=&#34;系统关机命令shutdown&#34;&gt;系统关机命令：shutdown&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569397008585.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;-k&lt;/strong&gt; &lt;strong&gt;并不真正关机，只是发出警告信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;-r&lt;/strong&gt;  &lt;strong&gt;关机后立即重新启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;-h&lt;/strong&gt;  &lt;strong&gt;关机后不重新启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;-f&lt;/strong&gt;   &lt;strong&gt;快速关机，重启时跳过****fcsk&lt;/strong&gt; &lt;strong&gt;命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;-n&lt;/strong&gt; &lt;strong&gt;快速关机，不经过****init&lt;/strong&gt; &lt;strong&gt;程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;-c&lt;/strong&gt; &lt;strong&gt;shutdown&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;系统关机命令reboot&#34;&gt;系统关机命令：reboot&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569397091666.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;shell应用技巧&#34;&gt;Shell应用技巧&lt;/h1&gt;
&lt;h2 id=&#34;命令别名&#34;&gt;命令别名&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569397200117.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;输入输出重定向&#34;&gt;输入/输出重定向&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569397234285.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569397219217.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;管道&#34;&gt;管道&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;管道（&lt;/strong&gt;** pipe ** &lt;strong&gt;）是&lt;/strong&gt; &lt;strong&gt;UNIX&lt;/strong&gt; &lt;strong&gt;中最古老的进程间通信工具，它提供进程之间单向通信的方法。简单说，管道是连接一个进程的输出到另一个进程的输入的一种方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;管道：将一个命令的输出传送给另一个命令，&lt;/p&gt;
&lt;p&gt;作为另一个命令的输入。&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;p&gt;命令1|命令2|命令3……|命令n&lt;/p&gt;
&lt;p&gt;范例：&lt;/p&gt;
&lt;p&gt;ls -l /etc | more&lt;/p&gt;
&lt;p&gt;ls -l /etc | grep init&lt;/p&gt;
&lt;p&gt;ls -l /etc | grep init | wc -l&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;命令连接符&#34;&gt;命令连接符&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569397503944.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;命令替换符&#34;&gt;命令替换符&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;{% asset_img 1569397519948.png  %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
">常用命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://bgst009.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;学习备忘&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;Nobody&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;骑行&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;阅读下面的内容，理解每一个细节，然后构选程序来描述函数指针数组的用法和向函数传函数指针的方法&lt;/p&gt;\n&lt;p&gt;关于函数指针&lt;/p&gt;\n&lt;p&gt;指针的值是地址，函数指针的值是函数的入口地址&lt;/p&gt;\n&lt;p&gt;下面与&lt;code&gt;int&lt;/code&gt;·型变量对比，说明函数指针变量的定义方法&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int a;&lt;/code&gt;整型变量a&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int*a;&lt;/code&gt;整型指针变量a&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int a(char,char)&lt;/code&gt;;函数&lt;code&gt;a&lt;/code&gt;，函数类型为:返回值为&lt;code&gt;int&lt;/code&gt;，参数为&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int (*a)(char,char);&lt;/code&gt;返回值为&lt;code&gt;int&lt;/code&gt;，参数为 &lt;code&gt;charchar&lt;/code&gt;的函数的函数指针变量a&lt;/p&gt;\n&lt;p&gt;可见类型加 &lt;code&gt;*&lt;/code&gt; 则表示指向某种类型的指针。&lt;/p&gt;\n&lt;p&gt;为什么&lt;code&gt;int*a&lt;/code&gt;直接加&lt;code&gt;＊&lt;/code&gt;，而&lt;code&gt;int（*a）（char，char）&lt;/code&gt;要用括号？&lt;/p&gt;\n&lt;p&gt;如果不加括号&lt;code&gt;:int＊a（char，char）&lt;/code&gt;是返回&lt;code&gt;int＊&lt;/code&gt;的函数。为了不和函数&lt;code&gt;int*a（ char char）&lt;/code&gt;混淆加上括号，&lt;code&gt;int（*a）（char，char&lt;/code&gt;）表示一个指向函数的指针。&lt;/p&gt;\n&lt;p&gt;下面与&lt;code&gt;int&lt;/code&gt;型对比，说明函数指针类型的描述方法:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int a;&lt;/code&gt;整型变量a&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int&lt;/code&gt;整型&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int (*a)(char,char);&lt;/code&gt;函数指针a&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int (*)(char,char);&lt;/code&gt;函数指针&lt;code&gt;a&lt;/code&gt;返回值为&lt;code&gt;int&lt;/code&gt;型，参数为&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;的函数的函数指针&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;函数指针使用举例:&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;程序1&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int f(char, char);\nmain() {\n    int a;\n    int b;\n    long c;\n    int (*p)(char, char);\n\n    p = f;\n    b = (int)f;\n    c = (long)f;\n\n    printf(&amp;quot;main=%x f=%x\\n&amp;quot;, main, f);\n    printf(&amp;quot;p=%x    b=%x c=%lx\\n&amp;quot;, p, b, c);\n\n    a = p(1, 2);\n    printf(&amp;quot;%d\\n&amp;quot;, a);\n\n    a = ((int (*)(char, char))b)(1, 2);\n    printf(&amp;quot;%d\\n&amp;quot;, a);\n}\nint f(char a, char b) { return a + b; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;程序2&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int far f(char, char);\nmain() {\n    int a;\n    int b;\n    long c;\n    int(far * p)(char, char);\n\n    p = f;\n    b = (int)f;\n    c = (long)f;\n\n    printf(&amp;quot;main offset=%x\\n&amp;quot;, main);\n    printf(&amp;quot;main=%lx\\n&amp;quot;, (long)main);\n    printf(&amp;quot;f offset=%x\\n&amp;quot;, (int)f);\n    printf(&amp;quot;f=%lx\\n&amp;quot;, f);\n    printf(&amp;quot;p=%lx b=%x c=%lx\\n&amp;quot;, p, b, c);\n\n    a = p(1, 2);\n    printf(&amp;quot;%d\\n&amp;quot;, a);\n\n    a = ((int(far *)(char, char))c)(1, 2);\n    printf(&amp;quot;%d\\n&amp;quot;, a);\n}\nint far f(char a, char b) { return a + b; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;向函数传函数指针\&#34;&gt;向函数传函数指针&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int add(int a, int b) { return a + b; }\nint f2(int (*p)(int, int));\nint a;\nmain() {\n    p = add;\n    a = f2(p);\n    printf(&amp;quot;%d\\n&amp;quot;, a);\n}\nint f2(int (*p)(int, int)) {\n    printf(&amp;quot;---------------f2-----------------\\n&amp;quot;);\n    return p(1, 2) + 1;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201009102929.png\&#34; alt=\&#34;image-20201009102929141\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;函数指针数组的用法\&#34;&gt;函数指针数组的用法&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a * b; }\nint div(int a, int b) { return a / b; }\nint f2(int (*p)(int, int));\nvoid f3(int (*p[])(int, int), int);\nint (*p)(int, int);\nint (*pb[4])(int, int) = {add, sub, mul, div};\nint a;\nint i;\nmain() {\n    p = add;\n    a = f2(p);\n    printf(&amp;quot;%d\\n&amp;quot;, a);\n    f3(pb, 4);\n}\nint f2(int (*p)(int, int)) {\n    printf(&amp;quot;---------------f2-----------------\\n&amp;quot;);\n    return p(1, 2) + 1;\n}\nvoid f3(int (*p[])(int, int), int size) {\n    printf(&amp;quot;---------------f3-----------------\\n&amp;quot;);\n    for (i = 0; i &amp;lt; size; i++) {\n        a = p[i](8, 4);\n        printf(&amp;quot;%d\\n&amp;quot;, a);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201009103102.png\&#34; alt=\&#34;image-20201009103102619\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-10&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;C语言综合研究与高强度程序设计训练10&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-10-09 10:46:33&#34;,&#34;dateFormat&#34;:&#34;2020-10-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-10/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:212000,&#34;words&#34;:697,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n阅读下面的内容，理解每一个细节，然后构选程序来描述函数指针数组的用法和向函数传函数指针的方法\n关于函数指针\n指针的值是地址，函数指针的值是函数的入口地址\n下面与int·型变量对比，说明函数指针变量的定义方法\nint a;整型变量a\nint...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88\&#34;&gt;向函数传函数指针&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E7%94%A8%E6%B3%95\&#34;&gt;函数指针数组的用法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;写一个函数，&lt;code&gt;showstr（char…）&lt;/code&gt;，打印多个字符串，它可以接收不定数量的char型参&lt;br&gt;\n数，最后一个参数可传入0， &lt;code&gt;showstr&lt;/code&gt;通过此可以识别何时停止打印，返回&lt;br&gt;\n例子，调用 &lt;code&gt;showstr&lt;/code&gt;在屏幕上打印字符串&lt;code&gt;“This is program＂.“Welcome to＂Hello world！＂&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void showstr(char *, ...);\nchar *p1 = &amp;quot;This is a c program.&amp;quot;;\nchar *p2 = &amp;quot;Welcome to c !&amp;quot;;\nchar *p3 = &amp;quot;Hello world !&amp;quot;;\nint i = 0;\nmain() { showstr(p1, p2, p3, 0); }\nvoid showstr(char *str, ...) {\n    for (i = 0; (*(int *)(_BP + 4 + i)) != 0; i += 2) {\n        printf(&amp;quot;%s\\n&amp;quot;, *(int *)(_BP + 4 + i));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201008130007.png\&#34; alt=\&#34;image-20201008130007166\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-9&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;C语言综合研究与高强度程序设计训练9&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-10-08 10:45:57&#34;,&#34;dateFormat&#34;:&#34;2020-10-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-9/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:40000,&#34;words&#34;:138,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n写一个函数，showstr（char…），打印多个字符串，它可以接收不定数量的char型参\n数，最后一个参数可传入0， showstr通过此可以识别何时停止打印，返回\n例子，调用 showstr在屏幕上打印字符串“This is prog...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;综合研究六\&#34;&gt;综合研究六&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;了解浮点型数据在内存中是怎么存储的。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;把双精度的十进制转换为二进制科学计数法然后对应下图存储到内存中&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007103509.png\&#34; alt=\&#34;image-20201007103509309\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;假设 &lt;code&gt;a=8&lt;/code&gt;则其二进制科学计数法表示为 &lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1.000&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;1.000*2^3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;.&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.8141079999999999em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8141079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.063em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,双精度浮点数的存储格式为&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;1.&lt;/mn&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1023&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(-1)^s*1.f*2^{e-1023}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.664392em;\&#34;&gt;&lt;span style=\&#34;top:-3.063em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.8888799999999999em;vertical-align:-0.19444em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;.&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10764em;\&#34;&gt;f&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.8141079999999999em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8141079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.063em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34;&gt;e&lt;/span&gt;&lt;span class=\&#34;mbin mtight\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;2&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,符号位&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;s=0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.43056em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,指数位&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1026&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;010000000010&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;e=1026=0100 0000 0010&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.43056em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;e&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,有效位&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;f = 0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.8888799999999999em;vertical-align:-0.19444em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10764em;\&#34;&gt;f&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,故对应的二进制表示为&lt;code&gt;0100 0000 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&lt;/code&gt;十六进制为 &lt;code&gt;40 20 00 00 00 00 00 00 00&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编写程序验证&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;程序&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;double da = 8;\nmain() {\n    int i;\n    printf(&amp;quot;double %lf,address %lx,size %d\\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));\n    for (i = 0; i &amp;lt; sizeof(double); ++i) {\n        if (i % 2 == 0)\n            printf(&amp;quot;\\n&amp;quot;);\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);\n        printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;da) + i));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可以看到下图结果和预测的一致&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007105359.png\&#34; alt=\&#34;image-20201007105359297\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;一维数组和一级指针区别&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007110810.png\&#34; alt=\&#34;数组与指针\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int *pi;\nint i;\nvoid f();\nmain() {\n    f();\n    for (i = 0; i &amp;lt; 10; i++) {\n        printf(&amp;quot;%d &amp;quot;, pi[i]);\n    }\n}\nvoid f() {\n    int ia[10];\n    for (i = 0; i &amp;lt; 10; i++) {\n        ia[i] = i + 1;\n        printf(&amp;quot;%d &amp;quot;, ia[i]);\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    for (i = 0; i &amp;lt; 10; i++) {\n        printf(&amp;quot;%d &amp;quot;, *(ia + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n\n    pi = ia;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007124701.png\&#34; alt=\&#34;image-20201007124701011\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过上图可以看到在函数返回后再次打印结果只保存前两个数据&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;C中的延时函数&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;sleep（）&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;测试&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;double start, stop, durationTime;\nmain() {\n    printf(&amp;quot;start\\n&amp;quot;);\n    start = clock();\n    sleep(1 * 2);\n    stop = clock();\n    printf(&amp;quot;end\\n&amp;quot;);\n    durationTime = ((double)(stop - start)) / 10;\n    printf(&amp;quot;duration %lfs&amp;quot;, durationTime);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007111945.png\&#34; alt=\&#34;image-20201007111945051\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;int型变量（存储一般类型（char、int、long等）变量的地址）和指针变量加一操作的区别。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;变量加一为值加一，而指针变量加一为指针变量增加变量长度。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;char ca = &#39;a&#39;;\nint ia = 6;\nlong la = 7;\nchar *pca = &amp;amp;ca;\nint *pia = &amp;amp;ia;\nlong *pla = &amp;amp;la;\nmain() {\n    printf(&amp;quot;char ca: %c , ca+1: %c\\n&amp;quot;, ca, ca + 1);\n    printf(&amp;quot;int  ia: %d , ia+1: %d\\n&amp;quot;, ia, ia + 1);\n    printf(&amp;quot;long la: %ld , la+1: %ld\\n&amp;quot;, la, la + 1);\n    printf(&amp;quot;size\\n&amp;quot;);\n    printf(&amp;quot;char %d,int %d,long %d\\n&amp;quot;, sizeof(char), sizeof(int), sizeof(long));\n    printf(&amp;quot;pchar pca: %x , pca+1: %x\\n&amp;quot;, pca, pca + 1);\n    printf(&amp;quot;pint pia: %x , pia+1: %x\\n&amp;quot;, pia, pia + 1);\n    printf(&amp;quot;plong pla: %x , pla+1: %x\\n&amp;quot;, pla, pla + 1);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007113030.png\&#34; alt=\&#34;image-20201007113030495\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;综合研究7\&#34;&gt;综合研究7&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;了解C语言中的输入函数（写程序验证不同输入函数功能上的区别）。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;kbhit()&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;main() {\n    char ch;\n    //检查当前是否有键盘输入，若有则返回一个非0值，否则返回0\n    while (!kbhit()) {\n        cprintf(&amp;quot;hello world\\n&amp;quot;);\n        sleep(1);\n        if (kbhit()) {\n            ch = getch();\n            if (ch == 27)//ESE\n                break;\n        }\n    }\n    cprintf(&amp;quot;end\\n&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007130341.png\&#34; alt=\&#34;image-20201007130341728\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;bioskey&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void f2() {\n    int a;\n    /* 当用户再循环时不按下任何键时，bioskey(1) 一直为0，则 !bioskey(1)\n     * 为1，条件成立，继续循环，printf（），直到，用户任意按下一个键时，bioskey(1)不为0，成功退出。\n     */\n    a = 1;\n    while (!bioskey(a)) {\n        cprintf(&amp;quot;biosKey\\n&amp;quot;);\n        sleep(1);\n    }\n    cprintf(&amp;quot;end\\n&amp;quot;);\n\n    /*  当cmd是0，bioskey()返回下一个在键盘键入的值（它将等待到按下一个键）。\n     *  它返回一个16位的二进制数，包括两个不同的值。当按下一个普通键时，\n     * 它的低8位数存放该字符的ASCII码,高8位存放该键的扫描码；对于特殊键（如方向键、F1～F12等等），\n     * 低8位为0，高8位字节存放该键的扫描码。\n     */\n    a = 0;\n    printf(&amp;quot;\\n%c\\n&amp;quot;, bioskey(0));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007131456.png\&#34; alt=\&#34;image-20201007131455820\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void f3() {\n    int a, b, c, d;\n    scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);           /*输入整数并赋值给变量a */\n    scanf(&amp;quot;%d&amp;quot;, &amp;amp;b);           /* 输入整数并赋值给变量b */\n    printf(&amp;quot;a+b=%d\\n&amp;quot;, a + b); /* 计算a+b的值 */\n    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;c, &amp;amp;d);    /* 输入两个整数并分别赋值给c、d */\n    printf(&amp;quot;c*d=%d\\n&amp;quot;, c * d); /* 计算c*d的值 */\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007131934.png\&#34; alt=\&#34;image-20201007131934192\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;getche()&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void f4(){\n    char c;\n    c = getche();\n    printf(&amp;quot;c=&#39;%c&#39;\\n&amp;quot;, c);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007132418.png\&#34; alt=\&#34;image-20201007132418853\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;getch&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void f5() {\n    char c = getch();\n    printf(&amp;quot;c=&#39;%c&#39;\\n&amp;quot;, c);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;p&gt;​\t&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007132728.png\&#34; alt=\&#34;image-20201007132728673\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;gets&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void f6() {\n    /* gets() 会读取用户输入的整行内容，包括空格。而 scanf()\n     * 遇到空格就结束读取，也就是说，使用 scanf()\n     * 读取的字符串中永远不会包含空格。 */\n    char str1[30], str2[30]; /* 定义两个字符数组 */\n    gets(str1);\n    scanf(&amp;quot;%s&amp;quot;, str2);\n    puts(str1);\n    puts(str2);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007133158.png\&#34; alt=\&#34;image-20201007133158613\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;1007_-zong-he-yan-jiu-6-7-wen-ti-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;1007_综合研究6-7问题研究报告&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-10-07 10:45:26&#34;,&#34;dateFormat&#34;:&#34;2020-10-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/1007_-zong-he-yan-jiu-6-7-wen-ti-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:314000,&#34;words&#34;:1096,&#34;minutes&#34;:6},&#34;description&#34;:&#34;综合研究六\n\n\n了解浮点型数据在内存中是怎么存储的。\n\n\n把双精度的十进制转换为二进制科学计数法然后对应下图存储到内存中\n\n\n\n\n\n假设 a=8则其二进制科学计数法表示为 1.000∗231.000*2^31.000∗23,双精度浮点数的存...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6%E5%85%AD\&#34;&gt;综合研究六&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B67\&#34;&gt;综合研究7&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;（1）定义一个描述学生成绩的数据类型:&lt;br&gt;\n&lt;code&gt;struct stu｛ unsigned char c； unsigned char os； unsigned char masm； unsigned char java； struct stu far ＊next； ｝&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;struct stu&lt;/code&gt;型数据的前四个数据项存储学生的几门课程的成绩；数据项&lt;code&gt;next&lt;/code&gt;存储下一个学生成绩的地址。&lt;br&gt;\n（2）定义一个数组: &lt;code&gt;struct stu［375］&lt;/code&gt;；&lt;br&gt;\n（3）将内存0:0处的3000个数据当作375个 struct stu型的数据，将它们的c、os、masmjava数据项的内容拷贝到数组a的对应数据项中。&lt;br&gt;\n（4）查找数组a中课程成绩总分小于400大于200的数据，用next数据项将它们连接起来。（5）将连接起来的数据打印出来。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;struct stu {\n    unsigned char c;\n    unsigned char os;\n    unsigned char masm;\n    unsigned char java;\n    struct stu *next;\n};\n\nint n;\nstruct stu a[375];\nstruct stu *s;\nint sum;\nmain() {\n    long address = 0x00000000;\n\n    for (n = 0; n &amp;lt; 375; n++) {\n        a[n].c = *(char far *)address++;\n        a[n].os = *(char far *)address++;\n        a[n].masm = *(char far *)address++;\n        a[n].java = *(char far *)address++;\n    }\n\n    s-&amp;gt;next = 0;\n    for (n = 0; n &amp;lt; 375; n++) {\n        if (a[n].c + a[n].os + a[n].masm + a[n].java &amp;lt; 400 &amp;amp;&amp;amp;\n            a[n].c + a[n].os + a[n].masm + a[n].java &amp;gt; 200) {\n            a[n].next = s-&amp;gt;next;\n            s-&amp;gt;next = &amp;amp;a[n];\n        }\n    }\n\n    n = 0;\n    while (s-&amp;gt;next) {\n        s = s-&amp;gt;next;\n        if (!s)\n            break;\n        printf(&amp;quot;%d: &amp;quot;, ++n);\n        sum = s-&amp;gt;c + s-&amp;gt;os + s-&amp;gt;masm + s-&amp;gt;java;\n        printf(&amp;quot;c: %c,os: %c,masm: %c,java: %c,sum: %d\\n&amp;quot;, s-&amp;gt;c, s-&amp;gt;os, s-&amp;gt;masm,\n               s-&amp;gt;java, sum);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201005181125.png\&#34; alt=\&#34;image-20201005181125417\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-8&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;C语言综合研究与高强度程序8&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-10-05 10:44:37&#34;,&#34;dateFormat&#34;:&#34;2020-10-05&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-8/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:108000,&#34;words&#34;:353,&#34;minutes&#34;:2},&#34;description&#34;:&#34;\n（1）定义一个描述学生成绩的数据类型:\nstruct stu｛ unsigned char c； unsigned char os； unsigned char masm； unsigned char java； struct stu f...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;写一个程序，进行如下工作:&lt;br&gt;\n（1）从内存偏移地址2000h处开始，读取偏移地址n处的整型数据d，按照如下格式打印&lt;br&gt;\n偏移地址n数据d&lt;br&gt;\n（2）将数据d当作新的偏移地址n，读取偏移地址n处的整型数据d按照上面的格式打印。直到偏移地址为xff为，或用户从键盘输入字符“q”&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;1\&#34;&gt;1&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int n = 0x2000;\nint c;\nint t;\nmain() {\n    while (n != 0xffff &amp;amp;&amp;amp; c != &#39;q&#39;) {\n        printf(&amp;quot;offset address %xh -&amp;gt; data %c\\n&amp;quot;, n, *(char *)n);\n        printf(&amp;quot;stop input q: &amp;quot;);\n        scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);\n        printf(&amp;quot;\\ninput n: &amp;quot;);\n        scanf(&amp;quot;%x&amp;quot;, &amp;amp;t);\n        n += t;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201005123641.png\&#34; alt=\&#34;image-20201005123640831\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2\&#34;&gt;2&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;b.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int n = 0x2000;\nint c;\nint t;\nmain() {\n    while (n != 0xffff &amp;amp;&amp;amp; c != &#39;q&#39;) {\n        printf(&amp;quot;offset address %xh -&amp;gt; data %c\\n&amp;quot;, n, *(int *)n);\n\n        printf(&amp;quot;stop input q: &amp;quot;);\n        scanf(&amp;quot;%c&amp;quot;, &amp;amp;c);\n\n        printf(&amp;quot;\\ninput n: &amp;quot;);\n        scanf(&amp;quot;%x&amp;quot;, &amp;amp;t);\n        t += n;\n        n += *(int *)t;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201005124652.png\&#34; alt=\&#34;image-20201005124652055\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-7&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;C语言综合研究与高强度程序设计训练7&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-10-04 10:44:00&#34;,&#34;dateFormat&#34;:&#34;2020-10-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/c-yu-yan-zong-he-yan-jiu-yu-gao-qiang-du-cheng-xu-she-ji-xun-lian-7/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:66000,&#34;words&#34;:225,&#34;minutes&#34;:2},&#34;description&#34;:&#34;\n写一个程序，进行如下工作:\n（1）从内存偏移地址2000h处开始，读取偏移地址n处的整型数据d，按照如下格式打印\n偏移地址n数据d\n（2）将数据d当作新的偏移地址n，读取偏移地址n处的整型数据d按照上面的格式打印。直到偏移地址为xff为，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1\&#34;&gt;1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2\&#34;&gt;2&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;4\&#34;&gt;4&lt;/h1&gt;\n&lt;h2 id=\&#34;1\&#34;&gt;1&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;了解tlib如何生成list文件，查看list文件中是什么内容？&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过查看使用说明尝试生成list文件&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003183838.png\&#34; alt=\&#34;image-20201003183838110\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过生成的&lt;mark&gt;CSLISTFI.LST&lt;/mark&gt;可以看到文件中包含着标号，大小，但不知道标号是&lt;mark&gt;obj&lt;/mark&gt;文件的名称还是其中的函数名称故通过自己的 c 文件生成&lt;mark&gt;obj&lt;/mark&gt;然后加入&lt;mark&gt;cs.lib&lt;/mark&gt;中来进行验证&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;生成的list文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;Publics by module\n\nABS     \tsize = 16\n\t_abs                            \n\nABSREAD \tsize = 76\n\t_absread                          _abswrite\n\nACCESS  \tsize = 57\n\t_access                         \n\nALLOCMEM\tsize = 36\n\t_allocmem                       \n\nATEXIT  \tsize = 104\n\t__atexitcnt                       __atexittbl\n\t_atexit                         \n\nATOL    \tsize = 128\n    .............\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;test.c&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int t1(int a, int b) {\n    int c;\n    c = a + b;\n    return c;\n}\nint t2(int a, int b) {\n    int c;\n    c = a - b;\n    return c;\n}\nint t3(int a, int b) { return a + b + 1; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003185025.png\&#34; alt=\&#34;image-20201003185025478\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看 &lt;mark&gt;cslsitfile&lt;/mark&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;可以看到标号为obj文件的名称，大小的obj文件的大小，带下划线的为函数名&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003185310.png\&#34; alt=\&#34;image-20201003185310200\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2\&#34;&gt;2&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;使用tlib进行操作时，会进行检测。写程序测试是检测函数名、obj文件名，还是两个都检测？如果都检测，那先检测哪一个？&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;紧接着在添加完test.obj后重新写一个不一样的test.c生成obj并加入cs.lib可以看到添加失败可以看到如果obj名称一致尽管函数名不一致也会添加失败&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;不一样的test.c&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int f3(int a, int b) { return a + b + 1; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003190042.png\&#34; alt=\&#34;image-20201003190042310\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;然后将test.c的obj文件拷贝重命名然后在添加到cs.lib中，可以看到虽然obj文件名不一致tlib还检查函数名&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003200900.png\&#34; alt=\&#34;image-20201003200721444\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过以上可以看出tlib会对函数名和obg文件名进行检查，现在接着将原始的test.obj再加入cslib中tlib会提示obj文件名一致添加失败，所以tlib先检查obj文件名然后检查函数名&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003201631.png\&#34; alt=\&#34;image-20201003201631248\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;3\&#34;&gt;3&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;将同一个.obj文件放入cs.lib和maths.lib中，会从哪个中取该文件中的函数？&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;稍微修改一下test.c然后再生成obj加入maths.lib&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;test.c&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int t1(int a, int b) {\n+   int c = 9;\n    c = a + b;\n    return c;\n}\nint t2(int a, int b) {\n+    int c = 8;\n    c = a - b;\n    return c;\n}\nint t3(int a, int b) { return a + b + 1; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003202038.png\&#34; alt=\&#34;image-20201003202038759\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编写测试程序&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;main.c&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-CQL\&#34;&gt;main() {\n    int a = 1;\n    int b = 2;\n    int c;\n    c = t1(a, b);\n    printf(&amp;quot;c = %d&amp;quot;, c);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;debug查看生成的可执行文件&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;可以看出会从maths.lib中去函数&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201003202551.png\&#34; alt=\&#34;image-20201003202550847\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;1003_-zong-he-yan-jiu-4-5-bu-chong-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;1003_综合研究4-5补充研究报告&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-10-03 10:43:22&#34;,&#34;dateFormat&#34;:&#34;2020-10-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/1003_-zong-he-yan-jiu-4-5-bu-chong-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:145000,&#34;words&#34;:569,&#34;minutes&#34;:3},&#34;description&#34;:&#34;4\n1\n\n了解tlib如何生成list文件，查看list文件中是什么内容？\n\n\n\n通过查看使用说明尝试生成list文件\n\n\n\n\n\n通过生成的CSLISTFI.LST可以看到文件中包含着标号，大小，但不知道标号是obj文件的名称还是其中的函数...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#4\&#34;&gt;4&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1\&#34;&gt;1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2\&#34;&gt;2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3\&#34;&gt;3&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;1\&#34;&gt;1&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;（1）写一个C程序，打印int、long、 double型变量所占的字节数、地址、各个字节的地址和内容。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int ia = 6;\nlong la = 7;\ndouble da = 8;\nmain() {\n    int i;\n    printf(&amp;quot;int %d          ,address %lx,size %d\\n&amp;quot;, ia, (long)&amp;amp;ia,\n           sizeof(int));\n    for (i = 0; i &amp;lt; sizeof(int); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;ia + i);\n        printf(&amp;quot;value  %d &amp;quot;, *((&amp;amp;ia) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n\n    printf(&amp;quot;long %ld         ,address %lx,size %d\\n&amp;quot;, la, (long)&amp;amp;la,\n           sizeof(long));\n    for (i = 0; i &amp;lt; sizeof(long); ++i) {\n        if (i % 2 == 0)\n            printf(&amp;quot;\\n&amp;quot;);\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;la + i);\n        printf(&amp;quot;value  %ld &amp;quot;, *((&amp;amp;la) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;double %lf,address %lx,size %d\\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));\n    for (i = 0; i &amp;lt; sizeof(double); ++i) {\n        if (i % 2 == 0)\n            printf(&amp;quot;\\n&amp;quot;);\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);\n        printf(&amp;quot;value  %lf &amp;quot;, *((&amp;amp;da) + i));\n    }\n}int ia = 6;\nlong la = 7;\ndouble da = 8;\nmain() {\n    int i;\n    printf(&amp;quot;int %d          ,address %lx,size %d\\n&amp;quot;, ia, (long)&amp;amp;ia,\n           sizeof(int));\n    for (i = 0; i &amp;lt; sizeof(int); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;ia + i);\n        printf(&amp;quot;value  %d &amp;quot;, *((&amp;amp;ia) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n\n    printf(&amp;quot;long %ld         ,address %lx,size %d\\n&amp;quot;, la, (long)&amp;amp;la,\n           sizeof(long));\n    for (i = 0; i &amp;lt; sizeof(long); ++i) {\n        if (i % 2 == 0)\n            printf(&amp;quot;\\n&amp;quot;);\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;la + i);\n        printf(&amp;quot;value  %ld &amp;quot;, *((&amp;amp;la) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;double %lf,address %lx,size %d\\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));\n    for (i = 0; i &amp;lt; sizeof(double); ++i) {\n        if (i % 2 == 0)\n            printf(&amp;quot;\\n&amp;quot;);\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);\n        printf(&amp;quot;value  %lf &amp;quot;, *((&amp;amp;da) + i));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200930184753.png\&#34; alt=\&#34;image-20200930184753489\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修正&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int ia = 6;\nlong la = 7;\ndouble da = 8;\nmain() {\n    int i;\n    /*     printf(&amp;quot;%x %x %x %x\\n&amp;quot;, &amp;amp;ia, ((int)(&amp;amp;ia) + 1), (char *)((char)(&amp;amp;ia) +\n     *1), (char *)((char)(&amp;amp;ia) + 1)); */\n    printf(&amp;quot;int %d          ,address %lx,size %d\\n&amp;quot;, ia, (long)&amp;amp;ia,\n           sizeof(int));\n    for (i = 0; i &amp;lt; sizeof(int); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;ia + i);\n +       printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;ia) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n\n    printf(&amp;quot;long %ld         ,address %lx,size %d\\n&amp;quot;, la, (long)&amp;amp;la,\n           sizeof(long));\n    for (i = 0; i &amp;lt; sizeof(long); ++i) {\n        if (i % 2 == 0)\n            printf(&amp;quot;\\n&amp;quot;);\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;la + i);\n+        printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;la) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;double %lf,address %lx,size %d\\n&amp;quot;, da, (long)&amp;amp;da, sizeof(double));\n    for (i = 0; i &amp;lt; sizeof(double); ++i) {\n        if (i % 2 == 0)\n            printf(&amp;quot;\\n&amp;quot;);\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;da + i);\n+        printf(&amp;quot;value  %x &amp;quot;, *(char *)((int)(&amp;amp;da) + i));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007094453.png\&#34; alt=\&#34;image-20201007094453071\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2\&#34;&gt;2&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;（2）写一个C程序，打印stu型变量所占的字节数、地址、各数据项地址、内容和各个字节的内容。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;  typedef struct\n  {\n  int num；\n  unsigned char c；\n  unsigned char osi\n  unsigned char masm；\n  char name［20］\n  }stu；\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;提示:研究 sizeof的用法；可将任何一个变量的存储空间，看做一个数组。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;typedef struct {\n    int num;\n    unsigned char c;\n    unsigned char os;\n    unsigned char masm;\n    char name[20];\n} stu;\n\nmain() {\n    int i = 0;\n    stu s;\n    s.num = 9;\n    s.c = &#39;1&#39;;\n    s.os = &#39;2&#39;;\n    s.masm = &#39;3&#39;;\n    s.name[0] = &#39;L&#39;;\n    s.name[1] = &#39;i&#39;;\n    s.name[2] = &#39;L&#39;;\n    s.name[3] = &#39;\\0&#39;;\n\n    printf(&amp;quot;size: %d,address: %lx\\n&amp;quot;, sizeof(s), (long)&amp;amp;s);\n    printf(&amp;quot;num :    %d,address: %lx\\n&amp;quot;, s.num, (long)&amp;amp;(s.num));\n    for (i = 0; i &amp;lt; sizeof(int); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.num) + i);\n        printf(&amp;quot;value  %d &amp;quot;, *(&amp;amp;(s.num) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;c   :    %c,address: %lx\\n&amp;quot;, s.c, (long)&amp;amp;(s.c));\n    for (i = 0; i &amp;lt; sizeof(char); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.c) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *(&amp;amp;(s.c) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;os  :    %c,address: %lx\\n&amp;quot;, s.os, (long)&amp;amp;(s.os));\n    for (i = 0; i &amp;lt; sizeof(char); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.os) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *(&amp;amp;(s.os) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;masm:    %c,address: %lx\\n&amp;quot;, s.masm, (long)&amp;amp;(s.masm));\n    for (i = 0; i &amp;lt; sizeof(char); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.masm) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *(&amp;amp;(s.masm) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;name:  %s,address: %lx\\n&amp;quot;, s.name, (long)&amp;amp;(s.name));\n    /* printf(&amp;quot;%d&amp;quot;, sizeof(char *)); */\n    for (i = 0; i &amp;lt; 20; i++) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.name) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *((*(&amp;amp;s.name)) + i));\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200930193943.png\&#34; alt=\&#34;image-20200930193943568\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修正&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;b.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;typedef struct {\n    int num;\n    unsigned char c;\n    unsigned char os;\n    unsigned char masm;\n    char name[20];\n} stu;\n\nchar *cp;\n\nmain() {\n    int i = 0;\n    stu s;\n    s.num = 9;\n    s.c = &#39;1&#39;;\n    s.os = &#39;2&#39;;\n    s.masm = &#39;3&#39;;\n    s.name[0] = &#39;L&#39;;\n    s.name[1] = &#39;i&#39;;\n    s.name[2] = &#39;L&#39;;\n    s.name[3] = &#39;\\0&#39;;\n\n    printf(&amp;quot;size: %d,address: %lx\\n&amp;quot;, sizeof(s), (long)&amp;amp;s);\n    printf(&amp;quot;num :    %d,address: %lx\\n&amp;quot;, s.num, (long)&amp;amp;(s.num));\n    for (i = 0; i &amp;lt; sizeof(int); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.num) + i);\n        cp = (char *)((int)&amp;amp;(s.num) + i);\n        printf(&amp;quot;value  %d &amp;quot;, *cp);\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;c   :    %c,address: %lx\\n&amp;quot;, s.c, (long)&amp;amp;(s.c));\n    for (i = 0; i &amp;lt; sizeof(char); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.c) + i);\n        cp = (char *)((int)&amp;amp;(s.c) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *cp);\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;os  :    %c,address: %lx\\n&amp;quot;, s.os, (long)&amp;amp;(s.os));\n    for (i = 0; i &amp;lt; sizeof(char); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.os) + i);\n        cp = (char *)((int)&amp;amp;(s.os) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *cp);\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;masm:    %c,address: %lx\\n&amp;quot;, s.masm, (long)&amp;amp;(s.masm));\n    for (i = 0; i &amp;lt; sizeof(char); ++i) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.masm) + i);\n        cp = (char *)((int)&amp;amp;(s.masm) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *cp);\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n    printf(&amp;quot;name:  %s,address: %lx\\n&amp;quot;, s.name, (long)&amp;amp;(s.name));\n    /* printf(&amp;quot;%d&amp;quot;, sizeof(char *)); */\n    for (i = 0; i &amp;lt; 20; i++) {\n        printf(&amp;quot;address  %lx &amp;quot;, (long)&amp;amp;(s.name) + i);\n        cp = (char *)((int)&amp;amp;(s.name) + i);\n        printf(&amp;quot;value  %c &amp;quot;, *cp);\n    }\n    printf(&amp;quot;\\n&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007095106.png\&#34; alt=\&#34;image-20201007095106825\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;3\&#34;&gt;3&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;（3）写一个程序，这个程序的运行结果反映如下主题参数的存储空间与局部变量的存储空间，在函数运行后收回。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;long *f(int a);\nlong res[2];\nlong p;\nlong l;\nmain() {\n    long *a = f(5);\n    p = a[0];\n    l = a[1];\n\n    printf(&amp;quot;parm  %d ,address %lx\\n&amp;quot;, *(long *)a[0], p);\n    printf(&amp;quot;local %d ,address %lx\\n&amp;quot;, *(long *)a[1], l);\n}\n\nlong *f(int parm) {\n    int local = 1;\n    local += parm;\n    printf(&amp;quot;parm  %d address %lx\\n&amp;quot;, parm, (long)&amp;amp;parm);\n    printf(&amp;quot;local %d address %lx\\n&amp;quot;, local, (long)&amp;amp;local);\n\n    res[0] = (long)&amp;amp;parm;\n    res[1] = (long)&amp;amp;local;\n\n    /*     printf(&amp;quot;parm %d ,address %lx\\n&amp;quot;, *(long *)res[0], res[0]);\n        printf(&amp;quot;parm %d ,address %lx\\n&amp;quot;, *(long *)res[1], res[1]); */\n    return res;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200930213929.png\&#34; alt=\&#34;image-20200930213929300\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修正&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;c.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;long *f(int a);\nlong res[2];\n\nmain() {\n    f(5);\n    printf(&amp;quot;============\\n&amp;quot;);\n    f(8);\n}\n\nlong *f(int parm) {\n    int local = 1;\n    local += parm;\n\n    printf(&amp;quot;parm  %d address %lx\\n&amp;quot;, parm, (long)&amp;amp;parm);\n    printf(&amp;quot;local %d address %lx\\n&amp;quot;, local, (long)&amp;amp;local);\n\n    return res;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20201007095242.png\&#34; alt=\&#34;image-20201007095242216\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;02020930_-zong-he-yan-jiu-6-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;02020930_综合研究6研究报告&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-09-30 10:42:07&#34;,&#34;dateFormat&#34;:&#34;2020-09-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/02020930_-zong-he-yan-jiu-6-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:525000,&#34;words&#34;:1472,&#34;minutes&#34;:9},&#34;description&#34;:&#34;1\n\n（1）写一个C程序，打印int、long、 double型变量所占的字节数、地址、各个字节的地址和内容。\n\nint ia = 6;\nlong la = 7;\ndouble da = 8;\nmain() {\n    int i;\n   ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1\&#34;&gt;1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2\&#34;&gt;2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3\&#34;&gt;3&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;用&lt;mark&gt;debug&lt;/mark&gt; 对一下程序进行分析，记录每一条c语句运行后，相关内存单元的值&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;ac\&#34;&gt;a.c&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;注意理解指针的机制，“**” 和 “&amp;amp;” 运算的意义&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;char ch;\nchar *p;\nchar **pa;\nchar far *pf;\nint n;\n\nmain() {\n    p = (unsigned char *)0x1000;\n    ch = *(unsigned char *)0x1000 + *p + *(unsigned char far *)0x200;\n\n    p = &amp;amp;ch;\n\n    *p = *p + 1;\n\n    pa = &amp;amp;p;\n    **pa = **pa + 1;\n\n    pf = (char far *)&amp;amp;ch;\n    *pf = *pf + 1;\n\n    n = (int)&amp;amp;ch;\n    *(char *)n = *(char *)n + 1;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;第一句 &lt;code&gt;p = (unsigned char *)0x1000;&lt;/code&gt;p在数据段中偏移地址为&lt;mark&gt;01af&lt;/mark&gt;然后看内存中的值&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*mov\tword ptr DGROUP:_p,4096*/\n    p = (unsigned char *)0x1000;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114715.png\&#34; alt=\&#34;image-20200929114715440\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114758.png\&#34; alt=\&#34;image-20200929114758733\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第二句 &lt;code&gt;ch = *(unsigned char *)0x1000 + *p + *(unsigned char far *)0x200;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*\n        mov\tal,byte ptr [4096]\n        mov\tbx,word ptr DGROUP:_p\n        add\tal,byte ptr [bx]\n        xor\tbx,bx\n        mov\tes,bx\n        mov\tbx,512\n        add\tal,byte ptr es:[bx]\n        mov\tbyte ptr DGROUP:_ch,al\n    */\n    ch = *(unsigned char *)0x1000 + *p + *(unsigned char far *)0x200;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114830.png\&#34; alt=\&#34;image-20200929114830832\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929114933.png\&#34; alt=\&#34;image-20200929114933614\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第三句 &lt;code&gt;p = &amp;amp;ch;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*                      [01af]            01a8*/\n    /*mov\tword ptr DGROUP:_p,offset DGROUP:_ch*/\n    p = &amp;amp;ch;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115117.png\&#34; alt=\&#34;image-20200929115116923\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第四句 &lt;code&gt;*p = *p + 1;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*\n        mov\tbx,word ptr DGROUP:_p\n        mov\tal,byte ptr [bx]\n        inc\tal\n        mov\tbx,word ptr DGROUP:_p\n        mov\tbyte ptr [bx],al\n    */\n    *p = *p + 1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115201.png\&#34; alt=\&#34;image-20200929115201697\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到p指向的内存中的值增加一&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115239.png\&#34; alt=\&#34;image-20200929115238797\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第五句 &lt;code&gt;pa = &amp;amp;p;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*                ds:[01a6]         01af\n    mov\tword ptr DGROUP:_pa,offset DGROUP:_p\n    */\n    pa = &amp;amp;p;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115547.png\&#34; alt=\&#34;image-20200929115547139\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第六句 &lt;code&gt;**pa = **pa + 1;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*\n        mov\tbx,word ptr DGROUP:_pa\n        mov\tbx,word ptr [bx]\n        mov\tal,byte ptr [bx]\n        inc\tal\n        mov\tbx,word ptr DGROUP:_pa\n        mov\tbx,word ptr [bx] bx=01a6\n        mov\tbyte ptr [bx],al\n    */\n    **pa = **pa + 1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115644.png\&#34; alt=\&#34;image-20200929115644803\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到p指向的内存中的值增加一&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115712.png\&#34; alt=\&#34;image-20200929115711875\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第七句 &lt;code&gt;pf = (**char** far *)&amp;amp;ch;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*                  01ad\n        mov\tword ptr DGROUP:_pf+2,ds\n                        [01a8]              01a8\n        mov\tword ptr DGROUP:_pf,offset DGROUP:_ch\n    */\n    pf = (char far *)&amp;amp;ch;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929115906.png\&#34; alt=\&#34;image-20200929115906423\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到pf存在的是&lt;mark&gt;ch&lt;/mark&gt;的地址&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120128.png\&#34; alt=\&#34;image-20200929120128258\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第八句 &lt;code&gt;*pf = *pf + 1;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*\n        les\tbx,dword ptr DGROUP:_pf\n        mov\tal,byte ptr es:[bx]\n        inc\tal\n        les\tbx,dword ptr DGROUP:_pf\n        mov\tbyte ptr es:[bx],al\n    */\n    *pf = *pf + 1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;13\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120436.png\&#34; alt=\&#34;image-20200929120436617\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到p指向的内存中的值增加一&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;14\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120344.png\&#34; alt=\&#34;image-20200929120344832\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第九句 &lt;code&gt;n = (**int**)&amp;amp;ch;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*                      01a8\n        mov\tax,offset DGROUP:_ch\n                        01a9\n        mov\tword ptr DGROUP:_n,ax\n    */\n    n = (int)&amp;amp;ch;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;15\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120603.png\&#34; alt=\&#34;image-20200929120603717\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;16\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120647.png\&#34; alt=\&#34;image-20200929120647507\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第十句 &lt;code&gt;*(**char** *)n = *(**char** *)n + 1;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    /*\n        mov\tbx,word ptr DGROUP:_n\n        mov\tal,byte ptr [bx]\n        inc\tal\n        mov\tbx,word ptr DGROUP:_n\n        mov\tbyte ptr [bx],al\n    */\n    *(char *)n = *(char *)n + 1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;17\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120716.png\&#34; alt=\&#34;image-20200929120716356\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;18\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929120800.png\&#34; alt=\&#34;image-20200929120800531\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;综上可以看出&lt;code&gt;*p&lt;/code&gt;的功能是取出以&lt;code&gt;p&lt;/code&gt;中数据作为偏移地址的内存中的值，&lt;code&gt;&amp;amp;p&lt;/code&gt;的功能就是取出&lt;code&gt;p&lt;/code&gt;的偏移地址&lt;/p&gt;\n&lt;h2 id=\&#34;bc\&#34;&gt;b.c&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;注意理解 struct指针的用法，指针“＋”运算的意义。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;typedef struct {\n    int number;\n    char c;\n    char name[8];\n} stu;\n\nstu a;\n\nchar *pchar;\nint *pint;\nstu *pstu;\n\nmain() {\n    pstu = &amp;amp;a;\n\n    pstu-&amp;gt;number = 1;\n    (*pstu).c = 80;\n    pstu-&amp;gt;name[0] = &#39;T&#39;;\n    pstu-&amp;gt;name[1] = &#39;o&#39;;\n    (*pstu).name[2] = &#39;m&#39;;\n    (*pstu).name[3] = &#39;0&#39;;\n\n    pchar = 0;\n    pint = 0;\n    pstu = 0;\n\n    pchar = pchar + 1;\n    pint = pint + 1;\n    pstu = pstu + 1;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过汇编代码可以得出不论是指针的&lt;code&gt;-&amp;gt;&lt;/code&gt; 运算和&lt;code&gt;.&lt;/code&gt; 运算最后翻译成的汇编都是把&lt;code&gt;stu&lt;/code&gt; 的首地址传给&lt;code&gt;bx&lt;/code&gt;然后通过&lt;code&gt;bx&lt;/code&gt;加上偏移来访问结构体变量的真正内存地址&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;19\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929111437.png\&#34; alt=\&#34;image-20200929111437771\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;20\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929111851.png\&#34; alt=\&#34;image-20200929111851178\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;字符型指针加一就把指针内存中的数据增加一，整形指针加一就把指针内存中的数据增加二，结构体指针加一就是把指针内存中的数据增加结构体中各个变量长度总和。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;21\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929112528.png\&#34; alt=\&#34;image-20200929112528048\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;cc\&#34;&gt;c.c&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;将字符串“hello world！”分别拷贝到从0:200、:210起始的内存中:将数组a分别拷贝到0:220、0:230起始的内存中。&lt;/p&gt;\n&lt;p&gt;注意理解“［］”运算的意义及数组名与指针的关系。&lt;/p&gt;\n&lt;p&gt;假设p是一个指针，p［n］的意义等同于＊（p＋n）&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;char *p;\nchar far *pf;\nchar str[20] = &amp;quot;hello world!&amp;quot;;\nint a[8] = {11, 22, 33, 44, 55, 66, 77, 88};\nint n;\n\nmain() {\n    pf = (char far *)0x200;\n    for (n = 0; str[n]; n++)\n        *(pf + n) = str[n];\n\n    p = str;\n    pf = (char far *)0x210;\n    for (n = 0; p[n]; n++)\n        pf[n] = *(str + n);\n\n    for (n = 0; n &amp;lt; 8; n++)\n        ((int far *)0x220)[n] = *(a + n);\n    for (n = 0; n &amp;lt; 8; n++)\n        *(int far *)(0x230 + n * 2) = *(&amp;amp;a[0] + n);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;1&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\n\tmov\tword ptr DGROUP:_pf+2,0\n\tmov\tword ptr DGROUP:_pf,512\n*/\npf = (char far *)0x200;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;22\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929122947.png\&#34; alt=\&#34;image-20200929122947409\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;2&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\n;\t?debug\tL 9\t\t[01ca]\n\tmov\tword ptr DGROUP:_n,0\n\tjmp\tshort @5\n@4:\n;\t?debug\tL 10\n\tmov\tbx,word ptr DGROUP:_n ;[01ca]\n\tmov\tal,byte ptr DGROUP:_str[bx] ;[bx+0194]\n\tles\tbx,dword ptr DGROUP:_pf\n\tadd\tbx,word ptr DGROUP:_n\n\tmov\tbyte ptr es:[bx],al\n@3:\n\tinc\tword ptr DGROUP:_n\n@5:\t\t\t\t\t[01ca]\n\tmov\tbx,word ptr DGROUP:_n\n\tcmp\tbyte ptr DGROUP:_str[bx],0\n\tjne\t@4\n*/\nfor (n = 0; str[n]; n++)\n\t*(pf + n) = str[n];\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;初始化后&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;23\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123634.png\&#34; alt=\&#34;image-20200929123634814\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;3&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\t\t\t\t\t01d0\t\t\t\t0194\n\tmov\tword ptr DGROUP:_p,offset DGROUP:_str\n*/\np = str;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;24\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123821.png\&#34; alt=\&#34;image-20200929123821356\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;25\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123859.png\&#34; alt=\&#34;image-20200929123859645\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;4&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\n\tmov\tword ptr DGROUP:_pf+2,0\n\tmov\tword ptr DGROUP:_pf,528\n*/\n\npf = (char far *)0x210;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;26\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123930.png\&#34; alt=\&#34;image-20200929123929928\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;27\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929123957.png\&#34; alt=\&#34;image-20200929123957303\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;5&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\n;\t?debug\tL 14\n\tmov\tword ptr DGROUP:_n,0\n\tjmp\tshort @9\n@8:\n;\t?debug\tL 15\n\tmov\tbx,word ptr DGROUP:_n\n\tmov\tal,byte ptr DGROUP:_str[bx]\n\tles\tbx,dword ptr DGROUP:_pf\n\tadd\tbx,word ptr DGROUP:_n\n\tmov\tbyte ptr es:[bx],al\n@7:\n\tinc\tword ptr DGROUP:_n\n@9:\n\tmov\tbx,word ptr DGROUP:_p\n\tadd\tbx,word ptr DGROUP:_n\n\tcmp\tbyte ptr [bx],0\n\tjne\t@8\n*/\nfor (n = 0; p[n]; n++)\n        pf[n] = *(str + n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;拷贝hello world从0:200 -&amp;gt; 0:210&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;28\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929124213.png\&#34; alt=\&#34;image-20200929124213070\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;6&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\n@6:\n;\t?debug\tL 17\n\tmov\tword ptr DGROUP:_n,0\n\tjmp\tshort @13\n@12:\n;\t?debug\tL 18\n\tmov\tbx,word ptr DGROUP:_n\n\tshl\tbx,1\n\tmov\tax,word ptr DGROUP:_a[bx]\n\tmov\tdx,word ptr DGROUP:_n\n\tshl\tdx,1\n\txor\tbx,bx\n\tmov\tes,bx\n\tmov\tbx,544\n\tadd\tbx,dx\n\tmov\tword ptr es:[bx],ax\n@11:\n\tinc\tword ptr DGROUP:_n\n@13:\n\tcmp\tword ptr DGROUP:_n,8\n\tjl\t@12\n*/\nfor (n = 0; n &amp;lt; 8; n++)\n        ((int far *)0x220)[n] = *(a + n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;初始化&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;29\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929124433.png\&#34; alt=\&#34;image-20200929124433711\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;7&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\n@10:\n;\t?debug\tL 19\n\tmov\tword ptr DGROUP:_n,0\n\tjmp\tshort @17\n@16:\n;\t?debug\tL 20\n\tmov\tbx,word ptr DGROUP:_n\n\tshl\tbx,1\n\tmov\tax,word ptr DGROUP:_a[bx]\n\tpush\tax\n\tmov\tax,word ptr DGROUP:_n\n\tshl\tax,1\n\tadd\tax,560\n\tcwd\t\n\tmov\tbx,ax\n\tmov\tes,dx\n\tpop\tax\n\tmov\tword ptr es:[bx],ax\n@15:\n\tinc\tword ptr DGROUP:_n\n@17:\n\tcmp\tword ptr DGROUP:_n,8\n\tjl\t@16\n*/\nfor (n = 0; n &amp;lt; 8; n++)\n        *(int far *)(0x230 + n * 2) = *(&amp;amp;a[0] + n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;拷贝a从0:220-&amp;gt;0:230&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;30\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200929124530.png\&#34; alt=\&#34;image-20200929124530273\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;综上&lt;code&gt;p[n]&lt;/code&gt;的意思是访问以&lt;code&gt;p&lt;/code&gt;为基地址&lt;code&gt;n&lt;/code&gt;为偏移地址中的数据，数组名&lt;code&gt;p&lt;/code&gt;和指针&lt;code&gt;*p&lt;/code&gt;存储的都是数据的起始地址&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;0929_-zong-he-yan-jiu-5-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;0929_综合研究5研究报告&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-09-29 10:41:07&#34;,&#34;dateFormat&#34;:&#34;2020-09-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/0929_-zong-he-yan-jiu-5-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:443000,&#34;words&#34;:1392,&#34;minutes&#34;:8},&#34;description&#34;:&#34;\n用debug 对一下程序进行分析，记录每一条c语句运行后，相关内存单元的值\n\na.c\n\n注意理解指针的机制，“**” 和 “&amp;amp;” 运算的意义\n\nchar ch;\nchar *p;\nchar **pa;\nchar far *pf;\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac\&#34;&gt;a.c&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bc\&#34;&gt;b.c&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cc\&#34;&gt;c.c&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;综合研究2\&#34;&gt;综合研究2&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;通过函数名直接打印出段地址和偏移地址（不使用_CS）&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;通过查阅相关资料可以尝试把函数名前强制转换成长整型&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int a;\nvoid f1(void) { a = 1; }\nvoid f2(void) { a = 2; }\nvoid f3(void) { a = 3; }\nmain() {\n    char *string = &amp;quot;--------------------&amp;quot;;\n    printf(&amp;quot;\\nCS: %x\\n&amp;quot;, _CS);\n    printf(&amp;quot;%s&amp;quot;, string);\n    printf(&amp;quot;\\nf1: %lx\\n&amp;quot;, (long)f1);\n    printf(&amp;quot;\\nf2: %lx\\n&amp;quot;, (long)f2);\n    printf(&amp;quot;\\nf3: %lx\\n&amp;quot;, (long)f3);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928070215.png\&#34; alt=\&#34;image-20200928070215176\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过&lt;code&gt;cs&lt;/code&gt;输出的数字可以检验出 强制转换可以正确输出函数对应的段地址和偏移地址。&lt;/p&gt;\n&lt;h2 id=\&#34;综合研究3\&#34;&gt;综合研究3&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;写程序验证全局变量存储空间是加载时分配，还是c0s分配。\t@未解决&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;编写测试程序&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int b = 9;\nmain() {\n    static int a = 8;\n    a++;\n    b++;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编译链接生成可执行程序通过debug查看变量在数据段的偏移地址&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928071005.png\&#34; alt=\&#34;image-20200928071005129\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可以看见存储全局变量的段地址和偏移地址，然后在重新debug后直接跳转到相应的位置查看&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928071303.png\&#34; alt=\&#34;image-20200928071303637\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可以推断全局变量是在程序加载时给全局变量分配空间&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;程序5首先要找到每条C语句对应的汇编代码，然后单步跟踪，跟踪时要将栈中的情况都画出来（这部分自己纸上画就可以，不必体现在研究报告中，但是必须通过这个过程去完全理解程序）。跟踪一遍后，回答教材中的两个问题。\t@未解决&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;LEA 取有效地址指令&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928074812.png\&#34; alt=\&#34;image-20200928074812709\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;程序的汇编代码&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075257.png\&#34; alt=\&#34;image-20200928075256961\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075321.png\&#34; alt=\&#34;image-20200928075320888\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075558.png\&#34; alt=\&#34;image-20200928075558794\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;执行 &lt;code&gt;call 266&lt;/code&gt;可以看到把结构体的数据的首地址偏移地址和要返回结果的段地址的偏移地址存储到栈中然后调用 &lt;code&gt;call 076a:13ea&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928082337.png\&#34; alt=\&#34;image-20200928082337791\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928075810.png\&#34; alt=\&#34;image-20200928075810572\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;call 076a:13ea&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928083602.png\&#34; alt=\&#34;image-20200928083601974\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928080105.png\&#34; alt=\&#34;image-20200928080104918\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;执行到&lt;code&gt;076a:13f0 c57606&lt;/code&gt;可以看到传入栈中的结构体数据的源地址和要返回结果的目的地址&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928082824.png\&#34; alt=\&#34;image-20200928082824733\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;执行到&lt;code&gt;adc cx,cx&lt;/code&gt;前后查看目的地址中的数据可以发现数据已经由源地址传送到目的地址&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;13\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928083959.png\&#34; alt=\&#34;image-20200928083959039\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;从函数返回的结构体数据类型存储在数据段中，在函数中先把返回结果的段地址和偏移地址压入栈中然后把结构体的段地址和偏移地址压入栈中，接着调用子程序（参数就是两个偏移地址）把栈中的数据移动到目标地址的内存中，子程序完成返回目标地址的偏移地址。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;执行到&lt;code&gt;call 076a:1406&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;可以看到&lt;code&gt;dx:ax&lt;/code&gt;为 &lt;code&gt;076a:1406&lt;/code&gt;的参数&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;14\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928090026.png\&#34; alt=\&#34;image-20200928090026334\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;子程序 &lt;code&gt;076a:1460&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;15\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928091101.png\&#34; alt=\&#34;image-20200928091101628\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;16\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928090256.png\&#34; alt=\&#34;image-20200928090256790\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;可以看到此程序的功能是把结构体数据复制到目的地址&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928091139.png\&#34; alt=\&#34;image-20200928091139256\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;执行 &lt;code&gt;call 0256&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;17\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928091532.png\&#34; alt=\&#34;image-20200928091531970\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到子程序通过栈来使用传过来的结构体数据&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;18\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200928092331.png\&#34; alt=\&#34;image-20200928092331592\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;向函数传递结构体数据&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;通过调用子程序来把结构体数据复制到栈中&lt;/li&gt;\n&lt;li&gt;然后函数在通过栈来使用结构体数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;0928_-zong-he-yan-jiu-1-3-bu-chong-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;0928_综合研究1-3补充研究报告&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-09-28 10:39:51&#34;,&#34;dateFormat&#34;:&#34;2020-09-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/0928_-zong-he-yan-jiu-1-3-bu-chong-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:167000,&#34;words&#34;:748,&#34;minutes&#34;:3},&#34;description&#34;:&#34;综合研究2\n\n通过函数名直接打印出段地址和偏移地址（不使用_CS）\n\n通过查阅相关资料可以尝试把函数名前强制转换成长整型\nint a;\nvoid f1(void) { a = 1; }\nvoid f2(void) { a = 2; }\nvo...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B62\&#34;&gt;综合研究2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B63\&#34;&gt;综合研究3&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;摘要\&#34;&gt;摘要&lt;/h2&gt;\n&lt;p&gt;源程序文件（.c文件）需要进行编译、连接两步工作后生成&lt;code&gt;exe&lt;/code&gt;文件在前面的内容中，&lt;br&gt;\n这两步工作是集成在一起完成的。&lt;/p&gt;\n&lt;p&gt;多个&lt;code&gt;obj&lt;/code&gt;文件中的代码可以存储在一个&lt;code&gt;lib&lt;/code&gt;文件中，对于&lt;code&gt;tc2.0&lt;/code&gt;开发环境，一个&lt;code&gt;exe&lt;/code&gt;文件&lt;br&gt;\n中可能包含了来自多个&lt;code&gt;obj&lt;/code&gt;文件和&lt;code&gt;lib&lt;/code&gt;文件中的代码。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;cs.lib emu.lib maths.lib&lt;/code&gt;等&lt;code&gt;lib&lt;/code&gt;文件中存储着C语言库函数的代码，比如 &lt;code&gt;printf&lt;/code&gt;、 &lt;code&gt;getch&lt;/code&gt;等等C语言提供的库函数都在&lt;code&gt;cs.lib&lt;/code&gt;中存储。&lt;br&gt;\n我们用形如&lt;code&gt;tcc a.c&lt;/code&gt;的方法对程序进行编译连接，使用的是&lt;code&gt;tc2.0&lt;/code&gt;设计的一套固定的&lt;br&gt;\n生成&lt;code&gt;exe&lt;/code&gt;文件的方案。这套设计好的方案的具体步骤如下:&lt;br&gt;\n（1）&lt;code&gt;tcc&lt;/code&gt;将源程序文件编译为&lt;code&gt;a.obj&lt;/code&gt;&lt;br&gt;\n（2）&lt;code&gt;tcc&lt;/code&gt;调用 &lt;code&gt;tlink&lt;/code&gt;将&lt;code&gt;c0s.obj、cs.lib、emu.lib maths.lib&lt;/code&gt;中的&lt;code&gt;a.obj&lt;/code&gt;中的程序要用到的代码&lt;br&gt;\n与&lt;code&gt;a.obj&lt;/code&gt;的代码连接到一起生成&lt;code&gt;exe&lt;/code&gt;文件。&lt;/p&gt;\n&lt;p&gt;而来自&lt;code&gt;c0s.obj&lt;/code&gt;中的代码被连接到其他代码的前面。&lt;code&gt;c0s.obj&lt;/code&gt;中的代码所做的工作是:进&lt;br&gt;\n行相关的初始化工作、调用名称为“&lt;code&gt;main&lt;/code&gt;”的函数、其他工作。&lt;/p&gt;\n&lt;p&gt;因为&lt;code&gt;c0s.obj&lt;/code&gt;的代码被连接到其他代码前面，则&lt;code&gt;exe&lt;/code&gt;文件运行的时候首先运行来自 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;br&gt;\n中的代码，进行相关的初始化工作，然后调用&lt;code&gt;main&lt;/code&gt;函数，从此开始运行程序员写的程序。&lt;/p&gt;\n&lt;p&gt;我们可以看出，这套工作方案落实了C语言的“用户程序必须从&lt;code&gt;main&lt;/code&gt;函数开始”的规则。&lt;/p&gt;\n&lt;h2 id=\&#34;问题研究\&#34;&gt;问题研究&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;用&lt;code&gt;tcc&lt;/code&gt;将下面的程序编译为&lt;code&gt;obj&lt;/code&gt;文件。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int f(void) { return 1; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926112859.png\&#34; alt=\&#34;image-20200926112859041\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过查看&lt;code&gt;tcc&lt;/code&gt;的使用方式可以看到 &lt;code&gt;-c&lt;/code&gt;为生成&lt;code&gt;obj&lt;/code&gt;文件的参数&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926113040.png\&#34; alt=\&#34;image-20200926113040248\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;用 &lt;code&gt;tcc&lt;/code&gt;的方法编译连接下面的程序。注意显示出来的信息。这些信息说明了什么？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;main() { f(); }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过编译链接，显示出来没有&lt;code&gt;f&lt;/code&gt;的定义，说明&lt;code&gt;tlink&lt;/code&gt;链接时仅仅链接 &lt;code&gt;c0s.obj、cs.lib、emu.lib maths.lib&lt;/code&gt;其余的用户自定义的不会被自动链接。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926113259.png\&#34; alt=\&#34;image-20200926113259807\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;tc2.0&lt;/code&gt;提供一个工具&lt;code&gt;tlib.exe&lt;/code&gt;，可以用&lt;code&gt;tib.exe&lt;/code&gt;将一个&lt;code&gt;obj&lt;/code&gt;文件中的代码加到一个lib文&lt;br&gt;\n件中。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;找到tlib.exe，研究它的使用方法，将（1）中生成的&lt;code&gt;obj&lt;/code&gt;文件加入到&lt;code&gt;csib&lt;/code&gt;中&lt;br&gt;\n注意:我们要对一个对象（&lt;code&gt;cs.lib&lt;/code&gt;）进行正确的改动，但是种正确的改动不一定一次成功&lt;br&gt;\n所以，在改动之前，我们可以将原来的对象保存一份，以便恢复。&lt;br&gt;\n上面的工作成功后，用&lt;code&gt;tcc a.c&lt;/code&gt;的方法将程序c编译连接为&lt;code&gt;a.exe&lt;/code&gt;文件用 &lt;code&gt;debug&lt;/code&gt;&lt;br&gt;\n加载&lt;code&gt;a.exe&lt;/code&gt;文件，找到&lt;code&gt;main&lt;/code&gt;函数和f函数的代码。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;:&lt;code&gt;a.c&lt;/code&gt;中并没有写函数&lt;code&gt;f&lt;/code&gt;，&lt;code&gt;a exe&lt;/code&gt;中的函数&lt;code&gt;f&lt;/code&gt;的代码是在什么时候加入的？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过观察&lt;code&gt;tlib.exe&lt;/code&gt;的使用方式后把&lt;code&gt;f.obj&lt;/code&gt;添加到&lt;code&gt;cs.lib&lt;/code&gt;中（提前备份以防止失败）后编译链接&lt;code&gt;a.c&lt;/code&gt;生成可执行文件&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926114704.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;可以看到链接过程没有报错。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过&lt;code&gt;debug&lt;/code&gt;来观察&lt;code&gt;a.exe&lt;/code&gt;可以看到程序开始后调用子程序然后我们开始转到子程序观察发现子程序为&lt;code&gt;f&lt;/code&gt;。&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926115332.png\&#34; alt=\&#34;image-20200926115332535\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926115407.png\&#34; alt=\&#34;image-20200926115407734\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在问题2中在链接的时候报错而修改完&lt;code&gt;cs.lib&lt;/code&gt;后在进行编译链接正常故&lt;code&gt;f&lt;/code&gt;中的代码是在链接的时候加入到&lt;code&gt;a.exe&lt;/code&gt;中的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;程序b.c中并没有写f、f2和 printf函数，bexe中这些函数的代码是什么时候加&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;将下面的程序编译为&lt;code&gt;f.obj&lt;/code&gt;，将&lt;code&gt;f.obj&lt;/code&gt;加入&lt;code&gt;cs.lib&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;mark&gt;程序&lt;code&gt;f.c&lt;/code&gt;&lt;/mark&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int f1(int a, int b) {\n    int c;\n    c = a + b;\n    return c;\n}\nint f2(int a, int b) {\n    int c;\n    c = a - b;\n    return c;\n}\nint f3(int a, int b) { return a + b + 1; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过 &lt;code&gt;tcc.exe，tlib.exe&lt;/code&gt;将生成后&lt;code&gt;obj&lt;/code&gt;文件添加到&lt;code&gt;cs.lib&lt;/code&gt;中&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926120657.png\&#34; alt=\&#34;image-20200926120657685\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;将下面的程序编译连接为&lt;code&gt;b.exe&lt;/code&gt;用 &lt;code&gt;debug&lt;/code&gt;加载&lt;code&gt;b.exe&lt;/code&gt;，找到其中所有函数代码。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;mark&gt;程序&lt;code&gt;b.c&lt;/code&gt;&lt;/mark&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int func(int, int);\n\nint a, b;\n\nmain() {\n    a = f1(1, 2);\n    b = f2(20, 10);\n    a = func(a, b);\n    printf(&amp;quot;%d\\n&amp;quot;, a);\n}\n\nint func(int a, int b) { return a * b; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过&lt;code&gt;tcc&lt;/code&gt;编译链接生成&lt;code&gt;b.exe&lt;/code&gt;可以找到函数代码&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926121609.png\&#34; alt=\&#34;image-20200926121609202\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926121743.png\&#34; alt=\&#34;image-20200926121743017\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926122007.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926122127.png\&#34; alt=\&#34;image-20200926122126913\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;b.exe&lt;/code&gt;中的函数代码是链接时加入的，并且其中包含&lt;code&gt;f3&lt;/code&gt;的代码紧紧跟在&lt;code&gt;f2&lt;/code&gt;的后面，猜测加入代码是通过&lt;code&gt;obj&lt;/code&gt;为单位进行添加的&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926122844.png\&#34; alt=\&#34;image-20200926122844432\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;现在尝试将&lt;code&gt;f.c&lt;/code&gt;中的三个函数分成三份然后逐步添加到&lt;code&gt;cs.lib&lt;/code&gt;中。&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926125312.png\&#34; alt=\&#34;image-20200926125312063\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;可以看到&lt;code&gt;f2&lt;/code&gt;后面就没有&lt;code&gt;f3&lt;/code&gt;的代码了&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;用&lt;code&gt;tlib&lt;/code&gt;将&lt;code&gt;cs.lib&lt;/code&gt;中 &lt;code&gt;printf&lt;/code&gt;函数的代码变为下面的程序的代码:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;printf() { puts(&amp;quot;Do you want to use printf? No printf here.&amp;quot;); }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使得调用 &lt;code&gt;printf&lt;/code&gt;的用户程序，比如:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;main() {\n    int a, b;\n    a = 1;\n    b = 2;\n    printf(&amp;quot;%d\\n&amp;quot;, a + b);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在用&lt;code&gt;tcc&lt;/code&gt;编译连接后，运行时打印出&lt;code&gt;Do you want to use printf No printf here&lt;/code&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;将&lt;code&gt;printf&lt;/code&gt;从&lt;code&gt;cs.lib&lt;/code&gt;中移除&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926125903.png\&#34; alt=\&#34;image-20200926125903019\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;将&lt;code&gt;printf&lt;/code&gt;生成新的&lt;code&gt;obj&lt;/code&gt;文件后加入&lt;code&gt;cs.lib&lt;/code&gt;中&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926130513.png\&#34; alt=\&#34;image-20200926130513072\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;编译链接运行&lt;code&gt;main.c&lt;/code&gt;可以看到结果&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200926130600.png\&#34; alt=\&#34;image-20200926130600602\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;0926_-zong-he-yan-jiu-4-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;0926_综合研究4研究报告&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;C&#34;,&#34;slug&#34;:&#34;f9uwaThCs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/f9uwaThCs/&#34;}],&#34;date&#34;:&#34;2020-09-26 13:22:47&#34;,&#34;dateFormat&#34;:&#34;2020-09-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/0926_-zong-he-yan-jiu-4-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:297000,&#34;words&#34;:1262,&#34;minutes&#34;:5},&#34;description&#34;:&#34;摘要\n源程序文件（.c文件）需要进行编译、连接两步工作后生成exe文件在前面的内容中，\n这两步工作是集成在一起完成的。\n多个obj文件中的代码可以存储在一个lib文件中，对于tc2.0开发环境，一个exe文件\n中可能包含了来自多个obj文件...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%91%98%E8%A6%81\&#34;&gt;摘要&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6\&#34;&gt;问题研究&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;研究1\&#34;&gt;研究1&lt;/h2&gt;\n&lt;h3 id=\&#34;摘要\&#34;&gt;摘要&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;用&lt;code&gt;debug&lt;/code&gt;对一下程序编译链接后的代码进行研究&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;unsigned int n;\nvoid f1();\nint f2(int, int);\nvoid far f3();\n\nmain() {\n    n = 0;\n    f1();\n    n = f2(1, 2);\n    f3();\n}\n\nvoid f1() {\n    n = 1;\n}\nint f2(int a, int b) {\n    int c;\n    c = a + b;\n    return c;\n}\n\nvoid far f3() {\n    n = 10;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;问题\&#34;&gt;问题&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;程序运行时n、a、b、c的段地在哪个存器中？&lt;/li&gt;\n&lt;li&gt;全局变量的存空间在什么段里？局都量的储空间在什么段里？参数的存储空间在什么段里？函数的返回在什么地方？&lt;/li&gt;\n&lt;li&gt;全局变量的存空间在什么时候分配？什么时候释？&lt;/li&gt;\n&lt;li&gt;局部变量的存空间在什么时候分配？什么时候释？&lt;/li&gt;\n&lt;li&gt;参数的存储空间在什么时候分配？什么时候释？&lt;/li&gt;\n&lt;li&gt;函数3在调用与返回方式上与函数与2有何不同？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;研究过程\&#34;&gt;研究过程&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;首先通过&lt;code&gt;TCC&lt;/code&gt;编译链接生成汇编文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;\tifndef\t??version\n?debug\tmacro\n\tendm\n\tendif\n\t?debug\tS &amp;quot;\\src\\three.c&amp;quot;\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\nDGROUP\tgroup\t_DATA,_BSS\n\tassume\tcs:_TEXT,ds:DGROUP,ss:DGROUP ;数据段地址和栈段地址为同一块内存空间\n_TEXT\tends\n_DATA\tsegment word public &#39;DATA&#39;\nd@\tlabel\tbyte\nd@w\tlabel\tword\n_DATA\tends\n_BSS\tsegment word public &#39;BSS&#39;\nb@\tlabel\tbyte\nb@w\tlabel\tword\n\t?debug\tC E9826239510C5C7372635C74687265652E63\n_BSS\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n;\t?debug\tL 10\n_main\tproc\tnear\n;\t?debug\tL 11\n\tmov\tword ptr DGROUP:_n,0 ;变量n\n;\t?debug\tL 12\n\tcall\tnear ptr _f1\n;\t?debug\tL 13\n\tmov\tax,2\n\tpush\tax\n\tmov\tax,1\n\tpush\tax\n\tcall\tnear ptr _f2\n\tpop\tcx\n\tpop\tcx\n\tmov\tword ptr DGROUP:_n,ax\n;\t?debug\tL 14\n\tcall\tfar ptr _f3\n@1:\n;\t?debug\tL 15\n\tret\t\n_main\tendp\n;\t?debug\tL 17\n_f1\tproc\tnear\n;\t?debug\tL 17\n\tmov\tword ptr DGROUP:_n,1\n@2:\n;\t?debug\tL 17\n\tret\t\n_f1\tendp\n;\t?debug\tL 18\n_f2\tproc\tnear\n\tpush\tbp\n\tmov\tbp,sp\n\tpush\tsi\n;\t?debug\tL 20\n\tmov\tsi,word ptr [bp+4]\n\tadd\tsi,word ptr [bp+6]\n;\t?debug\tL 21\n\tmov\tax,si\n\tjmp\tshort @3\n@3:\n;\t?debug\tL 22\n\tpop\tsi\n\tpop\tbp\n\tret\t\n_f2\tendp\n;\t?debug\tL 24\n_f3\tproc\tfar\n;\t?debug\tL 24\n\tmov\tword ptr DGROUP:_n,10\n@4:\n;\t?debug\tL 24\n\tret\t\n_f3\tendp\n_TEXT\tends\n_BSS\tsegment word public &#39;BSS&#39;\n_n\tlabel\tword\n\tdb\t2 dup (?)\n_BSS\tends\n\t?debug\tC E9\n_DATA\tsegment word public &#39;DATA&#39;\ns@\tlabel\tbyte\n_DATA\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n_TEXT\tends\n\tpublic\t_main\n\tpublic\t_n\n\tpublic\t_f3\n\tpublic\t_f2\n\tpublic\t_f1\n\tend\n\u001a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;观察汇编代码可以发现变量&lt;code&gt;n&lt;/code&gt;的段地址寄存器为&lt;code&gt;ds&lt;/code&gt;，而&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;的段地址寄存器为&lt;code&gt;ss&lt;/code&gt;，&lt;s&gt;&lt;code&gt;c&lt;/code&gt;的段地址寄存器为&lt;code&gt;cs&lt;/code&gt;。&lt;/s&gt;，&lt;code&gt;c&lt;/code&gt;的段地址寄存器为&lt;code&gt;ss&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在此程序中&lt;code&gt;n&lt;/code&gt;为全局变量并且存放在数据段中故全局变量存放在数据段中。&lt;code&gt;a,b&lt;/code&gt;为参数存放在栈中过参数存放在栈中，&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;全局变量的存储空间在编译的时候就分配好有多大然后在执行可执行文件时在分配内存。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;局部变量在程序执行过程中用到的时候在分配 ，&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;参数在给函数传递前分配空间。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;f3&lt;/code&gt;和&lt;code&gt;f2&lt;/code&gt;的调用方式可以通过汇编代码观察到&lt;code&gt;call\tfar ptr _f3&lt;/code&gt;和&lt;code&gt;call\tnear ptr _f2&lt;/code&gt;一个是&lt;code&gt;call\tfa&lt;/code&gt;一个是``\tcall\tnear&lt;code&gt;而 返回时&lt;/code&gt;f2&lt;code&gt;先进行栈恢复然后在返回，&lt;/code&gt;f3`直接返回不进行栈恢复。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;研究全部完成后，可以回答第2个问题&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;全局变量存储在数据段中&lt;/li&gt;\n&lt;li&gt;局部变量存储在栈中&lt;/li&gt;\n&lt;li&gt;参数存储在栈中&lt;/li&gt;\n&lt;li&gt;返回值存储在寄存器中或者数据段中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;研究2\&#34;&gt;研究2&lt;/h2&gt;\n&lt;h3 id=\&#34;摘要-2\&#34;&gt;摘要&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C\&#34;&gt;void f(void);\nmain() {\n    f();\n    f();\n}\nvoid f(void) {\n    int n = 0;\n    static int a = 0;\n    n++;\n    a++;\n    printf(&amp;quot;  %d  %d\\n&amp;quot;, n, a);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;问题-2\&#34;&gt;问题&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;变量 &lt;code&gt;n&lt;/code&gt; 与&lt;code&gt;a&lt;/code&gt;的存储空间分配方式何不同？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;研究过程-2\&#34;&gt;研究过程&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过&lt;code&gt;tcc&lt;/code&gt;生成汇编文件。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;\tifndef\t??version\n?debug\tmacro\n\tendm\n\tendif\n\t?debug\tS &amp;quot;\\src\\three2.c&amp;quot;\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\nDGROUP\tgroup\t_DATA,_BSS\n\tassume\tcs:_TEXT,ds:DGROUP,ss:DGROUP\n_TEXT\tends\n_DATA\tsegment word public &#39;DATA&#39;\nd@\tlabel\tbyte\nd@w\tlabel\tword\n_DATA\tends\n_BSS\tsegment word public &#39;BSS&#39;\nb@\tlabel\tbyte\nb@w\tlabel\tword\n\t?debug\tC E9A96A39510D5C7372635C7468726565322E63\n_BSS\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n;\t?debug\tL 2\n_main\tproc\tnear\n;\t?debug\tL 3\n\tcall\tnear ptr _f\n;\t?debug\tL 4\n\tcall\tnear ptr _f\n@1:\n;\t?debug\tL 5\n\tret\t\n_main\tendp\n_TEXT\tends\n_DATA\tsegment word public &#39;DATA&#39;\n\tdw\t0\n_DATA\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n;\t?debug\tL 6\n_f\tproc\tnear\n\tpush\tsi\n;\t?debug\tL 7\n\txor\tsi,si\n;\t?debug\tL 9\n\tinc\tsi\n;\t?debug\tL 10\n\tinc\tword ptr DGROUP:d@\n;\t?debug\tL 11\n\tpush\tword ptr DGROUP:d@\n\tpush\tsi\n\tmov\tax,offset DGROUP:s@\n\tpush\tax\n\tcall\tnear ptr _printf\n\tadd\tsp,6\n@2:\n;\t?debug\tL 12\n\tpop\tsi\n\tret\t\n_f\tendp\n_TEXT\tends\n\t?debug\tC E9\n_DATA\tsegment word public &#39;DATA&#39;\ns@\tlabel\tbyte\n\tdb\t32\n\tdb\t32\n\tdb\t37\n\tdb\t100\n\tdb\t32\n\tdb\t32\n\tdb\t37\n\tdb\t100\n\tdb\t10\n\tdb\t0\n_DATA\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n\textrn\t_printf:near\n_TEXT\tends\n\tpublic\t_main\n\tpublic\t_f\n\tend\n\u001a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;观察可以发现&lt;code&gt;n&lt;/code&gt;时局部变量分配在栈空间中而&lt;code&gt;a&lt;/code&gt;分配在数据段中&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;研究3\&#34;&gt;研究3&lt;/h2&gt;\n&lt;h3 id=\&#34;摘要-3\&#34;&gt;摘要&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;unsigned int a = 1;\nunsigned int b = 1;\nunsigned char c = 1;\nunsigned int a1 = 1;\nunsigned long a2 = 1;\n\nmain() {\n    a++;\n    b++;\n    c++;\n    a1++;\n    a2++;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;问题-3\&#34;&gt;问题&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;程序中所有变量的存储空间相邻吗?tc2.0中，整型、字符型、长整型数据的存储空&lt;br&gt;\n间分别为多大？&lt;/li&gt;\n&lt;li&gt;不同的数据类型对数据运算方式的有何影响？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;研究过程-3\&#34;&gt;研究过程&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;通过&lt;code&gt;tcc&lt;/code&gt;生成&lt;code&gt;asm&lt;/code&gt;文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;\tifndef\t??version\n?debug\tmacro\n\tendm\n\tendif\n\t?debug\tS &amp;quot;\\src\\three3.c&amp;quot;\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\nDGROUP\tgroup\t_DATA,_BSS\n\tassume\tcs:_TEXT,ds:DGROUP,ss:DGROUP\n_TEXT\tends\n_DATA\tsegment word public &#39;DATA&#39;\nd@\tlabel\tbyte\nd@w\tlabel\tword\n_DATA\tends\n_BSS\tsegment word public &#39;BSS&#39;\nb@\tlabel\tbyte\nb@w\tlabel\tword\n\t?debug\tC E9496C39510D5C7372635C7468726565332E63\n_BSS\tends\n_DATA\tsegment word public &#39;DATA&#39;\n_a\tlabel\tword\n\tdw\t1\n_b\tlabel\tword\n\tdw\t1\n_c\tlabel\tbyte\n\tdb\t1\n_a1\tlabel\tword\n\tdw\t1\n_a2\tlabel\tword\n\tdw\t1\n\tdw\t0\n_DATA\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n;\t?debug\tL 7\n_main\tproc\tnear\n;\t?debug\tL 8\n\tinc\tword ptr DGROUP:_a\n;\t?debug\tL 9\n\tinc\tword ptr DGROUP:_b\n;\t?debug\tL 10\n\tinc\tbyte ptr DGROUP:_c\n;\t?debug\tL 11\n\tinc\tword ptr DGROUP:_a1\n;\t?debug\tL 12\n\tadd\tword ptr DGROUP:_a2,1\n\tadc\tword ptr DGROUP:_a2+2,0\n@1:\n;\t?debug\tL 13\n\tret\t\n_main\tendp\n_TEXT\tends\n\t?debug\tC E9\n_DATA\tsegment word public &#39;DATA&#39;\ns@\tlabel\tbyte\n_DATA\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n_TEXT\tends\n\tpublic\t_main\n\tpublic\t_c\n\tpublic\t_b\n\tpublic\t_a\n\tpublic\t_a2\n\tpublic\t_a1\n\tend\n\u001a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过汇编代码可以发现只有长整型的运算方式是和其余数据类型的运算方式有所不同，长整型的运算方式为带进位的加法&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过汇编代码可以看出，整型的存储空间为一个字，字符型的存储空间为一个字节，长整型的存储空间为两个字大小。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改程序然后生成可执行文件&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;修改后将数据改成易辨识的数据（1，2，3，4，5）&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;unsigned int a = 1;\nunsigned int b = 2;\nunsigned char c = 3;\nunsigned int a1 = 4;\nunsigned long a2 = 5;\n\nmain() {\n    a++;\n    b++;\n    c++;\n    a1++;\n    a2++;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过debug来进行查看变量的存储空间是否相邻&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925135108.png\&#34; alt=\&#34;image-20200925135108549\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;从图中可以看出存储空间依次相邻&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;研究4\&#34;&gt;研究4&lt;/h2&gt;\n&lt;h3 id=\&#34;摘要-4\&#34;&gt;摘要&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*定义一个结构体类型stu，这个结构体类型描述一个学生的成绩。其中包括\n    : 学号（整型）、C、Os、masm三门课程的成绩（字符型）*/\nstruct stu {\n    int number;\n    char c;\n    char os;\n    char masm;\n};\n/*注意，在实际程序设计中，程序员往往需要定义新的数据类型来对数据进行抽象。C语言支持用基本的数据类型如“char”、“int”等等来构造新的更为复杂的数据类型。\n\n“整型”这一数据类型的名称为“int”:“字符型这一数据类型的名称为“char”:\n以上定义了一个 新的数据类型“struct stu”，这个数据类型的名称为“stu\n\nstructstu型数据包括4个数据项 : number、c、os、masm*/\n\nstruct stu a; /*定义一个struct stu型的变量a*/\n\nmain() {\n    /*定义一个struct stu型的变量b*/\n    struct stu b;\n\n    a.number = 1;\n    a.c = 80;\n    a.os = 82;\n    a.masm = 88;\n\n    b.number = 2;\n    b.c = 90;\n    b.os = 92;\n    b.masm = 98;\n\n    printf(&amp;quot;number c  os masm\\n&amp;quot;);\n    printf(&amp;quot;-----------------\\n&amp;quot;);\n\n    printf(&amp;quot;%d     %d  %d  %d\\n&amp;quot;, a.number, a.c, a.os, a.masm);\n    printf(&amp;quot;%d     %d  %d  %d\\n&amp;quot;, b.number, b.c, b.os, b.masm);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;问题-4\&#34;&gt;问题&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;变量&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;和他们的各个数据项的存储空间如何分配&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;研究过程-4\&#34;&gt;研究过程&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;将程序通过&lt;code&gt;tcc&lt;/code&gt;生成汇编文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;\tifndef\t??version\n?debug\tmacro\n\tendm\n\tendif\n\t?debug\tS &amp;quot;\\src\\three4.c&amp;quot;\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\nDGROUP\tgroup\t_DATA,_BSS\n\tassume\tcs:_TEXT,ds:DGROUP,ss:DGROUP\n_TEXT\tends\n_DATA\tsegment word public &#39;DATA&#39;\nd@\tlabel\tbyte\nd@w\tlabel\tword\n_DATA\tends\n_BSS\tsegment word public &#39;BSS&#39;\nb@\tlabel\tbyte\nb@w\tlabel\tword\n\t?debug\tC E9127239510D5C7372635C7468726565342E63\n_BSS\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n;\t?debug\tL 18\n_main\tproc\tnear\n\tpush\tbp\n\tmov\tbp,sp\n\tsub\tsp,6\n;\t?debug\tL 22\n\tmov\tword ptr DGROUP:_a,1\n;\t?debug\tL 23\n\tmov\tbyte ptr DGROUP:_a+2,80\n;\t?debug\tL 24\n\tmov\tbyte ptr DGROUP:_a+3,82\n;\t?debug\tL 25\n\tmov\tbyte ptr DGROUP:_a+4,88\n;\t?debug\tL 27\n\tmov\tword ptr [bp-6],2\n;\t?debug\tL 28\n\tmov\tbyte ptr [bp-4],90\n;\t?debug\tL 29\n\tmov\tbyte ptr [bp-3],92\n;\t?debug\tL 30\n\tmov\tbyte ptr [bp-2],98\n;\t?debug\tL 32\n\tmov\tax,offset DGROUP:s@\n\tpush\tax\n\tcall\tnear ptr _printf\n\tpop\tcx\n;\t?debug\tL 33\n\tmov\tax,offset DGROUP:s@+19\n\tpush\tax\n\tcall\tnear ptr _printf\n\tpop\tcx\n;\t?debug\tL 35\n\tmov\tal,byte ptr DGROUP:_a+4\n\tcbw\t\n\tpush\tax\n\tmov\tal,byte ptr DGROUP:_a+3\n\tcbw\t\n\tpush\tax\n\tmov\tal,byte ptr DGROUP:_a+2\n\tcbw\t\n\tpush\tax\n\tpush\tword ptr DGROUP:_a\n\tmov\tax,offset DGROUP:s@+38\n\tpush\tax\n\tcall\tnear ptr _printf\n\tadd\tsp,10\n;\t?debug\tL 36\n\tmov\tal,byte ptr [bp-2]\n\tcbw\t\n\tpush\tax\n\tmov\tal,byte ptr [bp-3]\n\tcbw\t\n\tpush\tax\n\tmov\tal,byte ptr [bp-4]\n\tcbw\t\n\tpush\tax\n\tpush\tword ptr [bp-6]\n\tmov\tax,offset DGROUP:s@+57\n\tpush\tax\n\tcall\tnear ptr _printf\n\tadd\tsp,10\n@1:\n;\t?debug\tL 37\n\tmov\tsp,bp\n\tpop\tbp\n\tret\t\n_main\tendp\n_TEXT\tends\n_BSS\tsegment word public &#39;BSS&#39;\n_a\tlabel\tword\n\tdb\t5 dup (?)\n_BSS\tends\n\t?debug\tC E9\n_DATA\tsegment word public &#39;DATA&#39;\ns@\tlabel\tbyte\n\tdb\t110\n\tdb\t117\n\tdb\t109\n..........\n\tdb\t0\n_DATA\tends\n_TEXT\tsegment\tbyte public &#39;CODE&#39;\n\textrn\t_printf:near\n_TEXT\tends\n\tpublic\t_main\n\tpublic\t_a\n\tend\n\u001a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;观察汇编文件可以发现，变量&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;的各个数据项的存储空间是连续分配的不过&lt;code&gt;a&lt;/code&gt;是在数据段中而&lt;code&gt;b&lt;/code&gt;是在栈中，而变量a和b是存储的该变量的初始地址&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;研究5\&#34;&gt;研究5&lt;/h2&gt;\n&lt;h3 id=\&#34;摘要-5\&#34;&gt;摘要&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;struct n {\n    int a;\n    int b;\n    int c;\n};\n\nint f(struct n);\n\nstruct n func(void);\n\nmain() {\n    struct n a;\n    int b;\n\n    a = func();\n    b = f(a);\n\n    printf(&amp;quot; %d&amp;quot;, b);\n    printf(&amp;quot; %d&amp;quot;, f(func()));\n}\n\nint f(struct n a) { return (a.a + a.b) * a.c; }\n\nstruct n func(void) {\n    struct n a;\n    a.a = 1;\n    a.b = 2;\n    a.c = 3;\n    return a;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;问题-5\&#34;&gt;问题&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;向函数传递结构体型数据是如何实现的？&lt;/li&gt;\n&lt;li&gt;从函数返回的结构体型数据存储在何处？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;研究过程-5\&#34;&gt;研究过程&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;要探讨结构体是如何返回的，那么首先应该观察执行函数前后有什么变化。我们开始执行到调用func的汇编语句的前一句然后在执行到后一句观察寄存器的值的变化&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925151809.png\&#34; alt=\&#34;image-20200925151809779\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;发现ax的值发生变化然后看对应数据段中的数据，发现从函数返回的结构体型数据存储在数据段中&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925152304.png\&#34; alt=\&#34;image-20200925152304087\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;所以从函数返回的结构体型数据存储在数据段中。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;对于第一个问题向函数传递结构体型数据是如何实现的？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;首先观察&lt;code&gt;b = f(a);&lt;/code&gt;对应的汇编代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;;\t?debug\tL 16\n\tlea\tbx,word ptr [bp-6]\n\tmov\tdx,ss\n\tmov\tax,bx\n\tmov\tcx,6\n\tcall\tfar ptr SPUSH@\n\tcall\tnear ptr _f\n\tadd\tsp,6\n\tmov\tsi,ax\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可以看到在执行&lt;code&gt;call\tnear ptr _f&lt;/code&gt;前先执行了&lt;code&gt;call\tfar ptr SPUSH@&lt;/code&gt;根据名字猜测应该是往栈里吗压入 一些数据，接下来在&lt;code&gt;debug&lt;/code&gt;中检验猜测是否正确&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;观察到执行完&lt;code&gt;call\tfar ptr SPUSH@&lt;/code&gt;前后寄存器&lt;code&gt;sp&lt;/code&gt;的值发生了改变然后观察栈中的数据可以看到把结构体中的数据压入到栈中(&lt;code&gt;ss:ffce&lt;/code&gt;)。然后接下来进入&lt;code&gt;_f&lt;/code&gt;中看是否使用了栈中压入的数据&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925153742.png\&#34; alt=\&#34;image-20200925153742447\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在进入后执行到&lt;code&gt;mov bp,sp&lt;/code&gt; 后可以发现确实使用了栈中压入的数据（&lt;code&gt;ss:ffce&lt;/code&gt;）&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925154430.png\&#34; alt=\&#34;image-20200925154430806\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;到此就可以回答了，函数是通过栈来传递结构体的&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;变量无非就是存储在栈中或者数据段中，如果变量需要长期存在或者要返回那么会将变量存储在数据段中，而如过仅仅只需在函数中存在或者传递参数就需要将数据保存在栈中。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;0925_-zong-he-yan-jiu-3-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34; 0925_综合研究3研究报告&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;C&#34;,&#34;slug&#34;:&#34;f9uwaThCs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/f9uwaThCs/&#34;}],&#34;date&#34;:&#34;2020-09-25 13:23:45&#34;,&#34;dateFormat&#34;:&#34;2020-09-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/0925_-zong-he-yan-jiu-3-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;14 min read&#34;,&#34;time&#34;:837000,&#34;words&#34;:2924,&#34;minutes&#34;:14},&#34;description&#34;:&#34;研究1\n摘要\n\n用debug对一下程序编译链接后的代码进行研究\n\nunsigned int n;\nvoid f1();\nint f2(int, int);\nvoid far f3();\n\nmain() {\n    n = 0;\n    f1...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B61\&#34;&gt;研究1&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%91%98%E8%A6%81\&#34;&gt;摘要&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B\&#34;&gt;研究过程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B62\&#34;&gt;研究2&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%91%98%E8%A6%81-2\&#34;&gt;摘要&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98-2\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-2\&#34;&gt;研究过程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B63\&#34;&gt;研究3&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%91%98%E8%A6%81-3\&#34;&gt;摘要&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98-3\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-3\&#34;&gt;研究过程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B64\&#34;&gt;研究4&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%91%98%E8%A6%81-4\&#34;&gt;摘要&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98-4\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-4\&#34;&gt;研究过程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B65\&#34;&gt;研究5&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%91%98%E8%A6%81-5\&#34;&gt;摘要&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98-5\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-5\&#34;&gt;研究过程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;研究问题\&#34;&gt;研究问题&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;在main函数中添加代码，打印出下列函数的段地址和偏移地址&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int a;\nvoid f1(void) { a = 1; }\nvoid f2(void) { a = 2; }\nvoid f3(void) { a = 3; }\nmain() {\n    .....\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;研究过程\&#34;&gt;研究过程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;因为代码段地址是存储在&lt;code&gt;cs&lt;/code&gt;中的所以我们可以通过&lt;code&gt;printf(&amp;quot;\\nCS: %x\\n&amp;quot;, _CS);&lt;/code&gt;来打印出程序运行时的段地址&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;函数的标号就是对应的偏移地址我们可以通过&lt;code&gt;printf(&amp;quot;\\nf1: %x\\n&amp;quot;, f1);&lt;/code&gt;来打印出函数的偏移地址&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;所以修改&lt;code&gt;a.c&lt;/code&gt; 添加相应打印输出语句&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;int a;\nvoid f1(void) { a = 1; }\nvoid f2(void) { a = 2; }\nvoid f3(void) { a = 3; }\nmain() {\n    char *string = &amp;quot;--------------------&amp;quot;;\n    printf(&amp;quot;\\nCS: %x\\n&amp;quot;, _CS);\n    printf(&amp;quot;%s&amp;quot;, string);\n    printf(&amp;quot;\\nf1: %x\\n&amp;quot;, f1);\n    printf(&amp;quot;\\nf2: %x\\n&amp;quot;, f2);\n    printf(&amp;quot;\\nf3: %x\\n&amp;quot;, f3);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编译链接完后执行可执行文件可以分别看出&lt;strong&gt;3&lt;/strong&gt;个函数的偏移地址和段地址&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200924130620.png\&#34; alt=\&#34;image-20200924130620295\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;然后在DEBUG中验证输出结果是否正确&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200924130910.png\&#34; alt=\&#34;image-20200924130910136\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200924131638.png\&#34; alt=\&#34;image-20200924131638053\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;发现&lt;code&gt;DEBUG&lt;/code&gt;中执行&lt;code&gt;a.exe&lt;/code&gt; 打印出的&lt;code&gt;CS&lt;/code&gt; 的值和直接运行的结果不一致，剩下三个函数的偏移地址都一致但是&lt;code&gt;DEBUG&lt;/code&gt;中打印的&lt;code&gt;cs&lt;/code&gt; 的值是正确的，所以推测直接运行 &lt;code&gt;a.exe&lt;/code&gt;的结果也是正确的。可能是应为&lt;code&gt;DEBUG&lt;/code&gt;本身就是一个可执行程序所以在运行时系统就已经分配给&lt;code&gt;DEBUG&lt;/code&gt;一块内存然后&lt;code&gt;DEBUG&lt;/code&gt;再分配内存给&lt;code&gt;a.exe&lt;/code&gt;,而直接运行&lt;code&gt;a.exe&lt;/code&gt;的话就系统直接分配的内存所以两次的结果会不同。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;研究结果\&#34;&gt;研究结果&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;函数的名称就好像汇编程序里面的标号起到一个定位的作用，方便程序嵌套和跳转&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;0924_-zong-he-yan-jiu-2-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34; 0924_综合研究2研究报告&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;C&#34;,&#34;slug&#34;:&#34;f9uwaThCs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/f9uwaThCs/&#34;}],&#34;date&#34;:&#34;2020-09-24 13:30:16&#34;,&#34;dateFormat&#34;:&#34;2020-09-24&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/0924_-zong-he-yan-jiu-2-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:103000,&#34;words&#34;:430,&#34;minutes&#34;:2},&#34;description&#34;:&#34;研究问题\n\n在main函数中添加代码，打印出下列函数的段地址和偏移地址\n\nint a;\nvoid f1(void) { a = 1; }\nvoid f2(void) { a = 2; }\nvoid f3(void) { a = 3; }\nm...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E9%97%AE%E9%A2%98\&#34;&gt;研究问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B\&#34;&gt;研究过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E7%BB%93%E6%9E%9C\&#34;&gt;研究结果&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;研究问题\&#34;&gt;研究问题&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;使用 TC 2.0 提供的编译程序进行编译链接&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;编译器： TCC.EXE&lt;/li&gt;\n&lt;li&gt;链接器：TLINK.EXE&lt;/li&gt;\n&lt;li&gt;相关文件：c0s.obj , cs.lib ,  emu.lib, maths.lib&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;研究过程\&#34;&gt;研究过程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;新建目录 &lt;code&gt;31prj_c&lt;/code&gt;将相关文件导入该目录下&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923182246.png\&#34; alt=\&#34;image-20200923182246342\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改&lt;strong&gt;DosBox&lt;/strong&gt;配置文件将 &lt;code&gt;F:\\gitee\\ThreeOneProject\\31prj_c&lt;/code&gt; 挂在到 &lt;code&gt;c:&lt;/code&gt;下&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923182308.png\&#34; alt=\&#34;image-20200923182308106\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编写 &lt;code&gt;a.c&lt;/code&gt;程序来测试&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;main ()\n{\n\tprintf(&amp;quot;hello world!\\n&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;进行测试&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;编译链接&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923182935.png\&#34; alt=\&#34;image-20200923182935034\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923183006.png\&#34; alt=\&#34;image-20200923183006580\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;​&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;p&gt;完成研究实验的基本环境搭建&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;0923_-zong-he-yan-jiu-1-yan-jiu-bao-gao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34; 0923_综合研究1研究报告&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;C&#34;,&#34;slug&#34;:&#34;f9uwaThCs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/f9uwaThCs/&#34;}],&#34;date&#34;:&#34;2020-09-23 17:45:55&#34;,&#34;dateFormat&#34;:&#34;2020-09-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/0923_-zong-he-yan-jiu-1-yan-jiu-bao-gao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:30000,&#34;words&#34;:124,&#34;minutes&#34;:1},&#34;description&#34;:&#34;研究问题\n\n使用 TC 2.0 提供的编译程序进行编译链接\n\n\n编译器： TCC.EXE\n链接器：TLINK.EXE\n相关文件：c0s.obj , cs.lib ,  emu.lib, maths.lib\n\n研究过程\n\n\n新建目录 31pr...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E9%97%AE%E9%A2%98\&#34;&gt;研究问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B\&#34;&gt;研究过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;0622-研究试验\&#34;&gt;0622-研究试验&lt;/h1&gt;\n&lt;h2 id=\&#34;修改c0sobj\&#34;&gt;修改c0s.obj&lt;/h2&gt;\n&lt;p&gt;按书上的汇编代码编译完生成的c0s.obj&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;测试函数(1)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;f()\n{\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;\n}\n\nmain(){\n    int a=0;\n    int b=0;\n    f();\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622162009509.png\&#34; alt=\&#34;image-20200622162009509\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;测试函数(2)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;f();\n\nmain(){\n    int a=0;\n    int b=0;\n    f();\n}\n\nf()\n{\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622161853903.png\&#34; alt=\&#34;image-20200622161853903\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到测试函数1是先调用 &lt;code&gt;f()&lt;/code&gt; 而 测试函数2 先调用 &lt;code&gt;main()&lt;/code&gt;还是没思路&lt;/p&gt;\n&lt;h2 id=\&#34;自己编写的printf\&#34;&gt;自己编写的printf&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void myPrintf(char *, ...);\n\nmain()\n{\n    myPrintf(&amp;quot; char: %c%n int: %d&amp;quot;, &#39;x&#39;, 5);\n}\n\nvoid myPrintf(char *str, ...)\n{\n    int stackIndex = 0;\n    int stringIndex = 0;\n    int screenIndex = 0;\n    int screenBenchmark = 160 * 10;\n\n    while (str[stringIndex] != 0)\n    {\n        if (str[stringIndex] == &#39;%&#39;)\n        {\n            if (str[stringIndex + 1] == &#39;c&#39;)\n            {\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex);\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;\n                screenIndex += 2;\n                stringIndex += 2;\n                stackIndex += 2;\n            }\n            else if (str[stringIndex + 1] == &#39;d&#39;)\n            {\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex) + 0x30;\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;\n\n                stackIndex += 2;\n                screenIndex += 2;\n                stringIndex += 2;\n            }\n            else if (str[stringIndex + 1] == &#39;n&#39;)\n            {\n                screenBenchmark += 160;\n                screenIndex = 0;\n                stringIndex += 2;\n            }\n        }\n        else\n        {\n            *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = str[stringIndex];\n            *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;\n\n            screenIndex += 2;\n            stringIndex += 1;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622115336023.png\&#34; alt=\&#34;image-20200622115336023\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;各种数据类型是通过什么返回的\&#34;&gt;各种数据类型是通过什么返回的&lt;/h2&gt;\n&lt;h3 id=\&#34;float-注释中为对应的汇编代码\&#34;&gt;float( 注释中为对应的汇编代码 )&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;float f(float, float);\n\n/*\n_main\tproc\tnear\n\tpush\tbp\n\tmov\tbp,sp\n\tsub\tsp,12\n*/\nmain()\n{\n        // ax=cccd dx= 400c    \n    float c = 2.2, a = 1.1, b = 1.1; /*\n                                        mov\tdx,16396\n                                        mov\tax,-13107\n                                        mov\tword ptr [bp-10],dx\n                                        mov\tword ptr [bp-12],ax\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下图为2.2对应的十六进制&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622152326481.png\&#34; alt=\&#34;image-20200622152326481\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;                                   /* ;\t?debug\tL 11\n                                        mov\tdx,16268\n                                        mov\tax,-13107\n                                        mov\tword ptr [bp-6],dx\n                                        mov\tword ptr [bp-8],ax\n                                    ;\t?debug\tL 11\n                                        mov\tdx,16268\n                                        mov\tax,-13107\n                                        mov\tword ptr [bp-2],dx\n                                        mov\tword ptr [bp-4],ax\n                                    */\n\n    c = f(a, b); /*\n                                    \tmov\tdx,word ptr [bp-2]\n                                        mov\tax,word ptr [bp-4]\n                                        push\tdx\n                                        push\tax\n                                        mov\tdx,word ptr [bp-6]\n                                        mov\tax,word ptr [bp-8]\n                                        push\tdx\n                                        push\tax\n                                        call\tnear ptr _f\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;跳转到 _f 函数（在下一段）执行，然后返回到此处在执行&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;#f\&#34;&gt;点击跳转&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a name=\&#34;ret\&#34;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;                                     /*   add\tsp,8\n                                        FSTP\tdword ptr [bp-12]\n                                        FWAIT\n                                    */\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最终结果在栈中&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622154424383.png\&#34; alt=\&#34;image-20200622154424383\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;a name=\&#34;f\&#34;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;/*\n_f\tproc\tnear\n\tpush\tbp\n\tmov\tbp,sp\n\tsub\tsp,4\n*/\nfloat f(float a, float b)\n{\n    float ab = a + b;   /*\n                            FLD\tdword ptr [bp+4]\n                            FLD\tdword ptr [bp+8]\n                            FADD\t\n                            FSTP\tdword ptr [bp-4]\n                            FWAIT\n                        */\n    \n    return ab;          /*\n                        \tFLD\tdword ptr [bp-4]\n                            jmp\tshort @2\n                        @2: */\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;返回前的各个寄存器的值&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622151535488.png\&#34; alt=\&#34;image-20200622151535488\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;对应汇编代码中的 &lt;code&gt;[bp-4]&lt;/code&gt; 查看 &lt;code&gt;ss:ffc4&lt;/code&gt; 中的值&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622151831557.png\&#34; alt=\&#34;image-20200622151831557\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;                        /*\n\t\t\t\t\t\t;\t?debug\tL 50\n                            mov\tsp,bp\n                            pop\tbp\n                            ret\t\n                        */\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=\&#34;#ret\&#34;&gt;返回&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;结构体注释中为对应的汇编代码\&#34;&gt;结构体（注释中为对应的汇编代码）&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;struct returnStruct\n{\n    int i_num;\n    float f_num;\n    double d_num;\n};\n\nstruct returnStruct f(struct returnStruct);\n\n\n/*\n\tproc\tnear\n\tpush\tbp\n\tmov\tbp,sp\n\tsub\tsp,28\n*/\n\nmain()\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此时各个寄存器的值&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622134618756.png\&#34; alt=\&#34;image-20200622134618756\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;{\n    struct returnStruct s;\n    struct returnStruct r;\n\n    s.i_num = 1;\t\t//\tmov\tword ptr [bp-28],1\n    s.f_num = 1.1;\t\t/*\n    \t\t\t\t\t\tmov\tdx,16268\n    \t\t\t\t\t\tmov\tax,-13107\n\t\t\t\t\t\t\tmov\tword ptr [bp-24],dx\n\t\t\t\t\t\t\tmov\tword ptr [bp-26],ax\n    \t\t\t\t\t*/\n    s.d_num = 1.11;\t\t/*\n    \t\t\t\t\t\tmov\tword ptr [bp-16],16369\n\t\t\t\t\t\t\tmov\tword ptr [bp-18],-15729\n\t\t\t\t\t\t\tmov\tword ptr [bp-20],23592\n\t\t\t\t\t\t\tmov\tword ptr [bp-22],-2621\n    \t\t\t\t\t*/\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;数据入栈后&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622135318316.png\&#34; alt=\&#34;image-20200622135318316\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;    r=f(s);  \t/*\n\t    \t\t\tlea\tbx,word ptr [bp-14]\n\t\t\t\t\tpush\tss\n\t\t\t\t\tpush\tbx\n\t\t\t\t\tlea\tbx,word ptr [bp-28]\n\t\t\t\t\tmov\tdx,ss\n\t\t\t\t\tmov\tax,bx\n\t\t\t\t\tmov\tcx,14\n\t\t\t\t\tcall\tfar ptr SPUSH@\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;SPUSH@执行前后对应寄存器的变化&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622135746933.png\&#34; alt=\&#34;image-20200622135746933\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到栈顶指针变了然后看对应的栈空间&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622140029293.png\&#34; alt=\&#34;image-20200622140029293\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到 SPUSH@ 的功能是 把 保存的数据再在栈空间中复制一份&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;\t\t\t\t//\tcall\tnear ptr _f\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;_f 执行前后对应寄存器的变化&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622140528110.png\&#34; alt=\&#34;image-20200622140528110\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到&lt;code&gt;ax&lt;/code&gt; 值改变，然后查看对应内存空间的值&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;13\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622141532472.png\&#34; alt=\&#34;image-20200622141532472\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以发现和在call near ptr _f 中最后 &lt;code&gt;lea\tbx,word ptr [bp+4]&lt;/code&gt; 执行完后的栈空间的数据一样&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;14\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200622142146357.png\&#34; alt=\&#34;image-20200622142146357\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;\t\t\t\t//\tadd\tsp,14\n\t\t\t\t*/\n}\n\n/*\n\tproc\tnear\n\tpush\tbp\n\tmov\tbp,sp\n*/\nstruct returnStruct f(struct returnStruct r){\n    r.i_num++;\t\t/*\n    \t\t\t\t\tinc\tword ptr [bp+4]\n    \t\t\t\t*/\n    r.f_num++;\t\t/*\n    \t\t\t\t\tFLD\tdword ptr [bp+6]  \t\t\tFLD类似于   PUSH指令\n    \t\t\t\t\tFADD\tqword ptr DGROUP:s@+9\tFADD类似于  ADD指令\n    \t\t\t\t\tFSTP\tdword ptr [bp+6]\t\tFSTP类似于  POP指令\n    \t\t\t\t\tFWAIT\n\t\t\t\t    */\n    r.d_num++;\t\t/*\n    \t\t\t\t\tFLD\tqword ptr [bp+10]\n\t\t\t\t\t\tFADD\tqword ptr DGROUP:s@+9\n\t\t\t\t\t\tFSTP\tqword ptr [bp+10]\n\t\t\t\t\t\tFWAIT\t\n    \t\t\t\t*/\n\n    return r;\t\t/*\n    \t\t\t\t\tmov\tbx,offset DGROUP:b@\n\t\t\t\t\t\tpush\tds\n\t\t\t\t\t\tpush\tbx\n\t\t\t\t\t\tlea\tbx,word ptr [bp+4]\n\t\t\t\t\t\tpush\tss\n\t\t\t\t\t\tpush\tbx\n\t\t\t\t\t\tmov\tcx,14\n\t\t\t\t\t\tcall\tfar ptr SCOPY@\n\t\t\t\t\t\t;\t?debug\tL 29\n\t\t\t\t\t\tmov\tax,offset DGROUP:b@\n\t\t\t\t\t\tjmp\tshort @2\n\t\t\t\t\t\t@2:\n\t\t\t\t\t\t;\t?debug\tL 30\n\t\t\t\t\t\tpop\tbp\n\t\t\t\t\t\tret\t\n    \t\t\t\t*/\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以发现，结构体返回是把结果复制到内存空间中然后返回该内存空间的首地址。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验1-5补充&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验1-5补充&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-06-22 22:52:35&#34;,&#34;dateFormat&#34;:&#34;2020-06-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验1-5补充/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:309000,&#34;words&#34;:983,&#34;minutes&#34;:6},&#34;description&#34;:&#34;0622-研究试验\n修改c0s.obj\n按书上的汇编代码编译完生成的c0s.obj\n\n测试函数(1)\n\nf()\n{\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;\n    *...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#0622-%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C\&#34;&gt;0622-研究试验&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9c0sobj\&#34;&gt;修改c0s.obj&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E7%9A%84printf\&#34;&gt;自己编写的printf&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E8%BF%94%E5%9B%9E%E7%9A%84\&#34;&gt;各种数据类型是通过什么返回的&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#float-%E6%B3%A8%E9%87%8A%E4%B8%AD%E4%B8%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81\&#34;&gt;float( 注释中为对应的汇编代码 )&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%84%E4%BD%93%E6%B3%A8%E9%87%8A%E4%B8%AD%E4%B8%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81\&#34;&gt;结构体（注释中为对应的汇编代码）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;研究试验4-5\&#34;&gt;研究试验4-5&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;连接。c0s中的什么操作使main函数不管放在程序哪里都可以调用？ 改写自己的c0s，实现main函数在文件中任意位置，也可以准确定位main函数。\n&lt;ol&gt;\n&lt;li&gt;没有实现&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;c0s还有什么其他功能？\n&lt;ol&gt;\n&lt;li&gt;相关初始化&lt;/li&gt;\n&lt;li&gt;申请资源&lt;/li&gt;\n&lt;li&gt;设置DS、SS等寄存器&lt;/li&gt;\n&lt;li&gt;在MAIN函数结束后进行相关资源的释放、环境恢复等工作&lt;/li&gt;\n&lt;li&gt;调用DOS的21H程序返回。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;参数什么时候入栈，a.c中&lt;code&gt;[bp+2][bp+4][bp+6]&lt;/code&gt;表示什么？\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;[bp+2]&lt;/code&gt;  是  &lt;code&gt;call 子程序&lt;/code&gt;的下一条指令的&lt;code&gt;ip&lt;/code&gt;地址（在执行call 指令时把把当前的ip入栈，此时的&lt;code&gt;ip&lt;/code&gt;为下一条指令的&lt;code&gt;ip&lt;/code&gt;）。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[bp+4]&lt;/code&gt; 是 字母 &lt;code&gt;a&lt;/code&gt; 对应的十六进制的 ASCII 码，在子程序执行开始时入栈。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;[bp+6]&lt;/code&gt; 是 颜色对应的 十六进制，在子程序执行开始时入栈。\n&lt;ol&gt;\n&lt;li&gt;&lt;mark&gt;不同&lt;/mark&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200621165803400.png\&#34; alt=\&#34;image-20200621165803400\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;了解printf函数的实现机制，编写可接收任意参数的printf函数。\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;printf&lt;/code&gt;可能是根据传入的&lt;code&gt;%&lt;/code&gt;的个数来确定打印的字符数，读入一个&lt;code&gt;%&lt;/code&gt;就会读取后面一个字符来确定打印的方式，当读出一个&lt;code&gt;0&lt;/code&gt;时打印结束&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;Printf和malloc函数在哪个库中存储（注意可表示int的范围-32768到32767）？\n&lt;ol&gt;\n&lt;li&gt;c0s.obj 用上自己修改的 c0s.obj 后printf无效果。&lt;/li&gt;\n&lt;li&gt;&lt;mark&gt;cs.lib(小模式中的库函数)&lt;/mark&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;#define Buffer((char &lt;em&gt;)&lt;/em&gt;(int far *)).....里面的char 后面加far后，能正确编译连接吗？如果不能，修改一步使其成功编译\n&lt;ol&gt;\n&lt;li&gt;不能。（Lvalue Required in Function Main）&lt;/li&gt;\n&lt;li&gt;&lt;mark&gt;把 int( 16位) 改为 long（32位）&lt;/mark&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验4-5补充&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验4-5补充&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-06-14 22:51:33&#34;,&#34;dateFormat&#34;:&#34;2020-06-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验4-5补充/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:93000,&#34;words&#34;:414,&#34;minutes&#34;:2},&#34;description&#34;:&#34;研究试验4-5\n\n连接。c0s中的什么操作使main函数不管放在程序哪里都可以调用？ 改写自己的c0s，实现main函数在文件中任意位置，也可以准确定位main函数。\n\n没有实现\n\n\nc0s还有什么其他功能？\n\n相关初始化\n申请资源\n设置D...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C4-5\&#34;&gt;研究试验4-5&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;研究试验5\&#34;&gt;研究试验5&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;函数如何接受不确定参数&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;编写ac-解答-相关问题\&#34;&gt;编写&lt;code&gt;a.c&lt;/code&gt; ，解答 相关问题&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;main&lt;/code&gt; 是如何给 &lt;code&gt;showchar&lt;/code&gt; 传递参数的?&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;showchar&lt;/code&gt; 是如何接受参数？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;ac\&#34;&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;c 代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void showchar(char a, int b);\n\nmain()\n{\n    showchar(&#39;a&#39;, 2);\n}\n\nvoid showchar(char a, int b)\n{\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;汇编代码&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091533.png\&#34; alt=\&#34;image-20200611091835656\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091538.png\&#34; alt=\&#34;image-20200611091940357\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;问题解答\&#34;&gt;问题解答&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;main&lt;/code&gt;函数通过 栈 给 &lt;code&gt;showchar&lt;/code&gt; 传递参数&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091543.png\&#34; alt=\&#34;image-20200611093446099\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;showchar&lt;/code&gt; 应该也是从栈中获取的但是汇编代码中没有相关的栈操作。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;编写-bc-思考相关问题\&#34;&gt;编写 &lt;code&gt;b.c&lt;/code&gt; 思考相关问题&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;showchar&lt;/code&gt; 函数是要如何知道呀显示多少个字符的？&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;printf&lt;/code&gt;函数是如何知道有多少个参数的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;bc\&#34;&gt;&lt;code&gt;b.c&lt;/code&gt;&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;c 代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void showchar(int, int, ...);\n\nmain()\n{\n    showchar(8, 2, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;);\n}\n\nvoid showchar(int n, int color, ...)\n{\n    int a;\n    for (a = 0; a != n; a++)\n    {\n        *(char far *)(0xb8000000 + 160 * 10 + 80 + a + a) = *(int *)(_BP + 8 + a + a);\n        *(char far *)(0xb8000000 + 160 * 10 + 81 + a + a) = color;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;汇编代码&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091546.png\&#34; alt=\&#34;image-20200611100510959\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091551.png\&#34; alt=\&#34;image-20200611100524352\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091612.png\&#34; alt=\&#34;image-20200611100549657\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091618.png\&#34; alt=\&#34;image-20200611100619466\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091621.png\&#34; alt=\&#34;image-20200611100647742\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;printf-函数是如何知道有多少给参数\&#34;&gt;&lt;code&gt;printf&lt;/code&gt; 函数是如何知道有多少给参数&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;先写一个 &lt;code&gt;printf.c&lt;/code&gt; 的测试用例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;main(){\n    printf(&amp;quot;%c,%c,%c,%c&amp;quot;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;);\n    printf(&amp;quot;%d,%d,%d,%d&amp;quot;,1,2,3,4);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;汇编代码&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;第一个&lt;code&gt;printf&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091624.png\&#34; alt=\&#34;image-20200611104837574\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第二个 &lt;code&gt;printf&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091627.png\&#34; alt=\&#34;image-20200611105231039\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过对照 &lt;code&gt;printf&lt;/code&gt; 函数 可以猜想 &lt;code&gt;mov ax,0194;&lt;/code&gt;和 &lt;code&gt;mov ax 01a0&lt;/code&gt; 因该是 &lt;code&gt;printf&lt;/code&gt;的第一个参数，然后通过 &lt;code&gt;debug&lt;/code&gt; 可以验证猜想是正确的&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091630.png\&#34; alt=\&#34;image-20200611110541403\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过观察可以看到 &lt;code&gt;25 63 2c 25 63 2c 25 63 2c 25 63 2c 25 63 00&lt;/code&gt; 对应 字符串 &lt;code&gt;%c,%c,%c,%c&lt;/code&gt; 和 &lt;code&gt;25 64 2c 25 64 2c 25 64 2c 25 64 00&lt;/code&gt; 对应字符串 &lt;code&gt;%d,%d,%d,%d&lt;/code&gt;,，故根据以往编程经验猜想 &lt;code&gt;00&lt;/code&gt; 为终止条件。所以把第三个 &lt;code&gt;%c&lt;/code&gt; 对应的汇编代码开头改变为 &lt;code&gt;00&lt;/code&gt;，看看是不是只输出两个字符 通过下图可以看出猜想正确。所以可以得出&lt;code&gt;printf&lt;/code&gt;可能是根据传入的&lt;code&gt;%&lt;/code&gt;的个数来确定打印的字符数，读入一个&lt;code&gt;%&lt;/code&gt;就会读取后面一个字符来确定打印的方式，当读出一个&lt;code&gt;0&lt;/code&gt;时打印结束&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200623091633.png\&#34; alt=\&#34;image-20200611111912747\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;问题解答-2\&#34;&gt;问题解答&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;第一个参数 &lt;code&gt;n&lt;/code&gt; 就是告知函数 &lt;code&gt;showchar&lt;/code&gt;显示多少给字符&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;printf&lt;/code&gt;是通过 &lt;code&gt;%&lt;/code&gt;的个数来得知有多少个参数，通过 &lt;code&gt;00&lt;/code&gt;来判断结束。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;实现一个简单的-printf-函数-只需支持-cd-即可\&#34;&gt;实现一个简单的 &lt;code&gt;printf&lt;/code&gt; 函数 只需支持 &lt;code&gt;%c,%d&lt;/code&gt; 即可&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void myPrintf(char *, ...);\n\nmain()\n{\n    myPrintf(&amp;quot;xxxxx%c,%n,ddddd%d&amp;quot;, &#39;x&#39;, 5);\n}\n\nvoid myPrintf(char *str, ...)\n{\n    int stackIndex = 0;\n    int stringIndex = 0;\n    int screenIndex = 0;\n    int screenBenchmark = 160 * 10;\n\n    while (str[stringIndex] != 0)\n    {\n        if (str[stringIndex] == &#39;%&#39;)\n        {\n            if (str[stringIndex + 1] == &#39;c&#39;)\n            {\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex); /*跨 push call 第一个参数 才能取到相应的值*/\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;\n                screenIndex += 2;\n                stringIndex += 2;\n                stackIndex += 2;\n            }\n            else if (str[stringIndex + 1] == &#39;d&#39;)\n            {\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = *(char *)(_BP + 6 + stackIndex) + 0x30;\n                *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;\n\n                stackIndex += 2;\n                screenIndex += 2;\n                stringIndex += 2;\n            }\n            else if (str[stringIndex + 1] == &#39;n&#39;)\n            {\n                screenBenchmark += 160;\n                screenIndex = 0;\n                stringIndex += 2;\n            }\n        }\n        else\n        {\n            *(char far *)(0xb8000000 + screenBenchmark + screenIndex) = str[stringIndex];\n            *(char far *)(0xb8000000 + screenBenchmark + screenIndex + 1) = 2;\n\n            screenIndex += 2;\n            stringIndex += 1;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验5&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验5&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-06-11 22:49:09&#34;,&#34;dateFormat&#34;:&#34;2020-06-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验5/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:198000,&#34;words&#34;:718,&#34;minutes&#34;:4},&#34;description&#34;:&#34;研究试验5\n\n函数如何接受不确定参数\n\n编写a.c ，解答 相关问题\n\n\nmain 是如何给 showchar 传递参数的?\nshowchar 是如何接受参数？\n\n\na.c\n\n\nc 代码\nvoid showchar(char a, int ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C5\&#34;&gt;研究试验5&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99ac-%E8%A7%A3%E7%AD%94-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98\&#34;&gt;编写&lt;code&gt;a.c&lt;/code&gt; ，解答 相关问题&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac\&#34;&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94\&#34;&gt;问题解答&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99-bc-%E6%80%9D%E8%80%83%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98\&#34;&gt;编写 &lt;code&gt;b.c&lt;/code&gt; 思考相关问题&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#bc\&#34;&gt;&lt;code&gt;b.c&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#printf-%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%9C%89%E5%A4%9A%E5%B0%91%E7%BB%99%E5%8F%82%E6%95%B0\&#34;&gt;&lt;code&gt;printf&lt;/code&gt; 函数是如何知道有多少给参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94-2\&#34;&gt;问题解答&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-printf-%E5%87%BD%E6%95%B0-%E5%8F%AA%E9%9C%80%E6%94%AF%E6%8C%81-cd-%E5%8D%B3%E5%8F%AF\&#34;&gt;实现一个简单的 &lt;code&gt;printf&lt;/code&gt; 函数 只需支持 &lt;code&gt;%c,%d&lt;/code&gt; 即可&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;什么时候用小模式，中模式，大模式&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;&lt;/th&gt;\n&lt;th&gt;小程序&lt;/th&gt;\n&lt;th&gt;大程序&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;小数据&lt;/td&gt;\n&lt;td&gt;微，小&lt;/td&gt;\n&lt;td&gt;中&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;大数据&lt;/td&gt;\n&lt;td&gt;紧凑&lt;/td&gt;\n&lt;td&gt;大，巨&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;小程序&lt;/strong&gt;就是指程序只有一个程序段，大小不超过64KB，缺省的码（函数）指针是near（近程指针）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;大程序&lt;/strong&gt;就是指程序只有多个程序段，每个程序段不超过64KB，但总程序量可超过64KB，缺省的码指针是far（远程指针）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;小数据&lt;/strong&gt;就是指数据只有一个数据段，缺省的数据指针是near。&lt;strong&gt;大数据&lt;/strong&gt;就是指数据有多个数据段，缺省的数据指针是far。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;TC跟TCC有什么区别？用TCC单步编译连接生成的文件和直接生成的可执行文件有什么区别？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;从功能上来看，tcc.exe只能编译当前目录下已存在的文件，而TC2.0则支持文件的创建、修改、保存、编译、连接，是集成了tcc.exe和tlink.exe的一个c语言小型开发平台。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;tc所需5个文件的作用&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;C0S.OBJ 小模式启动代码&lt;/li&gt;\n&lt;li&gt;EMU.LIB 8087仿真库&lt;/li&gt;\n&lt;li&gt;MATHS.LIB 是运算相关的库&lt;/li&gt;\n&lt;li&gt;GRAPHICS.LIB 图形库&lt;/li&gt;\n&lt;li&gt;CS.LIB 小模式运行库&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;graphics.lib在tc编译链接（提示：在菜单中有相应的设置选项）和tcc分步编译链接时是不是必须的？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;不是必须的\n&lt;ol&gt;\n&lt;li&gt;&lt;mark&gt;把 graphics.lib 删除后在通过 TCC.EXE 编译链接程序后可以正常生成 可执行文件&lt;/mark&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编译和连接有什么作用？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;编译&lt;/strong&gt;，就是Compile，由C编译程序对你写的代码进行词法和句法分析，发现并报告错误，有错时编译不能通过。如若无错，则生成中间代码，&lt;strong&gt;扩展名为obj&lt;/strong&gt;，此时它便是二进制的了&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;连接&lt;/strong&gt;，在汇编里称Link，在C里叫生成，即Build，它的作用是&lt;strong&gt;生成可执行的exe文件&lt;/strong&gt;。由于一个程序的源码可由多个文件组成。这些文件在第二步 中分别编译，生成各自的目标文件，这一步的作用便是将这些obj文件，以及程序中需要的其它库文件(dll除外），统一到一个文件中来，形成单个的exe 文件。此exe文件便可以在操作系统下直接运行了。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;全局变量在什么时候就被分配内存 ？ 函数执行之前，还是函数执行之后？是预处理的时候分配的吗？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;初始化的全局变量，在程序加载的时候，会从程序文件中，映射到内存的数据段。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;预处理的作用是什么？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;C语言预处理程序的作用是根据源代码中的预处理指令修改你的源代码。预处理指令是一种命令语句(如#define)，它指示预处理程序如何修改源代码。在对程序进行通常的编译处理之前，编译程序会自动运行预处理程序，对程序进行编译预处理。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;预处理在什么时候被执行的？是在程序编译前还是可执行文件执行前&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;程序编译前&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;malloc函数是怎么开辟内存空间的，怎么返回的?它的实现原理是什么？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;malloc函数其实就是在内存中找一片指定大小的空间，然后将这个空间的首地址给一个指针变量并且返回&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;浮点型数据和结构体作为返回值是存放在哪里返回的?&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;float dx+ax&lt;/li&gt;\n&lt;li&gt;结构体 暂未解决&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;尝试使用tcc -S 命令或其他方式在C0S.OBJ文件中找到main函数的标号。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;两个连续的ret指令，第二个ret指令也会被执行到，那么第二个ret指令的作用是什么？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;程序返回&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;宏定义&lt;code&gt;#define Buffer (char *)*(int far*)0x200&lt;/code&gt; 的理解&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;(int far*)0x200&lt;/code&gt;表示为地址 &lt;code&gt;0200：0000&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;*(int far*)0x200&lt;/code&gt; 表示为地址所对应的内存里的值（s）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;(char *)*(int far*)0x200&lt;/code&gt; 地址（s）对应的内存存储的char型数据大小为1个字节&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验1-3补充&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验1-3补充&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-06-08 22:50:14&#34;,&#34;dateFormat&#34;:&#34;2020-06-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验1-3补充/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:220000,&#34;words&#34;:1031,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n\n什么时候用小模式，中模式，大模式\n\n\n\n\n\n\n小程序\n大程序\n\n\n\n\n小数据\n微，小\n中\n\n\n大数据\n紧凑\n大，巨\n\n\n\n\n\n小程序就是指程序只有一个程序段，大小不超过64KB，缺省的码（函数）指针是near（近程指针）\n\n\n大程序就是...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;研究试验4\&#34;&gt;研究试验4&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;不使用 main 函数&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;编写程序-fc\&#34;&gt;编写程序 &lt;code&gt;f.c&lt;/code&gt;&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;f()\n{\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;1-将程序保存在-minc-目录下-编译链接\&#34;&gt;1. 将程序保存在 &lt;code&gt;minc&lt;/code&gt; 目录下 编译链接&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;在连接过程中会出现问题\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608170212786.png\&#34; alt=\&#34;image-20200608170212786\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;提示出的缺少 &lt;code&gt;_main&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;可能与 &lt;code&gt;C0S&lt;/code&gt; 有关&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;2-用学习汇编是的-linkexe-对-tcexe-生成的-fobj-进行连接-生成-fexe\&#34;&gt;2. 用学习汇编是的 &lt;code&gt;link.exe&lt;/code&gt; 对 &lt;code&gt;tc.exe&lt;/code&gt; 生成的 &lt;code&gt;f.obj&lt;/code&gt; 进行连接 生成 &lt;code&gt;f.exe&lt;/code&gt;&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;由图中可见总共由 &lt;strong&gt;303&lt;/strong&gt; 个字节\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608170929124.png\&#34; alt=\&#34;image-20200608170929124\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;函数 &lt;code&gt;f&lt;/code&gt; 实现了其功能 在屏幕中打印出 &lt;strong&gt;a&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608171139742.png\&#34; alt=\&#34;image-20200608171139742\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;但是函数不能正常结束 Dosbox 会卡死后然后退出\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608171415211.png\&#34; alt=\&#34;image-20200608171415211\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;debug 后可见 &lt;code&gt;f&lt;/code&gt;函数的偏移地址为0\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608171625247.png\&#34; alt=\&#34;image-20200608171625247\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;3-写一个-mc-在-编译-连接\&#34;&gt;3. 写一个 &lt;code&gt;m.c&lt;/code&gt; 在 编译 连接&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;main()\n{\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40 + 1) = 2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol&gt;\n&lt;li&gt;由图可见代码总长为 &lt;strong&gt;4280&lt;/strong&gt; 个字节\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608172758289.png\&#34; alt=\&#34;image-20200608172758289\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;由图可见  &lt;code&gt;m.exe&lt;/code&gt; 可以正常返回 因为在执行玩 &lt;code&gt;m.exe&lt;/code&gt; 后还可以在命令行输入新的命令\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608173027098.png\&#34; alt=\&#34;image-20200608173027098\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;m.exe&lt;/code&gt; 的汇编代码中&lt;strong&gt;main&lt;/strong&gt; 的偏移地址为 &lt;strong&gt;01fa&lt;/strong&gt; 而 &lt;code&gt;f.exe&lt;/code&gt; 中 &lt;strong&gt;f&lt;/strong&gt; 的偏移地址为 &lt;strong&gt;0000&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608173341369.png\&#34; alt=\&#34;main\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;H:/Books/%25E7%25BB%25BC%25E5%2590%2588%25E7%25A0%2594%25E7%25A9%25B6/0608-%25E7%25A0%2594%25E7%25A9%25B6%25E8%25AF%2595%25E9%25AA%258C4-%25E5%25AE%25A3%25E8%25AE%25B2%25E4%25BC%259A%25E7%25A0%2594%25E7%25A9%25B6%25E6%258A%25A5%25E5%2591%258A-%25E5%25B0%25B9%25E5%25BF%25A0%25E6%2581%25A9.assets/image-20200608171625247.png\&#34; alt=\&#34;f\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;4-debug-对-mexe-进行跟踪\&#34;&gt;4. debug 对 m.exe 进行跟踪&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;跳转到main函数开始地址\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608173857741.png\&#34; alt=\&#34;image-20200608173857741\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;执行到 ret 后 跳转到 了 &lt;code&gt;076a：011d&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608174106973.png\&#34; alt=\&#34;image-20200608174106973\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;由图可以看到 在 &lt;code&gt;07fa:011a&lt;/code&gt; 中调用 &lt;code&gt;main&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608174432350.png\&#34; alt=\&#34;image-20200608174432350\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;在执行完&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608175623677.png\&#34; alt=\&#34;image-20200608175623677\&#34; loading=\&#34;lazy\&#34;&gt;划红线的ret 然后一直按&lt;strong&gt;p&lt;/strong&gt; 会找到程序的返回指令为 &lt;code&gt;int 21&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608174723076.png\&#34; alt=\&#34;image-20200608174723076\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;5-思考问题\&#34;&gt;5. 思考问题&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;main函数的调用指令和程序返回指令应该是c0s中对应的代码中调用的&lt;/li&gt;\n&lt;li&gt;没有main 函数，提示错误信息中由 “c0s” 的相关信息，因该是 tc.exe 把 在搭建环境时所需要的 文件  和 用户的 &lt;code&gt;obj&lt;/code&gt; 生成 &lt;code&gt;.exe&lt;/code&gt; 而不单单是 一个 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;调用 main 函数的指令 因该来自于 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;用 &lt;code&gt;link.exe&lt;/code&gt; 连接 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;debug 后的 &lt;code&gt;c0s.exe&lt;/code&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608182441695.png\&#34; alt=\&#34;image-20200608182441695\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608182616287.png\&#34; alt=\&#34;image-20200608182616287\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;可以看见基本结构和由用户生成的包含main 函数的基本结构相似&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;6-用linkexe对-c0sobj-连接生成-c0sexe\&#34;&gt;6. 用&lt;code&gt;link.exe&lt;/code&gt;对 &lt;code&gt;c0s.obj&lt;/code&gt; 连接生成 &lt;code&gt;c0s.exe&lt;/code&gt;&lt;/h2&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;c0s.exe&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;m.exe&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608183128613.png\&#34; alt=\&#34;image-20200608183128613\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608184824390.png\&#34; alt=\&#34;image-20200608184824390\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608183211934.png\&#34; alt=\&#34;image-20200608183211934\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608184840521.png\&#34; alt=\&#34;image-20200608184840521\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608183244482.png\&#34; alt=\&#34;image-20200608183244482\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608184854759.png\&#34; alt=\&#34;image-20200608184854759\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;由上图可知代码开头部分两者的开始部分都相同&lt;/p&gt;\n&lt;h2 id=\&#34;7-对比-mexe-和-c0sexe-中调用main函数的call指令的偏移地址的后10条指令\&#34;&gt;7. 对比 &lt;code&gt;m.exe&lt;/code&gt; 和 &lt;code&gt;c0s.exe&lt;/code&gt; 中调用main函数的call指令的偏移地址的后10条指令&lt;/h2&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;c0s.exe&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;m.exe&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608190030232.png\&#34; alt=\&#34;image-20200608190030232\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608185534954.png\&#34; alt=\&#34;image-20200608185534954\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;由上图可知前10行有3行调用的不同 第一个为调用main函数然后返回到 &lt;code&gt;c0s.obj&lt;/code&gt; 中的 &lt;strong&gt;076a:011d&lt;/strong&gt;，其余的call应该也是完成相关任务后返回 &lt;code&gt;c0s.oj&lt;/code&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;8-改写-c0sobj\&#34;&gt;8. 改写 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;编写c0s.obj&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;assume cs:code\ndata segment\n\nDB 128 dup(0)\n\ndata ends\n\ncode segment\nstart:\n    mov ax,data\n    mov ds,ax\n    mov ss,ax\n    mov sp,128\n\n    call s\n\n    mov ax,4c00h\n    int 21h\n\n    s:\ncode ends\nend start\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;用 &lt;code&gt;masm&lt;/code&gt; 生成 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在 &lt;code&gt;tc&lt;/code&gt;  中 打开 &lt;code&gt;f.c&lt;/code&gt; 编译 连接 后可以正常生成 &lt;code&gt;f.exe&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;16\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608192023362.png\&#34; alt=\&#34;image-20200608192023362\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;9-debug-fexe\&#34;&gt;9 debug f.exe&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;17\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608192142927.png\&#34; alt=\&#34;image-20200608192142927\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;18\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608192223397.png\&#34; alt=\&#34;image-20200608192223397\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到程序正确的调用了 &lt;code&gt;f()&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;疑问\&#34;&gt;疑问：&lt;/h3&gt;\n&lt;p&gt;为什么汇编代码中仅仅调用了 &lt;strong&gt;s&lt;/strong&gt; 然后 &lt;strong&gt;s&lt;/strong&gt; 什么都没用，连接完后就把&lt;strong&gt;f&lt;/strong&gt;函数自动填充过去到 s 处&lt;/p&gt;\n&lt;h2 id=\&#34;10-编写新的fc\&#34;&gt;10 编写新的&lt;code&gt;f.c&lt;/code&gt;&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;#define Buffer ((char *)*(int far *)0x02000000)\nf()\n{\n    Buffer = 0;\n    Buffer[10] = 0;\n    while (Buffer[10] != 8)\n    {\n        Buffer[Buffer[10]] = &#39;a&#39; + Buffer[10];\n        Buffer[10]++;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;debug 后的 f.exe&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608210836686.png\&#34; alt=\&#34;image-20200608210836686\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608210902645.png\&#34; alt=\&#34;image-20200608210902645\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608210921844.png\&#34; alt=\&#34;image-20200608210921844\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200608211211498.png\&#34; alt=\&#34;image-20200608211211498\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;可以看到编译连结完debug后的代码逻辑和汇编代码逻辑基本一致&lt;/p&gt;\n&lt;h2 id=\&#34;感悟\&#34;&gt;感悟&lt;/h2&gt;\n&lt;p&gt;C0S.OBJ的功能就是进行相关初始化，申请资源、设置DS、SS等寄存器，并且在MAIN函数结束后进行相关资源的释放、环境恢复等工作，随后调用DOS的21H程序返回。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验4&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验4&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-06-08 22:47:18&#34;,&#34;dateFormat&#34;:&#34;2020-06-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验4/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:213000,&#34;words&#34;:858,&#34;minutes&#34;:4},&#34;description&#34;:&#34;研究试验4\n\n不使用 main 函数\n\n编写程序 f.c\nf()\n{\n    *(char far *)(0xb8000000 + 160 * 10 + 2 * 40) = &#39;a&#39;;\n    *(char far *)(0xb8000000...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C4\&#34;&gt;研究试验4&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F-fc\&#34;&gt;编写程序 &lt;code&gt;f.c&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%B0%86%E7%A8%8B%E5%BA%8F%E4%BF%9D%E5%AD%98%E5%9C%A8-minc-%E7%9B%AE%E5%BD%95%E4%B8%8B-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5\&#34;&gt;1. 将程序保存在 &lt;code&gt;minc&lt;/code&gt; 目录下 编译链接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%B1%87%E7%BC%96%E6%98%AF%E7%9A%84-linkexe-%E5%AF%B9-tcexe-%E7%94%9F%E6%88%90%E7%9A%84-fobj-%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5-%E7%94%9F%E6%88%90-fexe\&#34;&gt;2. 用学习汇编是的 &lt;code&gt;link.exe&lt;/code&gt; 对 &lt;code&gt;tc.exe&lt;/code&gt; 生成的 &lt;code&gt;f.obj&lt;/code&gt; 进行连接 生成 &lt;code&gt;f.exe&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%86%99%E4%B8%80%E4%B8%AA-mc-%E5%9C%A8-%E7%BC%96%E8%AF%91-%E8%BF%9E%E6%8E%A5\&#34;&gt;3. 写一个 &lt;code&gt;m.c&lt;/code&gt; 在 编译 连接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-debug-%E5%AF%B9-mexe-%E8%BF%9B%E8%A1%8C%E8%B7%9F%E8%B8%AA\&#34;&gt;4. debug 对 m.exe 进行跟踪&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98\&#34;&gt;5. 思考问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E7%94%A8linkexe%E5%AF%B9-c0sobj-%E8%BF%9E%E6%8E%A5%E7%94%9F%E6%88%90-c0sexe\&#34;&gt;6. 用&lt;code&gt;link.exe&lt;/code&gt;对 &lt;code&gt;c0s.obj&lt;/code&gt; 连接生成 &lt;code&gt;c0s.exe&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E5%AF%B9%E6%AF%94-mexe-%E5%92%8C-c0sexe-%E4%B8%AD%E8%B0%83%E7%94%A8main%E5%87%BD%E6%95%B0%E7%9A%84call%E6%8C%87%E4%BB%A4%E7%9A%84%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E7%9A%84%E5%90%8E10%E6%9D%A1%E6%8C%87%E4%BB%A4\&#34;&gt;7. 对比 &lt;code&gt;m.exe&lt;/code&gt; 和 &lt;code&gt;c0s.exe&lt;/code&gt; 中调用main函数的call指令的偏移地址的后10条指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-%E6%94%B9%E5%86%99-c0sobj\&#34;&gt;8. 改写 &lt;code&gt;c0s.obj&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9-debug-fexe\&#34;&gt;9 debug f.exe&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE\&#34;&gt;疑问：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#10-%E7%BC%96%E5%86%99%E6%96%B0%E7%9A%84fc\&#34;&gt;10 编写新的&lt;code&gt;f.c&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%84%9F%E6%82%9F\&#34;&gt;感悟&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;研究试验3\&#34;&gt;研究试验3&lt;/h1&gt;\n&lt;h2 id=\&#34;学习过程\&#34;&gt;学习过程&lt;/h2&gt;\n&lt;h3 id=\&#34;1\&#34;&gt;（1）&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200604201716625.png\&#34; alt=\&#34;image-20200604201716625\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200604202304616.png\&#34; alt=\&#34;image-20200604202304616\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;2\&#34;&gt;（2）&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;main()\n{\n    *(char far *)0x0b80009B0 = 0x61;\n    *(char far *)0x0b80009B1 = 0x2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3\&#34;&gt;（3）&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605124949972.png\&#34; alt=\&#34;image-20200605124949972\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125037239.png\&#34; alt=\&#34;image-20200605125037239\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;4\&#34;&gt;（4）&lt;/h3&gt;\n&lt;p&gt;书上的代码转换为的汇编&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605131126692.png\&#34; alt=\&#34;image-20200605131126692\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605131157695.png\&#34; alt=\&#34;image-20200605131157695\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;5\&#34;&gt;（5）&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132213671.png\&#34; alt=\&#34;image-20200605132213671\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132236127.png\&#34; alt=\&#34;image-20200605132236127\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132320486.png\&#34; alt=\&#34;image-20200605132320486\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605132336619.png\&#34; alt=\&#34;image-20200605132336619\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;解决的问题\&#34;&gt;解决的问题&lt;/h2&gt;\n&lt;h3 id=\&#34;2-2\&#34;&gt;（2）&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605124313108.png\&#34; alt=\&#34;image-20200605124313108\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;3-2\&#34;&gt;（3）&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;全局变量放在内存中\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125347415.png\&#34; alt=\&#34;image-20200605125347415\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;局部变量放在栈中\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125422103.png\&#34; alt=\&#34;image-20200605125422103\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;每个函数开头的 &lt;code&gt;push bp mov bp sp&lt;/code&gt; 就是为了在函数中正确的使用局部变量\n&lt;ol&gt;\n&lt;li&gt;main程序开始 &lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125742479.png\&#34; alt=\&#34;image-20200605125742479\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;main程序结束 &lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605125842195.png\&#34; alt=\&#34;image-20200605125842195\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;4-2\&#34;&gt;（4）&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;返回值存放在 &lt;strong&gt;ax&lt;/strong&gt; 中&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;//由于书上的代码返回值为0，不好对比。故将 a b 赋值为 1\nint f(void);\n\nint a, b, ab;\n\nmain()\n{\n    int c;\n    c = f();\n}\n\nint f(void)\n{\n    a = b = 1;//返回值为2\n    ab = a + b;\n    return ab;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605130645458.png\&#34; alt=\&#34;image-20200605130645458\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200605130830428.png\&#34; alt=\&#34;image-20200605130830428\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;5-2\&#34;&gt;（5）&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;void *malloc(long NumBytes)&lt;/code&gt;：该函数分配了&lt;code&gt;NumBytes&lt;/code&gt;个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;void free(void *FirstByte)&lt;/code&gt;： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。&lt;/p&gt;\n&lt;h2 id=\&#34;研究体会\&#34;&gt;研究体会&lt;/h2&gt;\n&lt;p&gt;本次实验较前两实验略显复杂，需要大量编译链接分析工作，通过本次实验，认识的C语言分配内存的机制&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验3&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验3&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-06-04 22:46:43&#34;,&#34;dateFormat&#34;:&#34;2020-06-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验3/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:70000,&#34;words&#34;:296,&#34;minutes&#34;:2},&#34;description&#34;:&#34;研究试验3\n学习过程\n（1）\n\n\n（2）\nmain()\n{\n    *(char far *)0x0b80009B0 = 0x61;\n    *(char far *)0x0b80009B1 = 0x2;\n}\n\n（3）\n\n\n（4）\n书上的代...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C3\&#34;&gt;研究试验3&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B\&#34;&gt;学习过程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1\&#34;&gt;（1）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2\&#34;&gt;（2）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3\&#34;&gt;（3）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4\&#34;&gt;（4）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5\&#34;&gt;（5）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;解决的问题&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-2\&#34;&gt;（2）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-2\&#34;&gt;（3）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-2\&#34;&gt;（4）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-2\&#34;&gt;（5）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E4%BD%93%E4%BC%9A\&#34;&gt;研究体会&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;研究试验2\&#34;&gt;研究试验2&lt;/h1&gt;\n&lt;h2 id=\&#34;学习过程\&#34;&gt;学习过程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;编写号&lt;strong&gt;url.c&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164231003.png\&#34; alt=\&#34;image-20200531164231003\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在 &lt;strong&gt;TC&lt;/strong&gt; 中 编译链接生成 &lt;strong&gt;url.exe&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164208010.png\&#34; alt=\&#34;image-20200531164208010\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;用 &lt;strong&gt;DEBUG&lt;/strong&gt; 调试 &lt;strong&gt;URL.EXE&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;按下 &lt;strong&gt;U&lt;/strong&gt; 调试后不像是我所写的 url.c\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164532886.png\&#34; alt=\&#34;image-20200531164532886\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;观察了一会儿，我试着看了看 076a:01f8 的出的代码，看见下面几行是url.c 中所写的\n&lt;ol&gt;\n&lt;li&gt;\n&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531164747917.png\&#34; alt=\&#34;image-20200531164747917\&#34; style=\&#34;zoom:150%;\&#34; /&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改url.c使其打印出main的地址（按十六进制）&lt;/p&gt;\n&lt;p&gt;重新编译运行后答应出main函数的地址&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531165157632.png\&#34; alt=\&#34;image-20200531165157632\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可以看到 &lt;code&gt;1fa&lt;/code&gt; 处对应的代码为 &lt;code&gt;push BP&lt;/code&gt;和 图 在第三步中观察到的一样&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编写，编译，链接，debug &lt;code&gt;ur2.c&lt;/code&gt; ，跳转到main 函数执行位置可以看到在main函数中调用了子程序&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531170601321.png\&#34; alt=\&#34;image-20200531170601321\&#34; style=\&#34;zoom:150%;\&#34; /&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;解决的问题\&#34;&gt;解决的问题&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;main函数在汇编语言的代码段中，&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200531163450988.png\&#34; alt=\&#34;image-20200531163450988\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;图中的 &lt;code&gt;mov 01f8,dx&lt;/code&gt;为main的人口地址&lt;/li&gt;\n&lt;li&gt;main函数应该也是一个代码段中的子功能&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;研究体会\&#34;&gt;研究体会&lt;/h2&gt;\n&lt;p&gt;c 语言的函数调用本质上就是包装了汇编中的调用子函数和子程序返回的相关指令&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验2&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验2&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-05-31 22:43:58&#34;,&#34;dateFormat&#34;:&#34;2020-05-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验2/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:57000,&#34;words&#34;:259,&#34;minutes&#34;:1},&#34;description&#34;:&#34;研究试验2\n学习过程\n\n\n编写号url.c\n\n\n\n\n\n在 TC 中 编译链接生成 url.exe\n\n\n\n\n\n用 DEBUG 调试 URL.EXE\n\n按下 U 调试后不像是我所写的 url.c\n\n\n\n\n观察了一会儿，我试着看了看 076a:0...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C2\&#34;&gt;研究试验2&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B\&#34;&gt;学习过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;解决的问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E4%BD%93%E4%BC%9A\&#34;&gt;研究体会&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;研究试验1\&#34;&gt;研究试验1&lt;/h1&gt;\n&lt;h2 id=\&#34;1-学习过程\&#34;&gt;1. 学习过程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;下载 tc&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在&lt;strong&gt;minic&lt;/strong&gt;下导入&lt;strong&gt;tc.exe&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215125606.png\&#34; alt=\&#34;image-20200530215125606\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在dosbox中用 &lt;strong&gt;TC&lt;/strong&gt; 打开事先 写好的 &lt;strong&gt;Simple.c&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;dosbox 的配置文件中添加下列三行&lt;/p&gt;\n&lt;p&gt;​\tMOUNT c: F:\\GitHub\\ASM-\\minic&lt;/p&gt;\n&lt;p&gt;​\tc:&lt;/p&gt;\n&lt;p&gt;​\ttc&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编译 simple.c&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;生成obj文件&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215307318.png\&#34; alt=\&#34;image-20200530215307318\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215345246.png\&#34; alt=\&#34;image-20200530215345246\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;链接&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215822177.png\&#34; alt=\&#34;image-20200530215822177\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215911676.png\&#34; alt=\&#34;image-20200530215911676\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530215949585.png\&#34; alt=\&#34;image-20200530215949585\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220128341.png\&#34; alt=\&#34;image-20200530220128341\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220215027.png\&#34; alt=\&#34;image-20200530220215027\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220301146.png\&#34; alt=\&#34;image-20200530220301146\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/image-20200530220350556.png\&#34; alt=\&#34;image-20200530220350556\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;2-解决的问题\&#34;&gt;2. 解决的问题&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;编译这个c文件，不需要&lt;strong&gt;tc&lt;/strong&gt;目录中所有的文件.只需再加5个就可以完成基本的c文件的链接。&lt;/li&gt;\n&lt;li&gt;在option选项中吧dictionary中的配置的默认目录全部删除后就可以找到链接中新添加的文件&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;4-研究体会\&#34;&gt;4. 研究体会&lt;/h2&gt;\n&lt;p&gt;经过此次实验，我们顺利的找出了TC中和编译链接一个C语言程序相关的文件，熟悉了TC的使用&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;研究试验1&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;研究试验1&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ASM&#34;,&#34;slug&#34;:&#34;z74Ni2u5JH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/z74Ni2u5JH/&#34;}],&#34;date&#34;:&#34;2020-05-30 20:37:36&#34;,&#34;dateFormat&#34;:&#34;2020-05-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/研究试验1/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:42000,&#34;words&#34;:189,&#34;minutes&#34;:1},&#34;description&#34;:&#34;研究试验1\n1. 学习过程\n\n\n下载 tc\n\n\n在minic下导入tc.exe\n\n\n\n\n\n在dosbox中用 TC 打开事先 写好的 Simple.c\n\ndosbox 的配置文件中添加下列三行\n​\tMOUNT c: F:\\GitHub\\AS...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C1\&#34;&gt;研究试验1&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B\&#34;&gt;1. 学习过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;2. 解决的问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E7%A0%94%E7%A9%B6%E4%BD%93%E4%BC%9A\&#34;&gt;4. 研究体会&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;接口芯片和端口\&#34;&gt;接口芯片和端口&lt;/h1&gt;\n&lt;hr&gt;\n&lt;ol&gt;\n&lt;li&gt;端口的读写只有&lt;strong&gt;in&lt;/strong&gt;,&lt;strong&gt;out&lt;/strong&gt; , 一个读一个写（CPU的视角来看）&lt;/li&gt;\n&lt;li&gt;访问端口&lt;br&gt;\nCPU 通过地址线 将 &lt;strong&gt;60h&lt;/strong&gt;的信息发出&lt;br&gt;\n通过控制线发出读命令&lt;br&gt;\n端口所在的芯片将&lt;strong&gt;60h&lt;/strong&gt;端口的数据通过数据总线将数据送入CPU&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;外中断\&#34;&gt;外中断&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;1-可屏蔽中断\&#34;&gt;1. 可屏蔽中断&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;IF=0 CPU 可以不响应可屏蔽中断&lt;/li&gt;\n&lt;li&gt;IF=1 执行完当前指令后执行中断&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;2-不可屏蔽终端\&#34;&gt;2. 不可屏蔽终端&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;不可屏蔽中断的中断类型码固定为&lt;strong&gt;2&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;pc机键盘的处理过程\&#34;&gt;PC机键盘的处理过程&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;1-键盘输入\&#34;&gt;1. 键盘输入&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;扫描码（通码）送入 &lt;strong&gt;60h&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;断码 = 通码 + 80h&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2-引发9号中断\&#34;&gt;2. 引发9号中断&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;有数据送入 &lt;strong&gt;60h&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;芯片向 &lt;strong&gt;CPU&lt;/strong&gt; 发出 中断类型码为 &lt;strong&gt;9&lt;/strong&gt;的可屏蔽中断&lt;/li&gt;\n&lt;li&gt;如果 &lt;strong&gt;IF=1&lt;/strong&gt; CPU 执行中断例程&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;3-执行9号中断例程\&#34;&gt;3. 执行9号中断例程&lt;/h2&gt;\n&lt;h3 id=\&#34;int9-的基本键盘处理流程\&#34;&gt;int9 的基本键盘处理流程&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;读出 &lt;strong&gt;60h&lt;/strong&gt; 的扫描码\n&lt;ul&gt;\n&lt;li&gt;如果是扫描码 将扫描码和字符码送入内存中的键盘缓冲区&lt;/li&gt;\n&lt;li&gt;如果是控制键的扫描码则将其转变为状态字节存入内存中的状态字节的单元&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;对键盘系统进行相关控制&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;编写中断例程\&#34;&gt;编写中断例程&lt;/h1&gt;\n&lt;p&gt;新的中断例程大概为&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;从60h端口读出键盘的输入\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;in al 60h&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;调用BIOS 的int9 的中断例程\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;pushf&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;call dword ptr cs:[200h] ;cs==0&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;功能的实现&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-外中断&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-外中断&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-03-23 13:43:44&#34;,&#34;dateFormat&#34;:&#34;2020-03-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-外中断/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:78000,&#34;words&#34;:356,&#34;minutes&#34;:2},&#34;description&#34;:&#34;接口芯片和端口\n\n\n端口的读写只有in,out , 一个读一个写（CPU的视角来看）\n访问端口\nCPU 通过地址线 将 60h的信息发出\n通过控制线发出读命令\n端口所在的芯片将60h端口的数据通过数据总线将数据送入CPU\n\n外中断\n\n1. ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87%E5%92%8C%E7%AB%AF%E5%8F%A3\&#34;&gt;接口芯片和端口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%96%E4%B8%AD%E6%96%AD\&#34;&gt;外中断&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD\&#34;&gt;1. 可屏蔽中断&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%B8%8D%E5%8F%AF%E5%B1%8F%E8%94%BD%E7%BB%88%E7%AB%AF\&#34;&gt;2. 不可屏蔽终端&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#pc%E6%9C%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B\&#34;&gt;PC机键盘的处理过程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5\&#34;&gt;1. 键盘输入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%BC%95%E5%8F%919%E5%8F%B7%E4%B8%AD%E6%96%AD\&#34;&gt;2. 引发9号中断&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E6%89%A7%E8%A1%8C9%E5%8F%B7%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B\&#34;&gt;3. 执行9号中断例程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#int9-%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%94%AE%E7%9B%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B\&#34;&gt;int9 的基本键盘处理流程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B\&#34;&gt;编写中断例程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;第13章-int-指令\&#34;&gt;第13章 int 指令&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;属于内中断的一种&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;int指令\&#34;&gt;int指令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;指令格式&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int n&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;执行过程&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;获取中断类型码 &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;标志寄存器入栈，IF = 0，TF = 0&lt;/li&gt;\n&lt;li&gt;CS:IP 入栈&lt;/li&gt;\n&lt;li&gt;CS:IP 指向中断向量表中的中断地址&lt;/li&gt;\n&lt;li&gt;转去执行终端程序&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;供程序调用的中断例程\&#34;&gt;供程序调用的中断例程&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;int 和 iret 配合使用 类似 call 和 ret&lt;/li&gt;\n&lt;li&gt;注意把中断程序中用到的寄存器压到栈中，避免寄存器冲突&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;13-int指令&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;13-int指令&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-03-19 19:27:41&#34;,&#34;dateFormat&#34;:&#34;2020-03-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/13-int指令/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:27000,&#34;words&#34;:120,&#34;minutes&#34;:1},&#34;description&#34;:&#34;第13章 int 指令\n属于内中断的一种\nint指令\n\n\n指令格式\nint n\n\n\n执行过程\n\n获取中断类型码 n\n标志寄存器入栈，IF = 0，TF = 0\nCS:IP 入栈\nCS:IP 指向中断向量表中的中断地址\n转去执行终端程序\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC13%E7%AB%A0-int-%E6%8C%87%E4%BB%A4\&#34;&gt;第13章 int 指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#int%E6%8C%87%E4%BB%A4\&#34;&gt;int指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BE%9B%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B\&#34;&gt;供程序调用的中断例程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;mvc开发模式\&#34;&gt;MVC:开发模式&lt;/h1&gt;\n&lt;h2 id=\&#34;1-jsp演变历史\&#34;&gt;1. jsp演变历史&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;早期只有servlet，只能使用response输出标签数据，非常麻烦&lt;/li&gt;\n&lt;li&gt;后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作&lt;/li&gt;\n&lt;li&gt;再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;2mvc\&#34;&gt;2.MVC：&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;M：Model，模型。JavaBean&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;完成具体的业务操作，如：查询数据库，封装对象&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;V：View，视图。JSP&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;展示数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;C：Controller，控制器。Servlet&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;获取用户的输入&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;调用模型&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;将数据交给视图进行展示&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;优缺点\&#34;&gt;优缺点：&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;优点：\n&lt;ul&gt;\n&lt;li&gt;耦合性低，方便维护，可以利于分工协作&lt;/li&gt;\n&lt;li&gt;重用性高&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;缺点：\n&lt;ul&gt;\n&lt;li&gt;使得项目架构变得复杂，对开发人员要求高&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;el表达式\&#34;&gt;EL表达式&lt;/h1&gt;\n&lt;h2 id=\&#34;概念\&#34;&gt;概念：&lt;/h2&gt;\n&lt;p&gt;Expression Language 表达式语言&lt;/p&gt;\n&lt;h2 id=\&#34;作用\&#34;&gt;作用：&lt;/h2&gt;\n&lt;p&gt;替换和简化jsp页面中java代码的编写&lt;/p&gt;\n&lt;h2 id=\&#34;语法\&#34;&gt;语法：&lt;/h2&gt;\n&lt;p&gt;${表达式}&lt;/p&gt;\n&lt;h2 id=\&#34;注意\&#34;&gt;注意：&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;jsp默认支持el表达式的。如果要忽略el表达式\n&lt;ul&gt;\n&lt;li&gt;设置jsp中page指令中：isELIgnored=&amp;quot;true&amp;quot; 忽略当前jsp页面中所有的el表达式&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;\\${表达式}&lt;/strong&gt; ：忽略当前这个el表达式&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;使用\&#34;&gt;使用：&lt;/h2&gt;\n&lt;h3 id=\&#34;1-运算\&#34;&gt;1. 运算：&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;运算符：\n&lt;ol&gt;\n&lt;li&gt;算数运算符： + - * /(div) %(mod)算数运算符： + - * /(div) %(mod)算数运算符： + - * /(div) %(mod)&lt;/li&gt;\n&lt;li&gt;比较运算符： &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= == !=&lt;/li&gt;\n&lt;li&gt;逻辑运算符： &amp;amp;&amp;amp;(and) ||(or) !(not)&lt;/li&gt;\n&lt;li&gt;空运算符： empty\n&lt;ul&gt;\n&lt;li&gt;功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0&lt;/li&gt;\n&lt;li&gt;${empty list}:判断字符串、集合、数组对象是否为null或者长度为0&lt;/li&gt;\n&lt;li&gt;${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&amp;gt;0&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;2-获取值\&#34;&gt;2. 获取值&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;el表达式只能从域对象中获取值&lt;/li&gt;\n&lt;li&gt;语法：\n&lt;ol&gt;\n&lt;li&gt;${域名称.键名}：从指定域中获取指定键的值&lt;/li&gt;\n&lt;li&gt;域名称：\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;pageScope      --&amp;gt; pageContext&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;requestScope   --&amp;gt; request&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;sessionScope   --&amp;gt; session&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;applicationScope --&amp;gt; application（ServletContext）&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;举例：在request域中存储了name=张三&lt;/li&gt;\n&lt;li&gt;获取：${requestScope.name}&lt;/li&gt;\n&lt;li&gt;${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。&lt;/li&gt;\n&lt;li&gt;获取对象、List集合、Map集合的值&lt;/li&gt;\n&lt;li&gt;对象：${域名称.键名.属性名}&lt;/li&gt;\n&lt;li&gt;质上会去调用对象的getter方法&lt;/li&gt;\n&lt;li&gt;List集合：${域名称.键名[索引]}&lt;/li&gt;\n&lt;li&gt;Map集合：\n&lt;ol&gt;\n&lt;li&gt;${域名称.键名.key名称}&lt;/li&gt;\n&lt;li&gt;${域名称.键名[&amp;quot;key名称&amp;quot;]}&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;3-隐式对象\&#34;&gt;3. 隐式对象：&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;el表达式中有11个隐式对象&lt;/li&gt;\n&lt;li&gt;pageContext：&lt;/li&gt;\n&lt;li&gt;获取jsp其他八个内置对象\n&lt;ol&gt;\n&lt;li&gt;${pageContext.request.contextPath}：动态获取虚拟目录&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;jstl\&#34;&gt;JSTL&lt;/h1&gt;\n&lt;h2 id=\&#34;1-概念\&#34;&gt;1. 概念：&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;JavaServer Pages Tag Library  JSP标准标签库&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;是由Apache组织提供的开源的免费的jsp标签        &amp;lt;标签&amp;gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;2-作用\&#34;&gt;2.  作用：&lt;/h2&gt;\n&lt;p&gt;**用于简化和替换jsp页面上的java代码     **&lt;/p&gt;\n&lt;h2 id=\&#34;3-使用步骤\&#34;&gt;3. 使用步骤：&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;导入jstl相关jar包&lt;/li&gt;\n&lt;li&gt;引入标签库：taglib指令：  &amp;lt;%@ taglib %&amp;gt;&lt;/li&gt;\n&lt;li&gt;使用标签&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;4-常用的jstl标签\&#34;&gt;4 常用的JSTL标签&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;if:相当于java代码的if语句\n&lt;ol&gt;\n&lt;li&gt;属性：\n&lt;ol&gt;\n&lt;li&gt;test 必须属性，接受boolean表达式\n&lt;ol&gt;\n&lt;li&gt;如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容&lt;/li&gt;\n&lt;li&gt;一般情况下，test属性值会结合el表达式一起使用&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;注意：\n&lt;ol&gt;\n&lt;li&gt;c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;choose:相当于java代码的switch语句\n&lt;ol&gt;\n&lt;li&gt;使用choose标签声明                  相当于switch声明&lt;/li&gt;\n&lt;li&gt;使用when标签做判断                  相当于case&lt;/li&gt;\n&lt;li&gt;使用otherwise标签做其他情况的声明        相当于default&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;foreach:相当于java代码的for语句&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;三层架构软件设计架构\&#34;&gt;三层架构：软件设计架构&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;业务逻辑层：处理业务逻辑的。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;数据访问层：操作数据存储文件。&lt;/strong&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;案例用户信息列表展示\&#34;&gt;案例：用户信息列表展示&lt;/h1&gt;\n&#34;,&#34;fileName&#34;:&#34;MVC-EL-JSTL笔记&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MVC&amp;EL&amp;JSTL笔记&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MVC&#34;,&#34;slug&#34;:&#34;DZ-4Jb1Opr&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/DZ-4Jb1Opr/&#34;},{&#34;name&#34;:&#34;EL&#34;,&#34;slug&#34;:&#34;mRNZGGGLW0&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/mRNZGGGLW0/&#34;},{&#34;name&#34;:&#34;JSTL&#34;,&#34;slug&#34;:&#34;excCMVgd72&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/excCMVgd72/&#34;}],&#34;date&#34;:&#34;2020-03-10 20:10:30&#34;,&#34;dateFormat&#34;:&#34;2020-03-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/MVC-EL-JSTL笔记/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:214000,&#34;words&#34;:952,&#34;minutes&#34;:4},&#34;description&#34;:&#34;MVC:开发模式\n1. jsp演变历史\n\n早期只有servlet，只能使用response输出标签数据，非常麻烦\n后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#mvc%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F\&#34;&gt;MVC:开发模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-jsp%E6%BC%94%E5%8F%98%E5%8E%86%E5%8F%B2\&#34;&gt;1. jsp演变历史&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2mvc\&#34;&gt;2.MVC：&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%BC%BA%E7%82%B9\&#34;&gt;优缺点：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#el%E8%A1%A8%E8%BE%BE%E5%BC%8F\&#34;&gt;EL表达式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5\&#34;&gt;概念：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%9C%E7%94%A8\&#34;&gt;作用：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%AD%E6%B3%95\&#34;&gt;语法：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F\&#34;&gt;注意：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8\&#34;&gt;使用：&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E8%BF%90%E7%AE%97\&#34;&gt;1. 运算：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E8%8E%B7%E5%8F%96%E5%80%BC\&#34;&gt;2. 获取值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E9%9A%90%E5%BC%8F%E5%AF%B9%E8%B1%A1\&#34;&gt;3. 隐式对象：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jstl\&#34;&gt;JSTL&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%A6%82%E5%BF%B5\&#34;&gt;1. 概念：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%BD%9C%E7%94%A8\&#34;&gt;2.  作用：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4\&#34;&gt;3. 使用步骤：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E5%B8%B8%E7%94%A8%E7%9A%84jstl%E6%A0%87%E7%AD%BE\&#34;&gt;4 常用的JSTL标签&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84\&#34;&gt;三层架构：软件设计架构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A1%88%E4%BE%8B%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA\&#34;&gt;案例：用户信息列表展示&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;会话技术\&#34;&gt;会话技术&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;会话&lt;/strong&gt;：一次会话中包含多次请求和响应。\n&lt;ul&gt;\n&lt;li&gt;一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：在一次会话的范围内的多次请求间，共享数据&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;方式&lt;/strong&gt;：\n&lt;ol&gt;\n&lt;li&gt;客户端会话技术：&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;服务器端会话技术：&lt;strong&gt;Session&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;cookie\&#34;&gt;Cookie：&lt;/h2&gt;\n&lt;h3 id=\&#34;1-概念\&#34;&gt;1. 概念&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;客户端会话技术，将数据保存到客户端&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;2-快速入门\&#34;&gt;2. 快速入门：&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;创建Cookie对象，绑定数据&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;new Cookie(String name, String value) \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;发送Cookie对象&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;response.addCookie(Cookie cookie) \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;获取Cookie，拿到数据&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Cookie[]  request.getCookies()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3-实现原理\&#34;&gt;3.  实现原理&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;基于响应头set-cookie和请求头cookie实现&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;4-cookie的细节\&#34;&gt;4. cookie的细节&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;一次可不可以发送多个cookie?&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;可以&lt;/p&gt;\n&lt;p&gt;可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;cookie在浏览器中保存多长时间？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;默认情况下，当浏览器关闭后，Cookie数据被销毁&lt;/li&gt;\n&lt;li&gt;持久化存储：&lt;strong&gt;setMaxAge(int seconds)&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;正数: 将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效&lt;/li&gt;\n&lt;li&gt;负数：默认值&lt;/li&gt;\n&lt;li&gt;零：删除cookie信息&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;cookie能不能存中文？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;在tomcat 8 之前 cookie中不能直接存储中文数据。\n&lt;ul&gt;\n&lt;li&gt;需要将中文数据转码---一般采用URL编码(%E3)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;cookie共享问题？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？\n&lt;ul&gt;\n&lt;li&gt;默认情况下cookie不能共享&lt;/li&gt;\n&lt;li&gt;setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录\n&lt;ul&gt;\n&lt;li&gt;如果要共享，则可以将path设置为&amp;quot;/&amp;quot;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;不同的tomcat服务器间cookie共享问题？\n&lt;ul&gt;\n&lt;li&gt;setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享\n&lt;ul&gt;\n&lt;li&gt;setDomain(&amp;quot;.baidu.com&amp;quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;5-cookie的特点和作用\&#34;&gt;5. Cookie的特点和作用&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;cookie存储数据在客户端浏览器&lt;/li&gt;\n&lt;li&gt;浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;作用：\n&lt;ul&gt;\n&lt;li&gt;cookie一般用于存出少量的不太敏感的数据&lt;/li&gt;\n&lt;li&gt;在不登录的情况下，完成服务器对客户端的身份识别&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;6-案例记住上一次访问时间\&#34;&gt;6. 案例：记住上一次访问时间&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;需求：&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;分析：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;可以采用Cookie来完成&lt;/li&gt;\n&lt;li&gt;在服务器中的Servlet判断是否有一个名为lastTime的cookie\n&lt;ol&gt;\n&lt;li&gt;有：不是第一次访问\n&lt;ol&gt;\n&lt;li&gt;响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20&lt;/li&gt;\n&lt;li&gt;写回Cookie：lastTime=2018年6月10日11:50:01&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;没有：是第一次访问\n&lt;ol&gt;\n&lt;li&gt;响应数据：您好，欢迎您首次访问&lt;/li&gt;\n&lt;li&gt;写回Cookie：lastTime=2018年6月10日11:50:01&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;代码实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package cn.itcast.cookie;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n@WebServlet(&amp;quot;/CookieTest&amp;quot;)\npublic class CookieTest extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //设置响应的消息体的数据格式以及编码\n        response.setContentType(&amp;quot;text/html;charset=utf-8&amp;quot;);\n        //1.获取所有Cookie\n        Cookie[] cookies = request.getCookies();\n        boolean flag = false;//没有cookie为lastTime\n        //2.遍历cookie数组\n        if(cookies != null &amp;amp;&amp;amp; cookies.length &amp;gt; 0){\n            for (Cookie cookie : cookies) {\n                //3.获取cookie的名称\n                String name = cookie.getName();\n                //4.判断名称是否是：lastTime\n                if(&amp;quot;lastTime&amp;quot;.equals(name)){\n                    //有该Cookie，不是第一次访问\n\n                    flag = true;//有lastTime的cookie\n\n                    //设置Cookie的value\n                    //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie\n                    Date date  = new Date();\n                    SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);\n                    String str_date = sdf.format(date);\n                    System.out.println(&amp;quot;编码前：&amp;quot;+str_date);\n                    //URL编码\n                    str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);\n                    System.out.println(&amp;quot;编码后：&amp;quot;+str_date);\n                    cookie.setValue(str_date);\n                    //设置cookie的存活时间\n                    cookie.setMaxAge(60 * 60 * 24 * 30);//一个月\n                    response.addCookie(cookie);\n\n\n                    //响应数据\n                    //获取Cookie的value，时间\n                    String value = cookie.getValue();\n                    System.out.println(&amp;quot;解码前：&amp;quot;+value);\n                    //URL解码：\n                    value = URLDecoder.decode(value,&amp;quot;utf-8&amp;quot;);\n                    System.out.println(&amp;quot;解码后：&amp;quot;+value);\n                    response.getWriter().write(&amp;quot;&amp;lt;h1&amp;gt;欢迎回来，您上次访问时间为:&amp;quot;+value+&amp;quot;&amp;lt;/h1&amp;gt;&amp;quot;);\n\n\n                    break;\n\n                }\n            }\n        }\n        if(cookies == null || cookies.length == 0 || flag == false){\n            //没有，第一次访问\n\n            //设置Cookie的value\n            //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie\n            Date date  = new Date();\n            SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);\n            String str_date = sdf.format(date);\n            System.out.println(&amp;quot;编码前：&amp;quot;+str_date);\n            //URL编码\n            str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);\n            System.out.println(&amp;quot;编码后：&amp;quot;+str_date);\n\n            Cookie cookie = new Cookie(&amp;quot;lastTime&amp;quot;,str_date);\n            //设置cookie的存活时间\n            cookie.setMaxAge(60 * 60 * 24 * 30);//一个月\n            response.addCookie(cookie);\n\n            response.getWriter().write(&amp;quot;&amp;lt;h1&amp;gt;您好，欢迎您首次访问&amp;lt;/h1&amp;gt;&amp;quot;);\n        }\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request, response);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;session主菜\&#34;&gt;Session：主菜&lt;/h2&gt;\n&lt;h3 id=\&#34;概念\&#34;&gt;概念&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;快速入门\&#34;&gt;快速入门：&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;获取HttpSession对象：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;HttpSession session = request.getSession();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;使用HttpSession对象：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;   Object getAttribute(String name)  \n    void setAttribute(String name, Object value)\n    void removeAttribute(String name)  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;原理&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;Session的实现是依赖于Cookie的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;\n&lt;p&gt;细节：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;当客户端关闭后，服务器不关闭，两次获取session是否为同一个？&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;默认情况下。不是。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Cookie c = new Cookie(&amp;quot;JSESSIONID&amp;quot;,session.getId());\nc.setMaxAge(60*60);\nresponse.addCookie(c);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;客户端不关闭，服务器关闭后，两次获取的session是同一个吗？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作\n&lt;ul&gt;\n&lt;li&gt;session的钝化：\n&lt;ul&gt;\n&lt;li&gt;在服务器正常关闭之前，将session对象系列化到硬盘上&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;session的活化：\n&lt;ul&gt;\n&lt;li&gt;在服务器启动后，将session文件转化为内存中的session对象即可。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;session什么时候被销毁？&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;服务器关闭&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;session对象调用invalidate() 。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;session默认失效时间 30分钟&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;&amp;lt;session-config&amp;gt;\n        &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt;\n    &amp;lt;/session-config&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;session的特点&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;session用于存储一次会话的多次请求的数据，存在服务器端&lt;/li&gt;\n&lt;li&gt;session可以存储任意类型，任意大小的数据(&lt;strong&gt;类比Cookie&lt;/strong&gt;)&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;session与Cookie的区别：\n&lt;ol&gt;\n&lt;li&gt;session存储数据在服务器端，Cookie在客户端&lt;/li&gt;\n&lt;li&gt;session没有数据大小限制，Cookie有&lt;/li&gt;\n&lt;li&gt;session数据安全，Cookie相对于不安全&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;案例验证码\&#34;&gt;案例：验证码&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;案例需求：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;访问带有验证码的登录页面login.jsp&lt;/li&gt;\n&lt;li&gt;用户输入用户名，密码以及验证码。用户输入用户名，密码以及验证码。\n&lt;ul&gt;\n&lt;li&gt;如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误&lt;/li&gt;\n&lt;li&gt;如果验证码输入有误，跳转登录页面，提示：验证码错误&lt;/li&gt;\n&lt;li&gt;如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;代码实现：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;login&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsp\&#34;&gt;\n&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;\n&amp;lt;html&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;title&amp;gt;login&amp;lt;/title&amp;gt;\n\n    &amp;lt;script&amp;gt;\n        window.onload = function(){\n            document.getElementById(&amp;quot;img&amp;quot;).onclick = function(){\n                this.src=&amp;quot;/day16_cookie_war_exploded/CheckCodeServlet&amp;quot;+new Date().getTime();\n            }\n        }\n\n\n    &amp;lt;/script&amp;gt;\n\n    &amp;lt;style&amp;gt;\n        div{\n            color: red;\n        }\n\n    &amp;lt;/style&amp;gt;\n\n\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n\n&amp;lt;form action=&amp;quot;/day16_cookie_war_exploded/LoginServlet&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;\n    &amp;lt;table&amp;gt;\n        &amp;lt;tr&amp;gt;\n            &amp;lt;td&amp;gt;用户名&amp;lt;/td&amp;gt;\n            &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;\n        &amp;lt;/tr&amp;gt;\n        &amp;lt;tr&amp;gt;\n            &amp;lt;td&amp;gt;密码&amp;lt;/td&amp;gt;\n            &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;\n        &amp;lt;/tr&amp;gt;\n        &amp;lt;tr&amp;gt;\n            &amp;lt;td&amp;gt;验证码&amp;lt;/td&amp;gt;\n            &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;checkCode&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;\n        &amp;lt;/tr&amp;gt;\n        &amp;lt;tr&amp;gt;\n            &amp;lt;td colspan=&amp;quot;2&amp;quot;&amp;gt;&amp;lt;img id=&amp;quot;img&amp;quot; src=&amp;quot;/day16_cookie_war_exploded/CheckCodeServlet&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;\n        &amp;lt;/tr&amp;gt;\n        &amp;lt;tr&amp;gt;\n            &amp;lt;td colspan=&amp;quot;2&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;登录&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;\n        &amp;lt;/tr&amp;gt;\n    &amp;lt;/table&amp;gt;\n\n\n&amp;lt;/form&amp;gt;\n\n\n&amp;lt;div&amp;gt;&amp;lt;%=request.getAttribute(&amp;quot;cc_error&amp;quot;) == null ? &amp;quot;&amp;quot; : request.getAttribute(&amp;quot;cc_error&amp;quot;)%&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;div&amp;gt;&amp;lt;%=request.getAttribute(&amp;quot;login_error&amp;quot;) == null ? &amp;quot;&amp;quot; : request.getAttribute(&amp;quot;login_error&amp;quot;) %&amp;gt;&amp;lt;/div&amp;gt;\n\n\n&amp;lt;/body&amp;gt;\n&amp;lt;/html&amp;gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;success&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsp\&#34;&gt;\n&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;\n&amp;lt;html&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;title&amp;gt;success&amp;lt;/title&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n&amp;lt;h1&amp;gt;&amp;lt;%=request.getSession().getAttribute(&amp;quot;user&amp;quot;)%&amp;gt;,欢迎您&amp;lt;/h1&amp;gt;\n&amp;lt;/body&amp;gt;\n&amp;lt;/html&amp;gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;CheckCodeServlet&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package cn.itcast.servlet;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\n@WebServlet(&amp;quot;/CheckCodeServlet&amp;quot;)\npublic class CheckCodeServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        int width = 100;\n        int height = 50;\n\n        //1.创建一对象，在内存中图片(验证码图片对象)\n        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);\n\n\n        //2.美化图片\n        //2.1 填充背景色\n        Graphics g = image.getGraphics();//画笔对象\n        g.setColor(Color.PINK);//设置画笔颜色\n        g.fillRect(0,0,width,height);\n\n        //2.2画边框\n        g.setColor(Color.BLUE);\n        g.drawRect(0,0,width - 1,height - 1);\n\n        String str = &amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789&amp;quot;;\n        //生成随机角标\n        Random ran = new Random();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i &amp;lt;= 4; i++) {\n            int index = ran.nextInt(str.length());\n            //获取字符\n            char ch = str.charAt(index);//随机字符\n            sb.append(ch);\n\n            //2.3写验证码\n            g.drawString(ch+&amp;quot;&amp;quot;,width/5*i,height/2);\n        }\n        String checkCode_session = sb.toString();\n        //将验证码存入session\n        request.getSession().setAttribute(&amp;quot;checkCode_session&amp;quot;,checkCode_session);\n\n        //2.4画干扰线\n        g.setColor(Color.GREEN);\n\n        //随机生成坐标点\n\n        for (int i = 0; i &amp;lt; 10; i++) {\n            int x1 = ran.nextInt(width);\n            int x2 = ran.nextInt(width);\n\n            int y1 = ran.nextInt(height);\n            int y2 = ran.nextInt(height);\n            g.drawLine(x1,y1,x2,y2);\n        }\n\n\n        //3.将图片输出到页面展示\n        ImageIO.write(image,&amp;quot;jpg&amp;quot;,response.getOutputStream());\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request, response);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;LoginServlet&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package cn.itcast.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\n@WebServlet(&amp;quot;/LoginServlet&amp;quot;)\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //1.设置request编码\n        request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);\n        //2.获取参数\n        String username = request.getParameter(&amp;quot;username&amp;quot;);\n        String password = request.getParameter(&amp;quot;password&amp;quot;);\n        String checkCode = request.getParameter(&amp;quot;checkCode&amp;quot;);\n        //3.先获取生成的验证码\n        HttpSession session = request.getSession();\n        String checkCode_session = (String) session.getAttribute(&amp;quot;checkCode_session&amp;quot;);\n        //删除session中存储的验证码\n        session.removeAttribute(&amp;quot;checkCode_session&amp;quot;);\n        //3.先判断验证码是否正确\n        if(checkCode_session!= null &amp;amp;&amp;amp; checkCode_session.equalsIgnoreCase(checkCode)){\n            //忽略大小写比较\n            //验证码正确\n            //判断用户名和密码是否一致\n            if(&amp;quot;zhangsan&amp;quot;.equals(username) &amp;amp;&amp;amp; &amp;quot;123&amp;quot;.equals(password)){//需要调用UserDao查询数据库\n                //登录成功\n                //存储信息，用户信息\n                session.setAttribute(&amp;quot;user&amp;quot;,username);\n                //重定向到success.jsp\n                response.sendRedirect(request.getContextPath()+&amp;quot;/success.jsp&amp;quot;);\n            }else{\n                //登录失败\n                //存储提示信息到request\n                request.setAttribute(&amp;quot;login_error&amp;quot;,&amp;quot;用户名或密码错误&amp;quot;);\n                //转发到登录页面\n                request.getRequestDispatcher(&amp;quot;/login.jsp&amp;quot;).forward(request,response);\n            }\n\n\n        }else{\n            //验证码不一致\n            //存储提示信息到request\n            request.setAttribute(&amp;quot;cc_error&amp;quot;,&amp;quot;验证码错误&amp;quot;);\n            //转发到登录页面\n            request.getRequestDispatcher(&amp;quot;/login.jsp&amp;quot;).forward(request,response);\n\n        }\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request, response);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;jsp入门学习\&#34;&gt;JSP：入门学习&lt;/h1&gt;\n&lt;h2 id=\&#34;概念-2\&#34;&gt;概念：&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Java Server Pages： java服务器端页面&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;用于简化书写！！！&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;原理\&#34;&gt;原理&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;JSP本质上就是一个Servlet&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;jsp的脚本jsp定义java代码的方式\&#34;&gt;JSP的脚本：JSP定义Java代码的方式&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;&amp;lt;&lt;strong&gt;%&lt;/strong&gt;  代码 %&amp;gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。&lt;/li&gt;\n&lt;li&gt;&amp;lt;&lt;strong&gt;%!&lt;/strong&gt; 代码 %&amp;gt;：定义的java代码，在jsp转换后的java类的成员位置。&lt;/li&gt;\n&lt;li&gt;&amp;lt;%= 代码 %&amp;gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;jsp的内置对象\&#34;&gt;JSP的内置对象：&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;在jsp页面中不需要获取和创建，可以直接使用的对象&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;jsp一共有9个内置对象。&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;今天学习3个：&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;request&lt;/li&gt;\n&lt;li&gt;response&lt;/li&gt;\n&lt;li&gt;out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似\n&lt;ul&gt;\n&lt;li&gt;response.getWriter()和out.write()的区别：\n&lt;ul&gt;\n&lt;li&gt;在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。&lt;/li&gt;\n&lt;li&gt;response.getWriter()数据输出永远在out.write()之前&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;案例改造cookie案例\&#34;&gt;案例:改造Cookie案例&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;&amp;lt;%@ page import=&amp;quot;java.util.Date&amp;quot; %&amp;gt;\n&amp;lt;%@ page import=&amp;quot;java.text.SimpleDateFormat&amp;quot; %&amp;gt;\n&amp;lt;%@ page import=&amp;quot;java.net.URLEncoder&amp;quot; %&amp;gt;\n&amp;lt;%@ page import=&amp;quot;java.net.URLDecoder&amp;quot; %&amp;gt;\n&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;\n&amp;lt;html&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;title&amp;gt;home&amp;lt;/title&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n\n\n&amp;lt;%\n\n    //1.获取所有Cookie\n    Cookie[] cookies = request.getCookies();\n    boolean flag = false;//没有cookie为lastTime\n    //2.遍历cookie数组\n    if(cookies != null &amp;amp;&amp;amp; cookies.length &amp;gt; 0){\n        for (Cookie cookie : cookies) {\n            //3.获取cookie的名称\n            String name = cookie.getName();\n            //4.判断名称是否是：lastTime\n            if(&amp;quot;lastTime&amp;quot;.equals(name)){\n                //有该Cookie，不是第一次访问\n\n                flag = true;//有lastTime的cookie\n\n                //设置Cookie的value\n                //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie\n                Date date  = new Date();\n                SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);\n                String str_date = sdf.format(date);\n                System.out.println(&amp;quot;编码前：&amp;quot;+str_date);\n                //URL编码\n                str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);\n                System.out.println(&amp;quot;编码后：&amp;quot;+str_date);\n                cookie.setValue(str_date);\n                //设置cookie的存活时间\n                cookie.setMaxAge(60 * 60 * 24 * 30);//一个月\n                response.addCookie(cookie);\n\n\n                //响应数据\n                //获取Cookie的value，时间\n                String value = cookie.getValue();\n                System.out.println(&amp;quot;解码前：&amp;quot;+value);\n                //URL解码：\n                value = URLDecoder.decode(value,&amp;quot;utf-8&amp;quot;);\n                System.out.println(&amp;quot;解码后：&amp;quot;+value);\n%&amp;gt;\n&amp;lt;h1&amp;gt;欢迎回来，您上次访问时间为:&amp;lt;%=value%&amp;gt;&amp;lt;/h1&amp;gt;\n&amp;lt;input&amp;gt;\n\n&amp;lt;%\n\n\n\n                break;\n\n            }\n        }\n    }\n\n\n    if(cookies == null || cookies.length == 0 || flag == false){\n        //没有，第一次访问\n\n        //设置Cookie的value\n        //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie\n        Date date  = new Date();\n        SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH:mm:ss&amp;quot;);\n        String str_date = sdf.format(date);\n        System.out.println(&amp;quot;编码前：&amp;quot;+str_date);\n        //URL编码\n        str_date = URLEncoder.encode(str_date,&amp;quot;utf-8&amp;quot;);\n        System.out.println(&amp;quot;编码后：&amp;quot;+str_date);\n\n        Cookie cookie = new Cookie(&amp;quot;lastTime&amp;quot;,str_date);\n        //设置cookie的存活时间\n        cookie.setMaxAge(60 * 60 * 24 * 30);//一个月\n        response.addCookie(cookie);\n\n%&amp;gt;\n\n&amp;lt;h1&amp;gt;您好，欢迎您首次访问&amp;lt;/h1&amp;gt;\n&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;\n\n&amp;lt;%\n    }\n\n%&amp;gt;\n\n&amp;lt;input&amp;gt;\n\n&amp;lt;/body&amp;gt;\n&amp;lt;/html&amp;gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;指令\&#34;&gt;指令&lt;/h2&gt;\n&lt;h3 id=\&#34;作用\&#34;&gt;作用&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;作用：用于配置JSP页面，导入资源文件&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;格式\&#34;&gt;格式&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;&amp;lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&amp;gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;分类\&#34;&gt;分类&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;page      ： 配置JSP页面的&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;contentType：等同于response.setContentType()\n&lt;ol&gt;\n&lt;li&gt;设置响应体的mime类型以及字符集&lt;/li&gt;\n&lt;li&gt;设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;import：导包&lt;/li&gt;\n&lt;li&gt;errorPage：当前页面发生异常后，会自动跳转到指定的错误页面&lt;/li&gt;\n&lt;li&gt;isErrorPage：标识当前也是是否是错误页面。\n&lt;ul&gt;\n&lt;li&gt;true：是，可以使用内置对象exception&lt;/li&gt;\n&lt;li&gt;false：否。默认值。不可以使用内置对象exception&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;\n&lt;p&gt;include   ： 页面包含的。导入页面的资源文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsp\&#34;&gt;&amp;lt;%@include file=&amp;quot;top.jsp&amp;quot;%&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;taglib    ： 导入资源&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsp\&#34;&gt;&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;注释\&#34;&gt;注释&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;html注释：&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;&lt;!-- --&gt;:只能注释html代码片段&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;在网页源码中&lt;/li&gt;\n&lt;li&gt;jsp注释：推荐使用\n&lt;ol&gt;\n&lt;li&gt;&amp;lt;%-- --%&amp;gt;：可以注释所有&lt;/li&gt;\n&lt;li&gt;不会在网页源码中&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;内置对象\&#34;&gt;内置对象&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;在jsp页面中不需要创建，直接使用的对象&lt;/strong&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;变量名&lt;/th&gt;\n&lt;th&gt;真实类型&lt;/th&gt;\n&lt;th&gt;作用&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;pageContext&lt;/td&gt;\n&lt;td&gt;PageContext&lt;/td&gt;\n&lt;td&gt;当前页面共享数据，还可以获取其他八个内置对象&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;request&lt;/td&gt;\n&lt;td&gt;HttpServletRequest&lt;/td&gt;\n&lt;td&gt;一次请求访问的多个资源(转发)&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;session&lt;/td&gt;\n&lt;td&gt;HttpSession&lt;/td&gt;\n&lt;td&gt;一次会话的多个请求间&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;application&lt;/td&gt;\n&lt;td&gt;ServletContext&lt;/td&gt;\n&lt;td&gt;所有用户间共享数据&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;response&lt;/td&gt;\n&lt;td&gt;HttpServletResponse&lt;/td&gt;\n&lt;td&gt;响应对象&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;page&lt;/td&gt;\n&lt;td&gt;Object&lt;/td&gt;\n&lt;td&gt;当前页面(Servlet)的对象  this&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;out&lt;/td&gt;\n&lt;td&gt;JspWriter&lt;/td&gt;\n&lt;td&gt;输出对象，数据输出到页面上&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;config&lt;/td&gt;\n&lt;td&gt;ServletConfig&lt;/td&gt;\n&lt;td&gt;Servlet的配置对象&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;exception&lt;/td&gt;\n&lt;td&gt;Throwable&lt;/td&gt;\n&lt;td&gt;异常对象&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;Cookie-Session&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Cookie&amp;&amp;Session&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_Web&#34;,&#34;slug&#34;:&#34;AQ8apQMsNK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/AQ8apQMsNK/&#34;},{&#34;name&#34;:&#34;Cookie&amp;&amp;Session&#34;,&#34;slug&#34;:&#34;T0JYCSGJDl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/T0JYCSGJDl/&#34;},{&#34;name&#34;:&#34;JSP&#34;,&#34;slug&#34;:&#34;JTsrT2riJY&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/JTsrT2riJY/&#34;}],&#34;date&#34;:&#34;2020-03-08 17:02:26&#34;,&#34;dateFormat&#34;:&#34;2020-03-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/Cookie-Session/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;19 min read&#34;,&#34;time&#34;:1094000,&#34;words&#34;:3994,&#34;minutes&#34;:19},&#34;description&#34;:&#34;会话技术\n\n会话：一次会话中包含多次请求和响应。\n\n一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止\n\n\n功能：在一次会话的范围内的多次请求间，共享数据\n方式：\n\n客户端会话技术：Cookie\n服务器端会话技术：Se...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF\&#34;&gt;会话技术&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#cookie\&#34;&gt;Cookie：&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%A6%82%E5%BF%B5\&#34;&gt;1. 概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\&#34;&gt;2. 快速入门：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\&#34;&gt;3.  实现原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-cookie%E7%9A%84%E7%BB%86%E8%8A%82\&#34;&gt;4. cookie的细节&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-cookie%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BD%9C%E7%94%A8\&#34;&gt;5. Cookie的特点和作用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E6%A1%88%E4%BE%8B%E8%AE%B0%E4%BD%8F%E4%B8%8A%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4\&#34;&gt;6. 案例：记住上一次访问时间&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#session%E4%B8%BB%E8%8F%9C\&#34;&gt;Session：主菜&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5\&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\&#34;&gt;快速入门：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A1%88%E4%BE%8B%E9%AA%8C%E8%AF%81%E7%A0%81\&#34;&gt;案例：验证码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jsp%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0\&#34;&gt;JSP：入门学习&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5-2\&#34;&gt;概念：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E7%90%86\&#34;&gt;原理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#jsp%E7%9A%84%E8%84%9A%E6%9C%ACjsp%E5%AE%9A%E4%B9%89java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F\&#34;&gt;JSP的脚本：JSP定义Java代码的方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jsp%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\&#34;&gt;JSP的内置对象：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A1%88%E4%BE%8B%E6%94%B9%E9%80%A0cookie%E6%A1%88%E4%BE%8B\&#34;&gt;案例:改造Cookie案例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E4%BB%A4\&#34;&gt;指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%9C%E7%94%A8\&#34;&gt;作用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%BC%E5%BC%8F\&#34;&gt;格式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E7%B1%BB\&#34;&gt;分类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E9%87%8A\&#34;&gt;注释&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\&#34;&gt;内置对象&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;入门\&#34;&gt;入门&lt;/h1&gt;\n&lt;h1 id=\&#34;python变量和数据类型\&#34;&gt;Python变量和数据类型&lt;/h1&gt;\n&lt;h2 id=\&#34;1-python中数据类型\&#34;&gt;1. Python中数据类型&lt;/h2&gt;\n&lt;p&gt;计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;一、整数&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;100&lt;/code&gt;，&lt;code&gt;-8080&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt;，等等。&lt;/p&gt;\n&lt;p&gt;计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用&lt;code&gt;0x&lt;/code&gt;前缀和0-9，a-f表示，例如：&lt;code&gt;0xff00&lt;/code&gt;，&lt;code&gt;0xa5b4c3d2&lt;/code&gt;，等等。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;二、浮点数&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10&lt;sup&gt;9和12.3x10&lt;/sup&gt;8是相等的。浮点数可以用数学写法，如&lt;code&gt;1.23&lt;/code&gt;，&lt;code&gt;3.14&lt;/code&gt;，&lt;code&gt;-9.01&lt;/code&gt;，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是&lt;strong&gt;1.23e9&lt;/strong&gt;，或者&lt;strong&gt;12.3e8&lt;/strong&gt;，0.000012可以写成&lt;strong&gt;1.2e-5&lt;/strong&gt;，等等。&lt;/p&gt;\n&lt;p&gt;整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;三、字符串&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;字符串是以&lt;code&gt;&#39;&#39;&lt;/code&gt;或&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;括起来的任意文本，比如**&#39;abc&#39;&lt;strong&gt;，&lt;/strong&gt;&amp;quot;xyz&amp;quot;&lt;strong&gt;等等。请注意，&lt;/strong&gt;&#39;&#39;&lt;strong&gt;或&lt;/strong&gt;&amp;quot;&amp;quot;**本身只是一种表示方式，不是字符串的一部分，因此，字符串&lt;code&gt;&#39;abc&#39;&lt;/code&gt;只有&lt;code&gt;a，b，c&lt;/code&gt;这3个字符。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;四、布尔值&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;布尔值和布尔代数的表示完全一致，一个布尔值只有&lt;code&gt;True&lt;/code&gt;、&lt;code&gt;False&lt;/code&gt;两种值，要么是&lt;code&gt;True&lt;/code&gt;，要么是&lt;code&gt;False&lt;/code&gt;，在Python中，可以直接用&lt;code&gt;True&lt;/code&gt;、&lt;code&gt;False&lt;/code&gt;表示布尔值（请注意大小写），也可以通过布尔运算计算出来。&lt;/p&gt;\n&lt;p&gt;布尔值可以用&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;not&lt;/code&gt;运算。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;and&lt;/code&gt;运算是与运算，只有所有都为 True，and运算结果才是 True。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;or&lt;/code&gt;运算是或运算，只要其中有一个为 True，or 运算结果就是 True。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;not&lt;/code&gt;运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;五、空值&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;空值是Python里一个特殊的值，用&lt;code&gt;None&lt;/code&gt;表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。&lt;/p&gt;\n&lt;p&gt;此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到&lt;/p&gt;\n&lt;h2 id=\&#34;2-python之print语句\&#34;&gt;2. Python之print语句&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;print&lt;/strong&gt;语句可以向屏幕上输出指定的文字。比如输出&#39;hello, world&#39;，用代码实现如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print &#39;hello, world&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;1.当我们在Python交互式环境下编写代码时，&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;是Python解释器的提示符，不是代码的一部分。&lt;/p&gt;\n&lt;p&gt;2.当我们在文本编辑器中编写代码时，千万不要自己添加 &amp;gt;&amp;gt;&amp;gt;。&lt;/p&gt;\n&lt;p&gt;print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print &#39;The quick brown fox&#39;, &#39;jumps over&#39;, &#39;the lazy dog&#39;\nThe quick brown fox jumps over the lazy dog\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：&lt;/p&gt;\n&lt;p&gt;{% asset_img 54055502000179c205060086.jpg %}&lt;/p&gt;\n&lt;p&gt;print也可以打印整数，或者计算结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print 300\n300    #运行结果\n&amp;gt;&amp;gt;&amp;gt; print 100 + 200\n300    #运行结果\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因此，我们可以把计算100 + 200的结果打印得更漂亮一点：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print &#39;100 + 200 =&#39;, 100 + 200\n100 + 200 = 300     #运行结果\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 对于100 + 200，Python解释器自动计算出结果300，但是，&#39;100 + 200 =&#39;是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。&lt;/p&gt;\n&lt;h2 id=\&#34;3-python的注释\&#34;&gt;3. Python的注释&lt;/h2&gt;\n&lt;p&gt;任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。&lt;/p&gt;\n&lt;p&gt;Python的注释以&lt;code&gt;#&lt;/code&gt;开头，后面的文字直到行尾都算注释&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;# 这一行全部都是注释...\nprint &#39;hello&#39; # 这也是注释\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;# 暂时不想运行下面一行代码:\n# print &#39;hello, python.&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;4-python中什么是变量\&#34;&gt;4. Python中什么是变量&lt;/h2&gt;\n&lt;p&gt;在Python中，变量的概念基本上和初中代数的方程变量是一致的。&lt;/p&gt;\n&lt;p&gt;例如，对于方程式 &lt;code&gt;y=x*x&lt;/code&gt;，&lt;code&gt;x&lt;/code&gt;就是变量。当&lt;code&gt;x=2&lt;/code&gt;时，计算结果是&lt;code&gt;4&lt;/code&gt;，当&lt;code&gt;x=5&lt;/code&gt;时，计算结果是&lt;code&gt;25&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。&lt;/p&gt;\n&lt;p&gt;在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;a = 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;变量&lt;code&gt;a&lt;/code&gt;是一个整数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;t_007 = &#39;T007&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;变量&lt;code&gt;t_007&lt;/code&gt;是一个字符串。&lt;/p&gt;\n&lt;p&gt;在Python中，等号&lt;code&gt;=&lt;/code&gt;是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;a = 123    # a是整数\nprint a\na = &#39;imooc&#39;   # a变为字符串\nprint a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。&lt;/p&gt;\n&lt;p&gt;静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;int a = 123; // a是整数类型变量\na = &amp;quot;mooc&amp;quot;; // 错误：不能把字符串赋给整型变量\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;和静态语言相比，动态语言更灵活，就是这个原因。&lt;/p&gt;\n&lt;p&gt;请不要把赋值语句的等号等同于数学的等号。比如下面的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;x = 10\nx = x + 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。&lt;/p&gt;\n&lt;p&gt;最后，理解变量在计算机内存中的表示也非常重要。当我们写：&lt;code&gt;a = &#39;ABC&#39;&lt;/code&gt;时，Python解释器干了两件事情：&lt;/p&gt;\n&lt;p&gt;\\1. 在内存中创建了一个&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;的字符串；&lt;/p&gt;\n&lt;p&gt;\\2. 在内存中创建了一个名为&lt;code&gt;a&lt;/code&gt;的变量，并把它指向&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;a = &#39;ABC&#39;\nb = a\na = &#39;XYZ&#39;\nprint b\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最后一行打印出变量b的内容到底是&#39;ABC&#39;呢还是&#39;XYZ&#39;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&#39;XYZ&#39;，但实际上b的值是&#39;ABC&#39;，让我们一行一行地执行代码，就可以看到到底发生了什么事：&lt;/p&gt;\n&lt;p&gt;执行&lt;code&gt;a = &#39;ABC&#39;&lt;/code&gt;，解释器创建了字符串  &#39;ABC&#39;和变量 a，并把a指向 &#39;ABC&#39;：&lt;/p&gt;\n&lt;p&gt;{% asset_img 540581030001c11202360058.jpg %}&lt;/p&gt;\n&lt;p&gt;执行&lt;code&gt;b = a&lt;/code&gt;，解释器创建了变量 b，并把b指向 a 指向的字符串&#39;ABC&#39;：&lt;/p&gt;\n&lt;p&gt;{% asset_img 53fc5e880001399902360084.jpg %}&lt;/p&gt;\n&lt;p&gt;执行&lt;code&gt;a = &#39;XYZ&#39;&lt;/code&gt;，解释器创建了字符串&#39;XYZ&#39;，并把a的指向改为&#39;XYZ&#39;，但b并没有更改：&lt;/p&gt;\n&lt;p&gt;{% asset_img 53fc5e9f0001b98d02360090.jpg %}&lt;/p&gt;\n&lt;p&gt;所以，最后打印变量&lt;code&gt;b&lt;/code&gt;的结果自然是&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;了。&lt;/p&gt;\n&lt;h2 id=\&#34;5python中定义字符串\&#34;&gt;5.Python中定义字符串&lt;/h2&gt;\n&lt;p&gt;前面我们讲解了什么是字符串。字符串可以用&lt;code&gt;&#39;&#39;&lt;/code&gt;或者&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;括起来表示。&lt;/p&gt;\n&lt;p&gt;如果字符串本身包含&lt;code&gt;&#39;&lt;/code&gt;怎么办？比如我们要表示字符串&lt;code&gt;I&#39;m OK&lt;/code&gt;，这时，可以用&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt;括起来表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;quot;I&#39;m OK&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;类似的，如果字符串包含&lt;code&gt;&amp;quot;&lt;/code&gt;，我们就可以用&lt;code&gt;&#39; &#39;&lt;/code&gt;括起来表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&#39;Learn &amp;quot;Python&amp;quot; in imooc&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果字符串既包含&lt;code&gt;&#39;&lt;/code&gt;又包含&lt;code&gt;&amp;quot;&lt;/code&gt;怎么办？&lt;/p&gt;\n&lt;p&gt;这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用&lt;code&gt;\\&lt;/code&gt;进行转义。&lt;/p&gt;\n&lt;p&gt;要表示字符串 &lt;code&gt;Bob said &amp;quot;I&#39;m OK&amp;quot;.&lt;/code&gt;&lt;br&gt;\n由于 &#39; 和 &amp;quot; 会引起歧义，因此，我们在它前面插入一个&lt;code&gt;\\&lt;/code&gt;表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&#39;Bob said \\&amp;quot;I\\&#39;m OK\\&amp;quot;.&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;**注意：**转义字符 \\ 不计入字符串的内容中。&lt;/p&gt;\n&lt;p&gt;常用的转义字符还有：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;\\n 表示换行\n\\t 表示一个制表符\n\\\\ 表示 \\ 字符本身\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;6python中raw字符串与多行字符串\&#34;&gt;6.Python中raw字符串与多行字符串&lt;/h2&gt;\n&lt;p&gt;如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀&lt;code&gt;r&lt;/code&gt;，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;r&#39;\\(~_~)/ \\(~_~)/&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是&lt;code&gt;r&#39;...&#39;&lt;/code&gt;表示法不能表示多行字符串，也不能表示包含&lt;code&gt;&#39;&lt;/code&gt;和 &lt;code&gt;&amp;quot;&lt;/code&gt;的字符串（为什么？）&lt;/p&gt;\n&lt;p&gt;如果要表示多行字符串，可以用&lt;code&gt;&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&#39;&#39;&#39;Line 1\nLine 2\nLine 3&#39;&#39;&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面这个字符串的表示方法和下面的是完全一样的：&lt;/p&gt;\n&lt;p&gt;&#39;Line 1\\nLine 2\\nLine 3&#39;&lt;/p&gt;\n&lt;p&gt;还可以在多行字符串前面添加&lt;code&gt;r&lt;/code&gt;，把这个多行字符串也变成一个raw字符串：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;r&#39;&#39;&#39;Python is created by &amp;quot;Guido&amp;quot;.\nIt is free and easy to learn.\nLet&#39;s start learn Python in imooc!&#39;&#39;&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;7-python中unicode字符串\&#34;&gt;7. Python中Unicode字符串&lt;/h2&gt;\n&lt;p&gt;字符串还有一个编码问题。&lt;/p&gt;\n&lt;p&gt;因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。&lt;/p&gt;\n&lt;p&gt;如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。&lt;/p&gt;\n&lt;p&gt;类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。&lt;/p&gt;\n&lt;p&gt;Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。&lt;/p&gt;\n&lt;p&gt;因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串&#39;ABC&#39;在Python内部都是ASCII编码的。&lt;/p&gt;\n&lt;p&gt;Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u&#39;...&#39;表示，比如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;print u&#39;中文&#39;\n中文\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 不加 u ，中文就不能正常显示。&lt;/p&gt;\n&lt;p&gt;Unicode字符串除了多了一个&lt;code&gt;u&lt;/code&gt;之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;转义：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;u&#39;中文\\n日文\\n韩文&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;多行：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;u&#39;&#39;&#39;第一行\n第二行&#39;&#39;&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;raw+多行：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;ur&#39;&#39;&#39;Python的Unicode字符串支持&amp;quot;中文&amp;quot;,\n&amp;quot;日文&amp;quot;,\n&amp;quot;韩文&amp;quot;等多种语言&#39;&#39;&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;# -*- coding: utf-8 -*-\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为... 并选择UTF-8格式保存。&lt;/p&gt;\n&lt;h2 id=\&#34;python中整数和浮点数\&#34;&gt;Python中整数和浮点数&lt;/h2&gt;\n&lt;p&gt;Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。&lt;/p&gt;\n&lt;p&gt;基本的运算：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;1 + 2 + 3   # ==&amp;gt; 6\n4 * 5 - 6   # ==&amp;gt; 14\n7.5 / 8 + 2.1   # ==&amp;gt; 3.0375\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;(1 + 2) * 3    # ==&amp;gt; 9\n(2.2 + 3.3) / (1.5 * (9 - 0.3))    # ==&amp;gt; 0.42145593869731807\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;1 + 2    # ==&amp;gt; 整数 3\n1.0 + 2.0    # ==&amp;gt; 浮点数 3.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是整数和浮点数混合运算的结果就变成浮点数了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;1 + 2.0    # ==&amp;gt; 浮点数 3.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;为什么要区分整数运算和浮点数运算呢？这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如&lt;code&gt;0.1&lt;/code&gt;换成二进制表示就是无限循环小数。&lt;/p&gt;\n&lt;p&gt;那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;11 / 4    # ==&amp;gt; 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;11 % 4    # ==&amp;gt; 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;11.0 / 4    # ==&amp;gt; 2.75\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;8-python中布尔类型\&#34;&gt;8. Python中布尔类型&lt;/h2&gt;\n&lt;p&gt;我们已经了解了Python支持布尔类型的数据，布尔类型只有&lt;code&gt;True&lt;/code&gt;和&lt;code&gt;False&lt;/code&gt;两种值，但是布尔类型有以下几种运算：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;与运算&lt;/strong&gt;：只有两个布尔值都为 True 时，计算结果才为 True。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;True and True   # ==&amp;gt; True\nTrue and False   # ==&amp;gt; False\nFalse and True   # ==&amp;gt; False\nFalse and False   # ==&amp;gt; False\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;或运算&lt;/strong&gt;：只要有一个布尔值为 True，计算结果就是 True。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;True or True   # ==&amp;gt; True\nTrue or False   # ==&amp;gt; True\nFalse or True   # ==&amp;gt; True\nFalse or False   # ==&amp;gt; False\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;非运算&lt;/strong&gt;：把True变为False，或者把False变为True：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;not True   # ==&amp;gt; False\nnot False   # ==&amp;gt; True\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。&lt;/p&gt;\n&lt;p&gt;在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;a = True\nprint a and &#39;a=T&#39; or &#39;a=F&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;计算结果不是布尔类型，而是字符串 &#39;a=T&#39;，这是为什么呢？&lt;/p&gt;\n&lt;p&gt;因为Python把&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;空字符串&#39;&#39;&lt;/code&gt;和&lt;code&gt;None&lt;/code&gt;看成 False，其他数值和非空字符串都看成 True，所以：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;True and &#39;a=T&#39; 计算结果是 &#39;a=T&#39;\n继续计算 &#39;a=T&#39; or &#39;a=F&#39; 计算结果还是 &#39;a=T&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;在计算&lt;code&gt;a and b&lt;/code&gt;时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在计算&lt;code&gt;a or b&lt;/code&gt;时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。&lt;/p&gt;\n&lt;h1 id=\&#34;list和tuple类型\&#34;&gt;List和Tuple类型&lt;/h1&gt;\n&lt;h2 id=\&#34;1-python创建list\&#34;&gt;1. Python创建list&lt;/h2&gt;\n&lt;p&gt;Python内置的一种数据类型是列表：&lt;code&gt;list&lt;/code&gt;。list是一种有序的集合，可以随时添加和删除其中的元素。&lt;/p&gt;\n&lt;p&gt;比如，列出班里所有同学的名字，就可以用一个list表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]\n[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。&lt;/p&gt;\n&lt;p&gt;构造list非常简单，按照上面的代码，直接用&lt;code&gt;[ ]&lt;/code&gt;把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]\n&amp;gt;&amp;gt;&amp;gt; classmates # 打印classmates变量的内容\n[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Michael&#39;, 100, True]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一个元素也没有的list，就是空list：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; empty_list = []\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-python按照索引访问list\&#34;&gt;2. Python按照索引访问list&lt;/h2&gt;\n&lt;p&gt;由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;需要特别注意的是&lt;/strong&gt;，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。&lt;/p&gt;\n&lt;p&gt;因此，要打印第一名同学的名字，用 L[0]:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[0]\nAdam\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;要打印第二名同学的名字，用 L[1]:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[1]\nLisa\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;要打印第三名同学的名字，用 L[2]:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[2]\nBart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;要打印第四名同学的名字，用 L[3]:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[3]\nTraceback (most recent call last):\n  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;\nIndexError: list index out of range\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。&lt;/p&gt;\n&lt;p&gt;所以，使用索引时，&lt;strong&gt;&lt;mark&gt;千万注意不要越界&lt;/mark&gt;&lt;/strong&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;3-python之倒序访问list\&#34;&gt;3.  Python之倒序访问list&lt;/h2&gt;\n&lt;p&gt;我们还是用一个list按分数从高到低表示出班里的3个同学：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这时，老师说，请分数最低的同学站出来。&lt;/p&gt;\n&lt;p&gt;要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[2]\nBart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有没有更简单的方法？&lt;/p&gt;\n&lt;p&gt;有！&lt;/p&gt;\n&lt;p&gt;Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[-1]\nBart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Bart同学表示躺枪。&lt;/p&gt;\n&lt;p&gt;类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print L[-2]\nLisa\n&amp;gt;&amp;gt;&amp;gt; print L[-3]\nAdam\n&amp;gt;&amp;gt;&amp;gt; print L[-4]\nTraceback (most recent call last):\n  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;\nIndexError: list index out of range\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。&lt;/p&gt;\n&lt;p&gt;使用倒序索引时，也要注意**&lt;mark&gt;不要越界&lt;/mark&gt;**。&lt;/p&gt;\n&lt;h2 id=\&#34;4-python之添加新元素\&#34;&gt;4. Python之添加新元素&lt;/h2&gt;\n&lt;p&gt;现在，班里有3名同学：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？&lt;/p&gt;\n&lt;p&gt;第一个办法是用 list 的&lt;code&gt;append()&lt;/code&gt;方法，把新同学追加到 list 的末尾：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&amp;gt;&amp;gt;&amp;gt; L.append(&#39;Paul&#39;)\n&amp;gt;&amp;gt;&amp;gt; print L\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;**&lt;mark&gt;append()&lt;/mark&gt;**总是把新的元素添加到 list 的尾部。&lt;/p&gt;\n&lt;p&gt;如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？&lt;/p&gt;\n&lt;p&gt;方法是用list的 **&lt;mark&gt;insert()&lt;/mark&gt;**方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&amp;gt;&amp;gt;&amp;gt; L.insert(0, &#39;Paul&#39;)\n&amp;gt;&amp;gt;&amp;gt; print L\n[&#39;Paul&#39;, &#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;L.insert(0, &#39;Paul&#39;)&lt;/strong&gt; 的意思是，&#39;Paul&#39;将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。&lt;/p&gt;\n&lt;h2 id=\&#34;5-python从list删除元素\&#34;&gt;5. Python从list删除元素&lt;/h2&gt;\n&lt;p&gt;Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？&lt;/p&gt;\n&lt;p&gt;如果Paul同学排在最后一个，我们可以用list的&lt;code&gt;pop()&lt;/code&gt;方法删除：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\n&amp;gt;&amp;gt;&amp;gt; L.pop()\n&#39;Paul&#39;\n&amp;gt;&amp;gt;&amp;gt; print L\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;**&lt;mark&gt;pop()&lt;/mark&gt;**方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 &#39;Paul&#39;。&lt;/p&gt;\n&lt;p&gt;如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Paul&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用**&lt;mark&gt;&lt;code&gt;pop(2)&lt;/code&gt;&lt;/mark&gt;**把Paul删掉：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L.pop(2)\n&#39;Paul&#39;\n&amp;gt;&amp;gt;&amp;gt; print L\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;6-python中替换元素\&#34;&gt;6.  Python中替换元素&lt;/h2&gt;\n&lt;p&gt;假设现在班里仍然是3名同学：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。&lt;/p&gt;\n&lt;p&gt;另一个办法是直接用Paul把Bart给替换掉：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[2] = &#39;Paul&#39;\n&amp;gt;&amp;gt;&amp;gt; print L\nL = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Paul&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。&lt;/p&gt;\n&lt;p&gt;由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[-1] = &#39;Paul&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;7-python之创建tuple\&#34;&gt;7. Python之创建tuple&lt;/h2&gt;\n&lt;p&gt;tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，&lt;mark&gt;但是，tuple一旦创建完毕，就不能修改了&lt;/mark&gt;。&lt;/p&gt;\n&lt;p&gt;同样是表示班里同学的名称，用tuple表示如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;创建tuple和创建list唯一不同之处是用**&lt;code&gt;( )&lt;/code&gt;替代了&lt;code&gt;[ ]&lt;/code&gt;。**&lt;/p&gt;\n&lt;p&gt;现在，这个&lt;code&gt;t&lt;/code&gt;就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。&lt;/p&gt;\n&lt;p&gt;获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t[0] = &#39;Paul&#39;\nTraceback (most recent call last):\n  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;\nTypeError: &#39;tuple&#39; object does not support item assignment\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;8-python之创建单元素tuple\&#34;&gt;8. Python之创建单元素tuple&lt;/h2&gt;\n&lt;p&gt;tuple和list一样，可以包含 0 个、1个和任意多个元素。&lt;/p&gt;\n&lt;p&gt;包含多个元素的 tuple，前面我们已经创建过了。&lt;/p&gt;\n&lt;p&gt;包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = ()\n&amp;gt;&amp;gt;&amp;gt; print t\n()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;创建包含1个元素的 tuple 呢？来试试：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (1)\n&amp;gt;&amp;gt;&amp;gt; print t\n1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;好像哪里不对！t 不是 tuple ，而是整数1。&lt;strong&gt;为什么&lt;/strong&gt;呢？&lt;/p&gt;\n&lt;p&gt;因为&lt;code&gt;()&lt;/code&gt;既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。&lt;/p&gt;\n&lt;p&gt;正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (1,)\n&amp;gt;&amp;gt;&amp;gt; print t\n(1,)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。&lt;/p&gt;\n&lt;p&gt;多元素 tuple 加不加这个额外的“,”效果是一样的：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (1, 2, 3,)\n&amp;gt;&amp;gt;&amp;gt; print t\n(1, 2, 3)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;9-python之可变的tuple\&#34;&gt;9. Python之“可变”的tuple&lt;/h2&gt;\n&lt;p&gt;前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;到 t 有 3 个元素：&lt;strong&gt;&#39;a&#39;，&#39;b&#39;&lt;strong&gt;和一个list：&lt;/strong&gt;[&#39;A&#39;, &#39;B&#39;]&lt;/strong&gt;。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = t[2]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后，我们把list的两个元素改一改：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[0] = &#39;X&#39;\n&amp;gt;&amp;gt;&amp;gt; L[1] = &#39;Y&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;再看看tuple的内容：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print t\n(&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;不是说tuple一旦定义后就不可变了吗？怎么现在又变了？&lt;/p&gt;\n&lt;p&gt;别急，我们先看看定义的时候tuple包含的3个元素：&lt;/p&gt;\n&lt;p&gt;{% asset_img 540538d400010f4603500260.jpg %}&lt;/p&gt;\n&lt;p&gt;当我们把list的元素**&#39;A&#39;和&#39;B&#39;&lt;strong&gt;修改为&lt;/strong&gt;&#39;X&#39;和&#39;Y&#39;**后，tuple变为：&lt;/p&gt;\n&lt;p&gt;{% asset_img 540538e9000110c003500260.jpg %}&lt;br&gt;\n表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。&lt;/p&gt;\n&lt;p&gt;tuple一开始指向的list并没有改成别的list，所以，tuple所谓的**“不变”&lt;strong&gt;是说，tuple的每个元素，指向永远不变。即&lt;/strong&gt;指向&#39;a&#39;，就不能改成指向&#39;b&#39;**，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！&lt;/p&gt;\n&lt;p&gt;理解了**“指向不变”**后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。&lt;/p&gt;\n&lt;h1 id=\&#34;条件判断和循环\&#34;&gt;条件判断和循环&lt;/h1&gt;\n&lt;h2 id=\&#34;1-python之if语句\&#34;&gt;1. Python之if语句&lt;/h2&gt;\n&lt;p&gt;计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。&lt;/p&gt;\n&lt;p&gt;比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;age = 20\nif age &amp;gt;= 18:\n    print &#39;your age is&#39;, age\n    print &#39;adult&#39;\nprint &#39;END&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。&lt;/p&gt;\n&lt;p&gt;缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: if 语句后接表达式，然后用&lt;code&gt;:&lt;/code&gt;表示代码块开始。&lt;/p&gt;\n&lt;p&gt;如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; age = 20\n&amp;gt;&amp;gt;&amp;gt; if age &amp;gt;= 18:\n...     print &#39;your age is&#39;, age\n...     print &#39;adult&#39;\n...\nyour age is 20\nadult\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-python之-if-else\&#34;&gt;2. Python之 if-else&lt;/h2&gt;\n&lt;p&gt;当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if age &amp;gt;= 18:\n    print &#39;adult&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果我们想判断年龄在18岁以下时，打印出 &#39;teenager&#39;，怎么办？&lt;/p&gt;\n&lt;p&gt;方法是再写一个 if:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if age &amp;lt; 18:\n    print &#39;teenager&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;或者用 not 运算：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if not age &amp;gt;= 18:\n    print &#39;teenager&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;细心的同学可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if ... else ... 语句把它们统一起来：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if age &amp;gt;= 18:\n    print &#39;adult&#39;\nelse:\n    print &#39;teenager&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;利用 if ... else ... 语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;mark&gt;注意&lt;/mark&gt;:&lt;/strong&gt; else 后面有个“:”。&lt;/p&gt;\n&lt;h2 id=\&#34;3-python之-if-elif-else\&#34;&gt;3. Python之 if-elif-else&lt;/h2&gt;\n&lt;p&gt;有的时候，一个 if ... else ... 还不够用。比如，根据年龄的划分：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;条件1：18岁或以上：adult\n条件2：6岁或以上：teenager\n条件3：6岁以下：kid\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们可以用一个 if age &amp;gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &amp;gt;= 6 来判断是否符合条件2，否则，执行条件3：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if age &amp;gt;= 18:\n    print &#39;adult&#39;\nelse:\n    if age &amp;gt;= 6:\n        print &#39;teenager&#39;\n    else:\n        print &#39;kid&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样写出来，我们就得到了一个两层嵌套的 if ... else ... 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if age &amp;gt;= 18:\n    print &#39;adult&#39;\nelse:\n    if age &amp;gt;= 6:\n        print &#39;teenager&#39;\n    else:\n        if age &amp;gt;= 3:\n            print &#39;kid&#39;\n        else:\n            print &#39;baby&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种缩进只会越来越多，代码也会越来越难看。&lt;/p&gt;\n&lt;p&gt;要避免嵌套结构的 if ... else ...，我们可以用 if ... 多个elif ... else ... 的结构，一次写完所有的规则：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if age &amp;gt;= 18:\n    print &#39;adult&#39;\nelif age &amp;gt;= 6:\n    print &#39;teenager&#39;\nelif age &amp;gt;= 3:\n    print &#39;kid&#39;\nelse:\n    print &#39;baby&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;特别注意:&lt;/strong&gt; 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。&lt;/p&gt;\n&lt;h3 id=\&#34;请思考下面的代码\&#34;&gt;请思考下面的代码：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;age = 8\nif age &amp;gt;= 6:\n    print &#39;teenager&#39;\nelif age &amp;gt;= 18:\n    print &#39;adult&#39;\nelse:\n    print &#39;kid&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当 age = 8 时，结果正确，但 age = 20 时，为什么没有打印出 adult？&lt;/p&gt;\n&lt;p&gt;如果要修复，应该如何修复？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;交换      print &#39;teenager&#39;     print &#39;adult&#39;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;4-python之-for循环\&#34;&gt;4. Python之 for循环&lt;/h2&gt;\n&lt;p&gt;list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\nprint L[0]\nprint L[1]\nprint L[2]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。&lt;/p&gt;\n&lt;p&gt;这时，循环就派上用场了。&lt;/p&gt;\n&lt;p&gt;Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\nfor name in L:\n    print name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。&lt;/p&gt;\n&lt;p&gt;这样一来，遍历一个list或tuple就非常容易了。&lt;/p&gt;\n&lt;h2 id=\&#34;5-python之-while循环\&#34;&gt;5. Python之 while循环&lt;/h2&gt;\n&lt;p&gt;和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。&lt;/p&gt;\n&lt;p&gt;比如要从 0 开始打印不大于 N 的整数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;N = 10\nx = 0\nwhile x &amp;lt; N:\n    print x\n    x = x + 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;while循环每次先判断 x &amp;lt; N，如果为True，则执行循环体的代码块，否则，退出循环。&lt;/p&gt;\n&lt;p&gt;在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &amp;lt; N 不成立而退出循环。&lt;/p&gt;\n&lt;p&gt;如果没有这一个语句，&lt;strong&gt;while循环在判断 x &amp;lt; N 时总是为True&lt;/strong&gt;，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。&lt;/p&gt;\n&lt;h2 id=\&#34;6-python之-break退出循环\&#34;&gt;6. Python之 break退出循环&lt;/h2&gt;\n&lt;p&gt;用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。&lt;/p&gt;\n&lt;p&gt;比如计算1至100的整数和，我们用while来实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;sum = 0\nx = 1\nwhile True:\n    sum = sum + x\n    x = x + 1\n    if x &amp;gt; 100:\n        break\nprint sum\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &amp;gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。&lt;/p&gt;\n&lt;h2 id=\&#34;7-python之-continue继续循环\&#34;&gt;7. Python之 continue继续循环&lt;/h2&gt;\n&lt;p&gt;在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。&lt;/p&gt;\n&lt;p&gt;假设我们已经写好了利用for循环计算平均分的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;L = [75, 98, 59, 81, 66, 43, 69, 85]\nsum = 0.0\nn = 0\nfor x in L:\n    sum = sum + x\n    n = n + 1\nprint sum / n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;现在老师只想统计及格分数的平均分，就要把 x &amp;lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &amp;lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;for x in L:\n    if x &amp;lt; 60:\n        continue\n    sum = sum + x\n    n = n + 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;8-python之-多重循环\&#34;&gt;8. Python之 多重循环&lt;/h2&gt;\n&lt;p&gt;在循环内部，还可以嵌套循环，我们来看一个例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;for x in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:\n    for y in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]:\n        print x + y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;x 每循环一次，y 就会循环 3 次，这样，我们可以打印出一个全排列：&lt;/p&gt;\n&lt;p&gt;A1&lt;br&gt;\nA2&lt;br&gt;\nA3&lt;br&gt;\nB1&lt;br&gt;\nB2&lt;br&gt;\nB3&lt;br&gt;\nC1&lt;br&gt;\nC2&lt;br&gt;\nC3&lt;/p&gt;\n&lt;h1 id=\&#34;dict和set类型\&#34;&gt;Dict和Set类型&lt;/h1&gt;\n&lt;h2 id=\&#34;1-python之什么是dict\&#34;&gt;1. Python之什么是dict&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;或者考试的成绩列表：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;[95, 85, 59]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。&lt;/p&gt;\n&lt;p&gt;如果把名字和分数关联起来，组成类似的查找表：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&#39;Adam&#39; ==&amp;gt; 95\n&#39;Lisa&#39; ==&amp;gt; 85\n&#39;Bart&#39; ==&amp;gt; 59\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;给定一个名字，就可以直接查到分数。&lt;/p&gt;\n&lt;p&gt;Python的 dict 就是专门干这件事的。用 &lt;strong&gt;dict&lt;/strong&gt; 表示**“名字”-“成绩”**的查找表如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = {\n    &#39;Adam&#39;: 95,\n    &#39;Lisa&#39;: 85,\n    &#39;Bart&#39;: 59\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们把&lt;strong&gt;名字称为key&lt;/strong&gt;，对应的&lt;strong&gt;成绩称为value&lt;/strong&gt;，dict就是通过 &lt;strong&gt;key&lt;/strong&gt; 来查找 &lt;strong&gt;value&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;花括号 {} 表示这是一个dict，然后按照 &lt;strong&gt;key: value&lt;/strong&gt;, 写出来即可。最后一个 key: value 的逗号可以省略。&lt;/p&gt;\n&lt;p&gt;由于dict也是集合，len() 函数可以计算任意集合的大小：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; len(d)\n3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 一个 key-value 算一个，因此，dict大小为3。&lt;/p&gt;\n&lt;h2 id=\&#34;2-python之访问dict\&#34;&gt;2. Python之访问dict&lt;/h2&gt;\n&lt;p&gt;我们已经能创建一个dict，用于表示名字和成绩的对应关系：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = {\n    &#39;Adam&#39;: 95,\n    &#39;Lisa&#39;: 85,\n    &#39;Bart&#39;: 59\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那么，如何根据名字来查找对应的成绩呢？&lt;/p&gt;\n&lt;p&gt;可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，&lt;strong&gt;list 必须使用索引返回对应的元素，而dict使用key：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d[&#39;Adam&#39;]\n95\n&amp;gt;&amp;gt;&amp;gt; print d[&#39;Paul&#39;]\nTraceback (most recent call last):\n  File &amp;quot;index.py&amp;quot;, line 11, in &amp;lt;module&amp;gt;\n    print d[&#39;Paul&#39;]\nKeyError: &#39;Paul&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。&lt;/p&gt;\n&lt;p&gt;要避免 KeyError 发生，有两个办法：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;一是先判断一下 key 是否存在，用 in 操作符：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;if &#39;Paul&#39; in d:\n    print d[&#39;Paul&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果 &#39;Paul&#39; 不存在，if语句判断为False，自然不会执行 print d[&#39;Paul&#39;] ，从而避免了错误。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d.get(&#39;Bart&#39;)\n59\n&amp;gt;&amp;gt;&amp;gt; print d.get(&#39;Paul&#39;)\nNone\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;任务\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;根据如下dict：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = {\n    &#39;Adam&#39;: 95,\n    &#39;Lisa&#39;: 85,\n    &#39;Bart&#39;: 59\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;请打印出：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;Adam: 95\nLisa: 85\nBart: 59\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;3-python中dict的特点\&#34;&gt;3. Python中dict的特点&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样&lt;/strong&gt;。而list的查找速度随着元素增加而逐渐下降。&lt;/p&gt;\n&lt;p&gt;不过dict的查找速度快不是没有代价的，&lt;strong&gt;dict的缺点是占用内存大，还会浪费很多内容&lt;/strong&gt;，list正好相反，占用内存小，但是查找速度慢。&lt;/p&gt;\n&lt;p&gt;由于dict是按 key 查找，所以，&lt;mark&gt;在一个dict中，key不能重复&lt;/mark&gt;。&lt;/p&gt;\n&lt;p&gt;**dict的第二个特点就是存储的key-value序对是没有顺序的！**这和list不一样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = {\n    &#39;Adam&#39;: 95,\n    &#39;Lisa&#39;: 85,\n    &#39;Bart&#39;: 59\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当我们试图打印这个dict时：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d\n{&#39;Lisa&#39;: 85, &#39;Adam&#39;: 95, &#39;Bart&#39;: 59}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同==，这说明dict内部是&lt;strong&gt;无序&lt;/strong&gt;的==，不能用dict存储有序的集合。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;dict的第三个特点是作为 key 的元素必须不可变&lt;/strong&gt;，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。&lt;/p&gt;\n&lt;p&gt;可以试试用list作为key时会报什么样的错误。&lt;/p&gt;\n&lt;p&gt;不可变这个限制仅作用于key，value是否可变无所谓：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;{\n    &#39;123&#39;: [1, 2, 3],  # key 是 str，value是list\n    123: &#39;123&#39;,  # key 是 int，value 是 str\n    (&#39;a&#39;, &#39;b&#39;): True  # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最常用的key还是字符串，因为用起来最方便。&lt;/p&gt;\n&lt;h2 id=\&#34;4-python更新dict\&#34;&gt;4. Python更新dict&lt;/h2&gt;\n&lt;p&gt;dict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = {\n    &#39;Adam&#39;: 95,\n    &#39;Lisa&#39;: 85,\n    &#39;Bart&#39;: 59\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;要把新同学&#39;Paul&#39;的成绩 72 加进去，用赋值语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d[&#39;Paul&#39;] = 72\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;再看看dict的内容：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print d\n{&#39;Lisa&#39;: 85, &#39;Paul&#39;: 72, &#39;Adam&#39;: 95, &#39;Bart&#39;: 59}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d[&#39;Bart&#39;] = 60\n&amp;gt;&amp;gt;&amp;gt; print d\n{&#39;Lisa&#39;: 85, &#39;Paul&#39;: 72, &#39;Adam&#39;: 95, &#39;Bart&#39;: 60}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;5-python之-遍历dict\&#34;&gt;5. Python之 遍历dict&lt;/h2&gt;\n&lt;p&gt;由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。&lt;/p&gt;\n&lt;p&gt;直接使用for循环可以遍历 dict 的 key：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }\n&amp;gt;&amp;gt;&amp;gt; for key in d:\n...     print key\n... \nLisa\nAdam\nBart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。&lt;/p&gt;\n&lt;h2 id=\&#34;6-python中什么是set\&#34;&gt;6. Python中什么是set&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以查看 set 的内容：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print s\nset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt;，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是&lt;strong&gt;无序&lt;/strong&gt;的。&lt;/p&gt;\n&lt;p&gt;因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;])\n&amp;gt;&amp;gt;&amp;gt; print s\nset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])\n&amp;gt;&amp;gt;&amp;gt; len(s)\n3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。&lt;/p&gt;\n&lt;h2 id=\&#34;7-python之-访问set\&#34;&gt;7. Python之 访问set&lt;/h2&gt;\n&lt;p&gt;由于&lt;strong&gt;set存储的是无序集合&lt;/strong&gt;，所以我们没法通过索引来访问。&lt;/p&gt;\n&lt;p&gt;访问 set中的某个元素实际上就是判断一个元素是否在set中。&lt;/p&gt;\n&lt;p&gt;例如，存储了班里同学名字的set：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们可以用 in 操作符判断：&lt;/p&gt;\n&lt;p&gt;Bart是该班的同学吗？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;Bart&#39; in s\nTrue\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Bill是该班的同学吗？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;Bill&#39; in s\nFalse\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;bart是该班的同学吗？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;bart&#39; in s\nFalse\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;mark&gt;看来大小写很重要&lt;/mark&gt;，&#39;Bart&#39; 和 &#39;bart&#39;被认为是两个不同的元素。&lt;/p&gt;\n&lt;h2 id=\&#34;8-python之-set的特点\&#34;&gt;8. Python之 set的特点&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;set的内部结构和dict很像，唯一区别是不存储value&lt;/strong&gt;，因此，判断一个元素是否在set中速度很快。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;set存储的元素和dict的key类似，必须是不变对象&lt;/strong&gt;，因此，任何可变对象是不能放入set中的。&lt;/p&gt;\n&lt;p&gt;最后，set存储的元素也是没有顺序的。&lt;/p&gt;\n&lt;p&gt;set的这些特点，可以应用在哪些地方呢？&lt;/p&gt;\n&lt;p&gt;星期一到星期日可以用字符串&#39;MON&#39;, &#39;TUE&#39;, ... &#39;SUN&#39;表示。&lt;/p&gt;\n&lt;p&gt;假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？&lt;/p&gt;\n&lt;p&gt;可以用 &lt;strong&gt;if 语句&lt;/strong&gt;判断，但这样做非常繁琐：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;x = &#39;???&#39; # 用户输入的字符串\nif x!= &#39;MON&#39; and x!= &#39;TUE&#39; and x!= &#39;WED&#39; ... and x!= &#39;SUN&#39;:\n    print &#39;input error&#39;\nelse:\n    print &#39;input ok&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;**注意：**if 语句中的...表示没有列出的其它星期名称，测试时，请输入完整。&lt;/p&gt;\n&lt;p&gt;如果事先创建好一个set，包含&#39;MON&#39; ~ &#39;SUN&#39;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;weekdays = set([&#39;MON&#39;, &#39;TUE&#39;, &#39;WED&#39;, &#39;THU&#39;, &#39;FRI&#39;, &#39;SAT&#39;, &#39;SUN&#39;])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;再判断输入是否有效，只需要判断该字符串是否在set中：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;x = &#39;???&#39; # 用户输入的字符串\nif x in weekdays:\n    print &#39;input ok&#39;\nelse:\n    print &#39;input error&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样一来，代码就简单多了。&lt;/p&gt;\n&lt;h2 id=\&#34;9-python之-遍历set\&#34;&gt;9. Python之 遍历set&lt;/h2&gt;\n&lt;p&gt;由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。&lt;/p&gt;\n&lt;p&gt;直接使用 for 循环可以遍历 set 的元素：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;])\n&amp;gt;&amp;gt;&amp;gt; for name in s:\n...     print name\n... \nLisa\nAdam\nBart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。&lt;/p&gt;\n&lt;h2 id=\&#34;python之-更新set\&#34;&gt;Python之 更新set&lt;/h2&gt;\n&lt;p&gt;由于&lt;strong&gt;set存储的是一组不重复的无序元素&lt;/strong&gt;，因此，更新set主要做两件事：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;一是把新的元素添加到set中，二是把已有元素从set中删除。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;添加元素时，用set的add()方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])\n&amp;gt;&amp;gt;&amp;gt; s.add(4)\n&amp;gt;&amp;gt;&amp;gt; print s\nset([1, 2, 3, 4])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])\n&amp;gt;&amp;gt;&amp;gt; s.add(3)\n&amp;gt;&amp;gt;&amp;gt; print s\nset([1, 2, 3])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;删除set中的元素时，用set的remove()方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3, 4])\n&amp;gt;&amp;gt;&amp;gt; s.remove(4)\n&amp;gt;&amp;gt;&amp;gt; print s\nset([1, 2, 3])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果删除的元素不存在set中，remove()会报错：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])\n&amp;gt;&amp;gt;&amp;gt; s.remove(4)\nTraceback (most recent call last):\n  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;\nKeyError: 4\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;所以用add()可以直接添加，而remove()前需要判断。&lt;/p&gt;\n&lt;h2 id=\&#34;函数\&#34;&gt;函数&lt;/h2&gt;\n&lt;h2 id=\&#34;python之什么是函数\&#34;&gt;Python之什么是函数&lt;/h2&gt;\n&lt;p&gt;我们知道圆的面积计算公式为：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;S = πr²\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;r1 = 12.34\nr2 = 9.08\nr3 = 73.1\ns1 = 3.14 * r1 * r1\ns2 = 3.14 * r2 * r2\ns3 = 3.14 * r3 * r3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。&lt;/p&gt;\n&lt;p&gt;有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用 &lt;code&gt;s = area_of_circle(x)&lt;/code&gt;，而函数 area_of_circle 本身只需要写一次，就可以多次调用。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;抽象&lt;/strong&gt;是数学中非常常见的概念。举个例子：&lt;/p&gt;\n&lt;p&gt;计算数列的和，比如：&lt;strong&gt;1 + 2 + 3 + ... + 100&lt;/strong&gt;，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + ... + 100记作：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;100\n∑n\nn=1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。&lt;/p&gt;\n&lt;p&gt;而且，这种抽象记法是可扩展的，比如：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;100\n∑(n²+1)\nn=1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;还原成加法运算就变成了：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。&lt;/p&gt;\n&lt;p&gt;写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。&lt;/p&gt;\n&lt;p&gt;Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。&lt;/p&gt;\n&lt;h2 id=\&#34;python之调用函数\&#34;&gt;Python之调用函数&lt;/h2&gt;\n&lt;p&gt;Python内置了很多有用的函数，我们可以直接调用。&lt;/p&gt;\n&lt;p&gt;要调用一个函数，需要知道&lt;strong&gt;函数&lt;/strong&gt;的&lt;strong&gt;名称&lt;/strong&gt;和&lt;strong&gt;参数&lt;/strong&gt;，比如求绝对值的函数 abs，它接收一个参数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;可以直接从Python的官方网站查看文档：\nhttp://docs.python.org/2/library/functions.html#abs\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。&lt;/p&gt;\n&lt;p&gt;调用 &lt;strong&gt;abs&lt;/strong&gt; 函数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs(100)\n100\n&amp;gt;&amp;gt;&amp;gt; abs(-20)\n20\n&amp;gt;&amp;gt;&amp;gt; abs(12.34)\n12.34\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;调用函数的时候，如果传入的参数数量不对，会报&lt;strong&gt;TypeError&lt;/strong&gt;的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs(1, 2)\nTraceback (most recent call last):\n  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;\nTypeError: abs() takes exactly one argument (2 given)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报&lt;strong&gt;TypeError&lt;/strong&gt;的错误，并且给出错误信息：str是错误的参数类型：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs(&#39;a&#39;)\nTraceback (most recent call last):\n  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;\nTypeError: bad operand type for abs(): &#39;str&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;而比较函数 cmp(x, y) 就需要两个参数，如果 **x&amp;lt;y，返回 &lt;strong&gt;-1&lt;/strong&gt;，如果 &lt;strong&gt;x==y&lt;/strong&gt;，返回 &lt;strong&gt;0&lt;/strong&gt;，如果 &lt;strong&gt;x&amp;gt;y&lt;/strong&gt;，返回 &lt;strong&gt;1&lt;/strong&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; cmp(1, 2)\n-1\n&amp;gt;&amp;gt;&amp;gt; cmp(2, 1)\n1\n&amp;gt;&amp;gt;&amp;gt; cmp(3, 3)\n0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Python内置的常用函数还包括数据类型转换函数，比如  int()函数可以把其他数据类型转换为整数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;123&#39;)\n123\n&amp;gt;&amp;gt;&amp;gt; int(12.34)\n12\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;str()函数把其他类型转换成 str：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; str(123)\n&#39;123&#39;\n&amp;gt;&amp;gt;&amp;gt; str(1.23)\n&#39;1.23&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;python之编写函数\&#34;&gt;Python之编写函数&lt;/h2&gt;\n&lt;p&gt;在Python中，定义一个函数要使用 &lt;strong&gt;def&lt;/strong&gt; 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。&lt;/p&gt;\n&lt;p&gt;我们以自定义一个求绝对值的 my_abs 函数为例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def my_abs(x):\n    if x &amp;gt;= 0:\n        return x\n    else:\n        return -x\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;请注意&lt;/strong&gt;，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。&lt;/p&gt;\n&lt;p&gt;如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。&lt;/p&gt;\n&lt;p&gt;return None可以简写为return。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-2\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;请定义一个 square_of_sum 函数，它接受一个list，返回list中每个元素平方的和。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def square_of_sum(L):\n    return sum([i * i for i in L])\n\nprint square_of_sum([1, 2, 3, 4, 5])\nprint square_of_sum([-5, 0, 5, 15, 25])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;python函数之返回多值\&#34;&gt;Python函数之返回多值&lt;/h2&gt;\n&lt;p&gt;函数可以返回多个值吗？答案是肯定的。&lt;/p&gt;\n&lt;p&gt;比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;# math&lt;/strong&gt;包提供了**sin()**和 **cos()**函数，我们先用import引用它：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;import math\ndef move(x, y, step, angle):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样我们就可以同时获得返回值：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; x, y = move(100, 100, 60, math.pi / 6)\n&amp;gt;&amp;gt;&amp;gt; print x, y\n151.961524227 70.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但其实这只是一种假象，Python函数返回的仍然是单一值：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; r = move(100, 100, 60, math.pi / 6)\n&amp;gt;&amp;gt;&amp;gt; print r\n(151.96152422706632, 70.0)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;用print打印返回结果，原来返回值是一个&lt;strong&gt;tuple&lt;/strong&gt;！&lt;/p&gt;\n&lt;p&gt;但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，&lt;strong&gt;Python的函数&lt;/strong&gt;返回多值其实就是&lt;strong&gt;返回一个tuple&lt;/strong&gt;，但写起来更方便。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-3\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;一元二次方程的定义是：ax² + bx + c = 0&lt;/p&gt;\n&lt;p&gt;请编写一个函数，返回一元二次方程的两个解。&lt;/p&gt;\n&lt;p&gt;**注意：**Python的math包提供了sqrt()函数用于计算平方根。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;import math\n\ndef quadratic_equation(a, b, c):\n    de=b**2-4*a*c\n    if de&amp;gt;=0:\n        x1=(-b+math.sqrt(de))/(2*a)\n        x2=(-b-math.sqrt(de))/(2*a)\n        return x1,x2\n    else:\n        return\n\nprint quadratic_equation(2, 3, 0)\nprint quadratic_equation(1, -6, 5)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;python之递归函数\&#34;&gt;Python之递归函数&lt;/h2&gt;\n&lt;p&gt;在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/p&gt;\n&lt;p&gt;举个例子，我们来计算阶乘 &lt;strong&gt;n! = 1 * 2 * 3 * ... * n&lt;/strong&gt;，用函数 **fact(n)**表示，可以看出：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;所以，**fact(n)**可以表示为 &lt;strong&gt;n * fact(n-1)&lt;/strong&gt;，只有n=1时需要特殊处理。&lt;/p&gt;\n&lt;p&gt;于是，fact(n)用递归的方式写出来就是：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def fact(n):\n    if n==1:\n        return 1\n    return n * fact(n - 1)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面就是一个递归函数。可以试试：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; fact(1)\n1\n&amp;gt;&amp;gt;&amp;gt; fact(5)\n120\n&amp;gt;&amp;gt;&amp;gt; fact(100)\n93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果我们计算fact(5)，可以根据函数定义看到计算过程如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;===&amp;gt; fact(5)\n===&amp;gt; 5 * fact(4)\n===&amp;gt; 5 * (4 * fact(3))\n===&amp;gt; 5 * (4 * (3 * fact(2)))\n===&amp;gt; 5 * (4 * (3 * (2 * fact(1))))\n===&amp;gt; 5 * (4 * (3 * (2 * 1)))\n===&amp;gt; 5 * (4 * (3 * 2))\n===&amp;gt; 5 * (4 * 6)\n===&amp;gt; 5 * 24\n===&amp;gt; 120\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。&lt;/p&gt;\n&lt;p&gt;使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-4\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;汉诺塔 (http://baike.baidu.com/view/191666.htm) 的移动也可以看做是递归函数。&lt;/p&gt;\n&lt;p&gt;我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为：&lt;/p&gt;\n&lt;p&gt;如果a只有一个圆盘，可以直接移动到c；&lt;/p&gt;\n&lt;p&gt;如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。&lt;/p&gt;\n&lt;p&gt;请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤：&lt;/p&gt;\n&lt;p&gt;move(n, a, b, c)&lt;/p&gt;\n&lt;p&gt;例如，输入 move(2, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)，打印出：&lt;/p&gt;\n&lt;p&gt;A --&amp;gt; B&lt;br&gt;\nA --&amp;gt; C&lt;br&gt;\nB --&amp;gt; C&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;#-*- coding:utf-8 -*-\ndef move(n, x, y, z):\n    if n==1:\n        print x,&#39;--&amp;gt;&#39;,z\n        return\n    move(n-1,x,z,y)#将前n-1个盘子从x移动到y上\n    move(1,x,y,z)#将最底下的最后一个盘子从x移动到z上\n    move(n-1,y,x,z)#将y上的n-1个盘子移动到z上\nmove(4, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;python之定义默认参数\&#34;&gt;Python之定义默认参数&lt;/h2&gt;\n&lt;p&gt;定义函数的时候，还可以有默认参数。&lt;/p&gt;\n&lt;p&gt;例如Python自带的 &lt;strong&gt;int()&lt;/strong&gt; 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;123&#39;)\n123\n&amp;gt;&amp;gt;&amp;gt; int(&#39;123&#39;, 8)\n83\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。&lt;/p&gt;\n&lt;p&gt;可见，&lt;strong&gt;函数的默认参数的作用是简化调用&lt;/strong&gt;，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。&lt;/p&gt;\n&lt;p&gt;我们来定义一个计算 x 的N次方的函数:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def power(x, n):\n    s = 1\n    while n &amp;gt; 0:\n        n = n - 1\n        s = s * x\n    return s\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def power(x, n=2):\n    s = 1\n    while n &amp;gt; 0:\n        n = n - 1\n        s = s * x\n    return s\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样一来，计算平方就不需要传入两个参数了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; power(5)\n25\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于函数的参数按从左到右的顺序匹配，所以&lt;strong&gt;默认参数只能定义在必需参数的后面：&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;# OK:\ndef fn1(a, b=1, c=2):\n    pass\n# Error:\ndef fn2(a=1, b):\n    pass\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;任务-5\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;请定义一个 greet() 函数，它包含一个默认参数，如果没有传入，打印 &#39;Hello, world.&#39;，如果传入，打印 &#39;Hello, xxx.&#39;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def greet(a=&#39;world&#39;):\n    print &#39;hello,&#39;,a,&#39;.&#39;\n\ngreet()\ngreet(&#39;Bart&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;python之定义可变参数\&#34;&gt;Python之定义可变参数&lt;/h2&gt;\n&lt;p&gt;如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def fn(*args):\n    print args\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可变参数的名字前面有个 ***** 号，我们可以传入0个、1个或多个参数给可变参数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; fn()\n()\n&amp;gt;&amp;gt;&amp;gt; fn(&#39;a&#39;)\n(&#39;a&#39;,)\n&amp;gt;&amp;gt;&amp;gt; fn(&#39;a&#39;, &#39;b&#39;)\n(&#39;a&#39;, &#39;b&#39;)\n&amp;gt;&amp;gt;&amp;gt; fn(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)\n(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。&lt;/p&gt;\n&lt;p&gt;定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def average(*args):\n    ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样，在调用的时候，可以这样写：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; average()\n0\n&amp;gt;&amp;gt;&amp;gt; average(1, 2)\n1.5\n&amp;gt;&amp;gt;&amp;gt; average(1, 2, 2, 3, 4)\n2.4\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;任务-6\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;请编写接受可变参数的 average() 函数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def average(*args):\n    sum = 0.0\n    if len(args) == 0:\n        return sum\n    for x in args:\n        sum = sum + x\n    return sum / len(args)\nprint average()\nprint average(1, 2)\nprint average(1, 2, 2, 3, 4)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;切片\&#34;&gt;切片&lt;/h1&gt;\n&lt;h2 id=\&#34;1-对list进行切片\&#34;&gt;1 对list进行切片&lt;/h2&gt;\n&lt;h2 id=\&#34;对list进行切片\&#34;&gt;对list进行切片&lt;/h2&gt;\n&lt;p&gt;取一个list的部分元素是非常常见的操作。比如，一个list如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;取前3个元素，应该怎么做？&lt;/p&gt;\n&lt;p&gt;笨办法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [L[0], L[1], L[2]]\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;之所以是笨办法是因为扩展一下，取前N个元素就没辙了。&lt;/p&gt;\n&lt;p&gt;取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; r = []\n&amp;gt;&amp;gt;&amp;gt; n = 3\n&amp;gt;&amp;gt;&amp;gt; for i in range(n):\n...     r.append(L[i])\n... \n&amp;gt;&amp;gt;&amp;gt; r\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。&lt;/p&gt;\n&lt;p&gt;对应上面的问题，取前3个元素，用一行代码就可以完成切片：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[0:3]\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。&lt;/p&gt;\n&lt;p&gt;如果第一个索引是0，还可以省略：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[:3]\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;也可以从索引1开始，取出2个元素出来：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[1:3]\n[&#39;Lisa&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;只用一个 &lt;strong&gt;:&lt;/strong&gt; ，表示从头到尾：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[:]\n[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因此，L[:]实际上复制出了一个新list。&lt;/p&gt;\n&lt;p&gt;切片操作还可以指定第三个参数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[::2]\n[&#39;Adam&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。&lt;/p&gt;\n&lt;p&gt;把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-7\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;range()函数可以创建一个数列：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; range(1, 101)\n[1, 2, 3, ..., 100]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;请利用切片，取出：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;前10个数；&lt;/li&gt;\n&lt;li&gt;3的倍数；&lt;/li&gt;\n&lt;li&gt;不大于50的5的倍数。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;L = range(1, 101)\n\nprint L[:10]\nprint L[2::3]\nprint L[4:50:5]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;倒序切片\&#34;&gt;倒序切片&lt;/h2&gt;\n&lt;p&gt;对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\n\n&amp;gt;&amp;gt;&amp;gt; L[-2:]\n[&#39;Bart&#39;, &#39;Paul&#39;]\n\n&amp;gt;&amp;gt;&amp;gt; L[:-2]\n[&#39;Adam&#39;, &#39;Lisa&#39;]\n\n&amp;gt;&amp;gt;&amp;gt; L[-3:-1]\n[&#39;Lisa&#39;, &#39;Bart&#39;]\n\n&amp;gt;&amp;gt;&amp;gt; L[-4:-1:2]\n[&#39;Adam&#39;, &#39;Bart&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-8\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;利用倒序切片对 1 - 100 的数列取出：&lt;/p&gt;\n&lt;p&gt;* 最后10个数；&lt;/p&gt;\n&lt;p&gt;* 最后10个5的倍数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;L = range(1, 101)\nprint L[-10:]\nprint L[-46::5]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;对字符串切片\&#34;&gt;对字符串切片&lt;/h2&gt;\n&lt;p&gt;字符串 &#39;xxx&#39;和 Unicode字符串 u&#39;xxx&#39;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[:3]\n&#39;ABC&#39;\n&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[-3:]\n&#39;EFG&#39;\n&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[::2]\n&#39;ACEG&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-9\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;字符串有个方法 upper() 可以把字符变成大写字母：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.upper()\n&#39;ABC&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。&lt;/p&gt;\n&lt;p&gt;**提示：**利用切片操作简化字符串操作。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def firstCharUpper(s):\n    return s[0].upper() + s[1:]\nprint firstCharUpper(&#39;hello&#39;)\nprint firstCharUpper(&#39;sunday&#39;)\nprint firstCharUpper(&#39;september&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;迭代\&#34;&gt;迭代&lt;/h1&gt;\n&lt;h2 id=\&#34;什么是迭代\&#34;&gt;什么是迭代&lt;/h2&gt;\n&lt;p&gt;在Python中，如果给定一个&lt;strong&gt;list&lt;/strong&gt;或&lt;strong&gt;tuple&lt;/strong&gt;，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。&lt;/p&gt;\n&lt;p&gt;在Python中，迭代是通过 for ... in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;for (i=0; i&amp;lt;list.length; i++) {\n    n = list[i];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看出，Python的for循环抽象程度要高于Java的for循环。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：\n1. 有序集合：list，tuple，str和unicode；\n2. 无序集合：set\n3. 无序集合并且具有 key-value 对：dict\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;而迭代是一个动词，它指的是一种操作，&lt;strong&gt;在Python中，就是 for 循环&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-10\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;请用for循环迭代数列 1-100 并打印出7的倍数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;for i in range(1, 101):\n    if i % 7 == 0:\n        print i\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;索引迭代\&#34;&gt;索引迭代&lt;/h2&gt;\n&lt;p&gt;Python中，&lt;strong&gt;迭代永远是取出元素本身，而非元素的索引。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？&lt;/p&gt;\n&lt;p&gt;方法是使用 &lt;strong&gt;enumerate() 函数&lt;/strong&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\n&amp;gt;&amp;gt;&amp;gt; for index, name in enumerate(L):\n...     print index, &#39;-&#39;, name\n... \n0 - Adam\n1 - Lisa\n2 - Bart\n3 - Paul\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;变成了类似：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;[(0, &#39;Adam&#39;), (1, &#39;Lisa&#39;), (2, &#39;Bart&#39;), (3, &#39;Paul&#39;)]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因此，迭代的每一个元素实际上是一个tuple：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;for t in enumerate(L):\n    index = t[0]\n    name = t[1]\n    print index, &#39;-&#39;, name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;for index, name in enumerate(L):\n    print index, &#39;-&#39;, name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样不但代码更简单，而且还少了两条赋值语句。&lt;/p&gt;\n&lt;p&gt;可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-11\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;zip()函数可以把两个 list 变成一个 list：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; zip([10, 20, 30], [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])\n[(10, &#39;A&#39;), (20, &#39;B&#39;), (30, &#39;C&#39;)]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在迭代 [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。&lt;/p&gt;\n&lt;p&gt;**提示：**考虑使用zip()函数和range()函数&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]\nfor index, name in zip(range(1, len(L)+1), L):\n    print index, &#39;-&#39;, name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;迭代dict的value\&#34;&gt;迭代dict的value&lt;/h2&gt;\n&lt;p&gt;我们已经了解了&lt;strong&gt;dict对象&lt;/strong&gt;本身就是可&lt;strong&gt;迭代对象&lt;/strong&gt;，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。&lt;/p&gt;\n&lt;p&gt;如果我们希望迭代 dict 对象的value，应该怎么做？&lt;/p&gt;\n&lt;p&gt;dict 对象有一个 &lt;strong&gt;values() 方法&lt;/strong&gt;，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }\nprint d.values()\n# [85, 95, 59]\nfor v in d.values():\n    print v\n# 85\n# 95\n# 59\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果仔细阅读Python的文档，还可以发现，dict除了**values()**方法外，还有一个 &lt;strong&gt;itervalues()&lt;/strong&gt; 方法，用 &lt;strong&gt;itervalues()&lt;/strong&gt; 方法替代 &lt;strong&gt;values()&lt;/strong&gt; 方法，迭代效果完全一样：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }\nprint d.itervalues()\n# &amp;lt;dictionary-valueiterator object at 0x106adbb50&amp;gt;\nfor v in d.itervalues():\n    print v\n# 85\n# 95\n# 59\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;那这两个方法有何不同之处呢？&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;\\1. &lt;strong&gt;values()&lt;/strong&gt; 方法实际上把一个 dict 转换成了包含 value 的list。&lt;/p&gt;\n&lt;p&gt;\\2. 但是 &lt;strong&gt;itervalues()&lt;/strong&gt; 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。&lt;/p&gt;\n&lt;p&gt;\\3. 打印 itervalues() 发现它返回一个 &lt;dictionary-valueiterator&gt; 对象，这说明在Python中，&lt;strong&gt;for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等&lt;/strong&gt;，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;任务-12\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;给定一个dict：&lt;/p&gt;\n&lt;p&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }&lt;/p&gt;\n&lt;p&gt;请计算所有同学的平均分。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }\nsum = 0.0\nfor v in d.itervalues():\n    sum = sum + v\nprint sum / len(d)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;迭代dict的key和value\&#34;&gt;迭代dict的key和value&lt;/h2&gt;\n&lt;p&gt;我们了解了如何&lt;strong&gt;迭代 dict&lt;/strong&gt; 的&lt;strong&gt;key&lt;/strong&gt;和&lt;strong&gt;value&lt;/strong&gt;，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。&lt;/p&gt;\n&lt;p&gt;首先，我们看看 dict 对象的 &lt;strong&gt;items()&lt;/strong&gt; 方法返回的值：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }\n&amp;gt;&amp;gt;&amp;gt; print d.items()\n[(&#39;Lisa&#39;, 85), (&#39;Adam&#39;, 95), (&#39;Bart&#39;, 59)]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; for key, value in d.items():\n...     print key, &#39;:&#39;, value\n... \nLisa : 85\nAdam : 95\nBart : 59\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;和 values() 有一个 itervalues() 类似， &lt;strong&gt;items()&lt;/strong&gt; 也有一个对应的 &lt;strong&gt;iteritems()&lt;/strong&gt;，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-13\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;请根据dict：&lt;/p&gt;\n&lt;p&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }&lt;/p&gt;\n&lt;p&gt;打印出 name : score，最后再打印出平均分 average : score。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59, &#39;Paul&#39;: 74 }\nsum = 0.0\nfor k, v in d.iteritems():\n    sum = sum + v\n    print k, &#39;:&#39;, v\nprint &#39;average&#39;, &#39;:&#39;, sum / len(d)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;列表生成式\&#34;&gt;列表生成式&lt;/h1&gt;\n&lt;h2 id=\&#34;生成列表\&#34;&gt;生成列表&lt;/h2&gt;\n&lt;p&gt;要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; range(1, 11)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = []\n&amp;gt;&amp;gt;&amp;gt; for x in range(1, 11):\n...    L.append(x * x)\n... \n&amp;gt;&amp;gt;&amp;gt; L\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。&lt;/p&gt;\n&lt;p&gt;写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-14\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, ..., 99x100]&lt;/p&gt;\n&lt;p&gt;**提示：**range(1, 100, 2) 可以生成list [1, 3, 5, 7, 9,...]&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;print [x * (x + 1) for x in range(1, 100, 2)]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;复杂表达式\&#34;&gt;复杂表达式&lt;/h2&gt;\n&lt;p&gt;使用&lt;strong&gt;for循环&lt;/strong&gt;的迭代不仅可以迭代普通的list，还可以迭代dict。&lt;/p&gt;\n&lt;p&gt;假设有如下的dict：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;tds = [&#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39; % (name, score) for name, score in d.iteritems()]\nprint &#39;&amp;lt;table&amp;gt;&#39;\nprint &#39;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;&#39;\nprint &#39;\\n&#39;.join(tds)\nprint &#39;&amp;lt;/table&amp;gt;&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;**注：**字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。&lt;/p&gt;\n&lt;p&gt;把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt;\n&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;\n&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Lisa&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;85&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Adam&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;95&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Bart&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;59&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&amp;lt;/table&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;{% asset_img 540fcd2a0001ff4600940104.jpg %}&lt;/p&gt;\n&lt;h3 id=\&#34;任务-15\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;在生成的表格中，对于没有及格的同学，请把分数标记为红色。&lt;/p&gt;\n&lt;p&gt;**提示：**红色可以用 &lt;td style=\&#34;color:red\&#34;&gt; 实现。&lt;/p&gt;\n&lt;p&gt;{% asset_img 540fcd610001be6800940104.jpg%}&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;d = { &#39;Adam&#39;: 95, &#39;Lisa&#39;: 85, &#39;Bart&#39;: 59 }\ndef generate_tr(name, score):\n    if score &amp;lt; 60:\n        return &#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td style=&amp;quot;color:red&amp;quot;&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39; % (name, score)\n    return &#39;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&#39; % (name, score)\ntds = [generate_tr(name, score) for name, score in d.iteritems()]\nprint &#39;&amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt;&#39;\nprint &#39;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;&#39;\nprint &#39;\\n&#39;.join(tds)\nprint &#39;&amp;lt;/table&amp;gt;&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;条件过滤\&#34;&gt;条件过滤&lt;/h2&gt;\n&lt;p&gt;列表生成式的 &lt;strong&gt;for 循环后面还可以加上 if 判断&lt;/strong&gt;。例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11) if x % 2 == 0]\n[4, 16, 36, 64, 100]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。&lt;/p&gt;\n&lt;h3 id=\&#34;任务-16\&#34;&gt;任务&lt;/h3&gt;\n&lt;p&gt;请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;\\1. isinstance(x, str) 可以判断变量 x 是否是字符串；&lt;/p&gt;\n&lt;p&gt;\\2. 字符串的 upper() 方法可以返回大写的字母。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;def toUppers(L):\n    return [x.upper() for x in L if isinstance(x, str)]\nprint toUppers([&#39;Hello&#39;, &#39;world&#39;, 101])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;多层表达式\&#34;&gt;多层表达式&lt;/h2&gt;\n&lt;p&gt;for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。&lt;/p&gt;\n&lt;p&gt;对于字符串 &#39;ABC&#39; 和 &#39;123&#39;，可以使用两层循环，生成全排列：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [m + n for m in &#39;ABC&#39; for n in &#39;123&#39;]\n[&#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;翻译成循环代码就像下面这样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;L = []\nfor m in &#39;ABC&#39;:\n    for n in &#39;123&#39;:\n        L.append(m + n)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;print [100 * n1 + 10 * n2 + n3 for n1 in range(1, 10) for n2 in range(10) for n3 in range(10) if n1==n3]\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;Python入门&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Python入门&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Python入门&#34;,&#34;slug&#34;:&#34;RHrM0w46mi&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/RHrM0w46mi/&#34;}],&#34;date&#34;:&#34;2020-02-20 19:42:36&#34;,&#34;dateFormat&#34;:&#34;2020-02-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/Python入门/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;68 min read&#34;,&#34;time&#34;:4053000,&#34;words&#34;:16488,&#34;minutes&#34;:68},&#34;description&#34;:&#34;入门\nPython变量和数据类型\n1. Python中数据类型\n计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%A5%E9%97%A8\&#34;&gt;入门&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;Python变量和数据类型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-python%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;1. Python中数据类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-python%E4%B9%8Bprint%E8%AF%AD%E5%8F%A5\&#34;&gt;2. Python之print语句&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-python%E7%9A%84%E6%B3%A8%E9%87%8A\&#34;&gt;3. Python的注释&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-python%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F\&#34;&gt;4. Python中什么是变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5python%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2\&#34;&gt;5.Python中定义字符串&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6python%E4%B8%ADraw%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2\&#34;&gt;6.Python中raw字符串与多行字符串&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-python%E4%B8%ADunicode%E5%AD%97%E7%AC%A6%E4%B8%B2\&#34;&gt;7. Python中Unicode字符串&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B8%AD%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0\&#34;&gt;Python中整数和浮点数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-python%E4%B8%AD%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B\&#34;&gt;8. Python中布尔类型&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#list%E5%92%8Ctuple%E7%B1%BB%E5%9E%8B\&#34;&gt;List和Tuple类型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-python%E5%88%9B%E5%BB%BAlist\&#34;&gt;1. Python创建list&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-python%E6%8C%89%E7%85%A7%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AElist\&#34;&gt;2. Python按照索引访问list&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-python%E4%B9%8B%E5%80%92%E5%BA%8F%E8%AE%BF%E9%97%AElist\&#34;&gt;3.  Python之倒序访问list&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-python%E4%B9%8B%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0\&#34;&gt;4. Python之添加新元素&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-python%E4%BB%8Elist%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0\&#34;&gt;5. Python从list删除元素&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-python%E4%B8%AD%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0\&#34;&gt;6.  Python中替换元素&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-python%E4%B9%8B%E5%88%9B%E5%BB%BAtuple\&#34;&gt;7. Python之创建tuple&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-python%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%8D%95%E5%85%83%E7%B4%A0tuple\&#34;&gt;8. Python之创建单元素tuple&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9-python%E4%B9%8B%E5%8F%AF%E5%8F%98%E7%9A%84tuple\&#34;&gt;9. Python之“可变”的tuple&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF\&#34;&gt;条件判断和循环&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-python%E4%B9%8Bif%E8%AF%AD%E5%8F%A5\&#34;&gt;1. Python之if语句&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-python%E4%B9%8B-if-else\&#34;&gt;2. Python之 if-else&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-python%E4%B9%8B-if-elif-else\&#34;&gt;3. Python之 if-elif-else&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%B7%E6%80%9D%E8%80%83%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81\&#34;&gt;请思考下面的代码：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-python%E4%B9%8B-for%E5%BE%AA%E7%8E%AF\&#34;&gt;4. Python之 for循环&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-python%E4%B9%8B-while%E5%BE%AA%E7%8E%AF\&#34;&gt;5. Python之 while循环&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-python%E4%B9%8B-break%E9%80%80%E5%87%BA%E5%BE%AA%E7%8E%AF\&#34;&gt;6. Python之 break退出循环&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-python%E4%B9%8B-continue%E7%BB%A7%E7%BB%AD%E5%BE%AA%E7%8E%AF\&#34;&gt;7. Python之 continue继续循环&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-python%E4%B9%8B-%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF\&#34;&gt;8. Python之 多重循环&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dict%E5%92%8Cset%E7%B1%BB%E5%9E%8B\&#34;&gt;Dict和Set类型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-python%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AFdict\&#34;&gt;1. Python之什么是dict&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-python%E4%B9%8B%E8%AE%BF%E9%97%AEdict\&#34;&gt;2. Python之访问dict&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-python%E4%B8%ADdict%E7%9A%84%E7%89%B9%E7%82%B9\&#34;&gt;3. Python中dict的特点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-python%E6%9B%B4%E6%96%B0dict\&#34;&gt;4. Python更新dict&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-python%E4%B9%8B-%E9%81%8D%E5%8E%86dict\&#34;&gt;5. Python之 遍历dict&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-python%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AFset\&#34;&gt;6. Python中什么是set&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-python%E4%B9%8B-%E8%AE%BF%E9%97%AEset\&#34;&gt;7. Python之 访问set&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-python%E4%B9%8B-set%E7%9A%84%E7%89%B9%E7%82%B9\&#34;&gt;8. Python之 set的特点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9-python%E4%B9%8B-%E9%81%8D%E5%8E%86set\&#34;&gt;9. Python之 遍历set&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B9%8B-%E6%9B%B4%E6%96%B0set\&#34;&gt;Python之 更新set&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0\&#34;&gt;函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0\&#34;&gt;Python之什么是函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B9%8B%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0\&#34;&gt;Python之调用函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B9%8B%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0\&#34;&gt;Python之编写函数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-2\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E5%87%BD%E6%95%B0%E4%B9%8B%E8%BF%94%E5%9B%9E%E5%A4%9A%E5%80%BC\&#34;&gt;Python函数之返回多值&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-3\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B9%8B%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0\&#34;&gt;Python之递归函数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-4\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B9%8B%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0\&#34;&gt;Python之定义默认参数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-5\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\&#34;&gt;Python之定义可变参数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-6\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%87%E7%89%87\&#34;&gt;切片&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%AF%B9list%E8%BF%9B%E8%A1%8C%E5%88%87%E7%89%87\&#34;&gt;1 对list进行切片&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9list%E8%BF%9B%E8%A1%8C%E5%88%87%E7%89%87\&#34;&gt;对list进行切片&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-7\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%80%92%E5%BA%8F%E5%88%87%E7%89%87\&#34;&gt;倒序切片&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-8\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87\&#34;&gt;对字符串切片&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-9\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%AD%E4%BB%A3\&#34;&gt;迭代&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3\&#34;&gt;什么是迭代&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-10\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B4%A2%E5%BC%95%E8%BF%AD%E4%BB%A3\&#34;&gt;索引迭代&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-11\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%AD%E4%BB%A3dict%E7%9A%84value\&#34;&gt;迭代dict的value&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-12\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%AD%E4%BB%A3dict%E7%9A%84key%E5%92%8Cvalue\&#34;&gt;迭代dict的key和value&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-13\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F\&#34;&gt;列表生成式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8\&#34;&gt;生成列表&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-14\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%8D%E6%9D%82%E8%A1%A8%E8%BE%BE%E5%BC%8F\&#34;&gt;复杂表达式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-15\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%A1%E4%BB%B6%E8%BF%87%E6%BB%A4\&#34;&gt;条件过滤&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1-16\&#34;&gt;任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E5%B1%82%E8%A1%A8%E8%BE%BE%E5%BC%8F\&#34;&gt;多层表达式&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;数据库连接池\&#34;&gt;数据库连接池&lt;/h1&gt;\n&lt;h2 id=\&#34;1-概念\&#34;&gt;1. 概念：&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;其实就是一个容器(集合)，存放数据库连接的容器。&lt;/li&gt;\n&lt;li&gt;当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;2-好处\&#34;&gt;2. 好处：&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;节约资源&lt;/li&gt;\n&lt;li&gt;用户访问高效&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;3-实现\&#34;&gt;3. 实现：&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;标准接口：DataSource   javax.sql包下的\n&lt;ol&gt;\n&lt;li&gt;方法：\n&lt;ol&gt;\n&lt;li&gt;获取连接：getConnection()&lt;/li&gt;\n&lt;li&gt;归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;一般我们不去实现它，有数据库厂商来实现\n&lt;ol&gt;\n&lt;li&gt;C3P0：数据库连接池技术&lt;/li&gt;\n&lt;li&gt;Druid：数据库连接池实现技术，由阿里巴巴提供的&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;4-c3p0数据库连接池技术\&#34;&gt;4. C3P0：数据库连接池技术&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;步骤：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;不要忘记导入数据库驱动jar包&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;定义配置文件：\n&lt;ol&gt;\n&lt;li&gt;名称： c3p0.properties 或者 c3p0-config.xml&lt;/li&gt;\n&lt;li&gt;路径：直接将文件放在src目录下即可。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt; //1.创建数据库连接池对象\n DataSource ds  = new ComboPooledDataSource();\n  //2. 获取连接对象\n  Connection conn = ds.getConnection();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;5-druid数据库连接池实现技术由阿里巴巴提供的\&#34;&gt;5. Druid：数据库连接池实现技术，由阿里巴巴提供的&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;步骤：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;导入jar包 druid-1.0.9.jar&lt;/li&gt;\n&lt;li&gt;定义配置文件：\n&lt;ol&gt;\n&lt;li&gt;是properties形式的&lt;/li&gt;\n&lt;li&gt;可以叫任意名称，可以放在任意目录下&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;加载配置文件。Properties&lt;/li&gt;\n&lt;li&gt;获取数据库连接池对象：通过&lt;strong&gt;工厂&lt;/strong&gt;来来获取  &lt;strong&gt;DruidDataSourceFactory&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;获取连接：&lt;strong&gt;getConnection&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;代码：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t\t //3.加载配置文件\n\t        Properties pro = new Properties();\n\t        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&amp;quot;druid.properties&amp;quot;);\n\t        pro.load(is);\n\t        //4.获取连接池对象\n\t        DataSource ds = DruidDataSourceFactory.createDataSource(pro);\n\t        //5.获取连接\n\t        Connection conn = ds.getConnection();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;定义工具类&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;定义一个类 JDBCUtils&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;提供静态代码块加载配置文件，初始化连接池对象&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;提供方法&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;获取连接方法：通过数据库连接池获取连接&lt;/li&gt;\n&lt;li&gt;释放资源&lt;/li&gt;\n&lt;li&gt;获取连接池的方法&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class JDBCUtils {\n\n\t\t\t    //1.定义成员变量 DataSource\n\t\t\t    private static DataSource ds ;\n\t\t\t\n\t\t\t    static{\n\t\t\t        try {\n\t\t\t            //1.加载配置文件\n\t\t\t            Properties pro = new Properties();\n\t\t\t            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&amp;quot;druid.properties&amp;quot;));\n\t\t\t            //2.获取DataSource\n\t\t\t            ds = DruidDataSourceFactory.createDataSource(pro);\n\t\t\t        } catch (IOException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        } catch (Exception e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t    }\n\t\t\t\n\t\t\t    /**\n\t\t\t     * 获取连接\n\t\t\t     */\n\t\t\t    public static Connection getConnection() throws SQLException {\n\t\t\t        return ds.getConnection();\n\t\t\t    }\n\t\t\t\n\t\t\t    /**\n\t\t\t     * 释放资源\n\t\t\t     */\n\t\t\t    public static void close(Statement stmt,Connection conn){\n\t\t\t       /* if(stmt != null){\n\t\t\t            try {\n\t\t\t                stmt.close();\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t        if(conn != null){\n\t\t\t            try {\n\t\t\t                conn.close();//归还连接\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }*/\n\t\t\t\n\t\t\t       close(null,stmt,conn);\n\t\t\t    }\n\t\t\t\n\t\t\t\n\t\t\t    public static void close(ResultSet rs , Statement stmt, Connection conn){\n\t\t\t\n\t\t\t\n\t\t\t        if(rs != null){\n\t\t\t            try {\n\t\t\t                rs.close();\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t\n\t\t\t        if(stmt != null){\n\t\t\t            try {\n\t\t\t                stmt.close();\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t\n\t\t\t        if(conn != null){\n\t\t\t            try {\n\t\t\t                conn.close();//归还连接\n\t\t\t            } catch (SQLException e) {\n\t\t\t                e.printStackTrace();\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t\n\t\t\t    /**\n\t\t\t     * 获取连接池方法\n\t\t\t     */\n\t\t\t\n\t\t\t    public static DataSource getDataSource(){\n\t\t\t        return  ds;\n\t\t\t    }\n\t\t\t\n\t\t\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;spring-jdbc\&#34;&gt;Spring JDBC&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;步骤：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;导入jar包&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建JdbcTemplate对象。依赖于数据源DataSource&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;JdbcTemplate template = new JdbcTemplate(ds);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;调用JdbcTemplate的方法来完成CRUD的操作&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;update():执行DML语句。增、删、改语句&lt;/li&gt;\n&lt;li&gt;queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：这个方法查询的结果集长度只能是1&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;queryForList():查询结果将结果集封装为list集合\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;query():查询结果，将结果封装为JavaBean对象&lt;/li&gt;\n&lt;li&gt;query的参数：RowMapper\n&lt;ul&gt;\n&lt;li&gt;一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装&lt;/li&gt;\n&lt;li&gt;new BeanPropertyRowMapper&amp;lt;类型&amp;gt;(类型.class)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;queryForObject：查询结果，将结果封装为对象\n&lt;ul&gt;\n&lt;li&gt;一般用于聚合函数的查询&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;练习：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;需求：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;修改1号数据的 salary 为 10000&lt;/li&gt;\n&lt;li&gt;添加一条记录&lt;/li&gt;\n&lt;li&gt;删除刚才添加的记录&lt;/li&gt;\n&lt;li&gt;查询id为1的记录，将其封装为Map集合&lt;/li&gt;\n&lt;li&gt;查询所有记录，将其封装为List&lt;/li&gt;\n&lt;li&gt;查询所有记录，将其封装为Emp对象的List集合&lt;/li&gt;\n&lt;li&gt;查询总记录数&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;code&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    \t\t\timport cn.itcast.domain.Emp;\n    \t\t\timport cn.itcast.utils.JDBCUtils;\n    \t\t\timport org.junit.Test;\n    \t\t\timport org.springframework.jdbc.core.BeanPropertyRowMapper;\n    \t\t\timport org.springframework.jdbc.core.JdbcTemplate;\n    \t\t\timport org.springframework.jdbc.core.RowMapper;\n\n    \t\t\timport java.sql.Date;\n    \t\t\timport java.sql.ResultSet;\n    \t\t\timport java.sql.SQLException;\n    \t\t\timport java.util.List;\n    \t\t\timport java.util.Map;\n\n    \t\t\tpublic class JdbcTemplateDemo2 {\n\n    \t\t\t    //Junit单元测试，可以让方法独立执行\n\n\n    \t\t\t    //1. 获取JDBCTemplate对象\n    \t\t\t    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());\n    \t\t\t    /**\n    \t\t\t     * 1. 修改1号数据的 salary 为 10000\n    \t\t\t     */\n    \t\t\t    @Test\n    \t\t\t    public void test1(){\n\n    \t\t\t        //2. 定义sql\n    \t\t\t        String sql = &amp;quot;update emp set salary = 10000 where id = 1001&amp;quot;;\n    \t\t\t        //3. 执行sql\n    \t\t\t        int count = template.update(sql);\n    \t\t\t        System.out.println(count);\n    \t\t\t    }\n\n    \t\t\t    /**\n    \t\t\t     * 2. 添加一条记录\n    \t\t\t     */\n    \t\t\t    @Test\n    \t\t\t    public void test2(){\n    \t\t\t        String sql = &amp;quot;insert into emp(id,ename,dept_id) values(?,?,?)&amp;quot;;\n    \t\t\t        int count = template.update(sql, 1015, &amp;quot;郭靖&amp;quot;, 10);\n    \t\t\t        System.out.println(count);\n\n    \t\t\t    }\n\n    \t\t\t    /**\n    \t\t\t     * 3.删除刚才添加的记录\n    \t\t\t     */\n    \t\t\t    @Test\n    \t\t\t    public void test3(){\n    \t\t\t        String sql = &amp;quot;delete from emp where id = ?&amp;quot;;\n    \t\t\t        int count = template.update(sql, 1015);\n    \t\t\t        System.out.println(count);\n    \t\t\t    }\n\n    \t\t\t    /**\n    \t\t\t     * 4.查询id为1001的记录，将其封装为Map集合\n    \t\t\t     * 注意：这个方法查询的结果集长度只能是1\n    \t\t\t     */\n    \t\t\t    @Test\n    \t\t\t    public void test4(){\n    \t\t\t        String sql = &amp;quot;select * from emp where id = ? or id = ?&amp;quot;;\n    \t\t\t        Map&amp;lt;String, Object&amp;gt; map = template.queryForMap(sql, 1001,1002);\n    \t\t\t        System.out.println(map);\n    \t\t\t        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}\n\n    \t\t\t    }\n\n    \t\t\t    /**\n    \t\t\t     * 5. 查询所有记录，将其封装为List\n    \t\t\t     */\n    \t\t\t    @Test\n    \t\t\t    public void test5(){\n    \t\t\t        String sql = &amp;quot;select * from emp&amp;quot;;\n    \t\t\t        List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = template.queryForList(sql);\n\n    \t\t\t        for (Map&amp;lt;String, Object&amp;gt; stringObjectMap : list) {\n    \t\t\t            System.out.println(stringObjectMap);\n    \t\t\t        }\n    \t\t\t    }\n\n    \t\t\t    /**\n    \t\t\t     * 6. 查询所有记录，将其封装为Emp对象的List集合\n    \t\t\t     */\n\n    \t\t\t    @Test\n    \t\t\t    public void test6(){\n    \t\t\t        String sql = &amp;quot;select * from emp&amp;quot;;\n    \t\t\t        List&amp;lt;Emp&amp;gt; list = template.query(sql, new RowMapper&amp;lt;Emp&amp;gt;() {\n\n    \t\t\t            @Override\n    \t\t\t            public Emp mapRow(ResultSet rs, int i) throws SQLException {\n    \t\t\t                Emp emp = new Emp();\n    \t\t\t                int id = rs.getInt(&amp;quot;id&amp;quot;);\n    \t\t\t                String ename = rs.getString(&amp;quot;ename&amp;quot;);\n    \t\t\t                int job_id = rs.getInt(&amp;quot;job_id&amp;quot;);\n    \t\t\t                int mgr = rs.getInt(&amp;quot;mgr&amp;quot;);\n    \t\t\t                Date joindate = rs.getDate(&amp;quot;joindate&amp;quot;);\n    \t\t\t                double salary = rs.getDouble(&amp;quot;salary&amp;quot;);\n    \t\t\t                double bonus = rs.getDouble(&amp;quot;bonus&amp;quot;);\n    \t\t\t                int dept_id = rs.getInt(&amp;quot;dept_id&amp;quot;);\n\n    \t\t\t                emp.setId(id);\n    \t\t\t                emp.setEname(ename);\n    \t\t\t                emp.setJob_id(job_id);\n    \t\t\t                emp.setMgr(mgr);\n    \t\t\t                emp.setJoindate(joindate);\n    \t\t\t                emp.setSalary(salary);\n    \t\t\t                emp.setBonus(bonus);\n    \t\t\t                emp.setDept_id(dept_id);\n\n    \t\t\t                return emp;\n    \t\t\t            }\n    \t\t\t        });\n\n\n    \t\t\t        for (Emp emp : list) {\n    \t\t\t            System.out.println(emp);\n    \t\t\t        }\n    \t\t\t    }\n\n    \t\t\t    /**\n    \t\t\t     * 6. 查询所有记录，将其封装为Emp对象的List集合\n    \t\t\t     */\n\n    \t\t\t    @Test\n    \t\t\t    public void test6_2(){\n    \t\t\t        String sql = &amp;quot;select * from emp&amp;quot;;\n    \t\t\t        List&amp;lt;Emp&amp;gt; list = template.query(sql, new BeanPropertyRowMapper&amp;lt;Emp&amp;gt;(Emp.class));\n    \t\t\t        for (Emp emp : list) {\n    \t\t\t            System.out.println(emp);\n    \t\t\t        }\n    \t\t\t    }\n\n    \t\t\t    /**\n    \t\t\t     * 7. 查询总记录数\n    \t\t\t     */\n\n    \t\t\t    @Test\n    \t\t\t    public void test7(){\n    \t\t\t        String sql = &amp;quot;select count(id) from emp&amp;quot;;\n    \t\t\t        Long total = template.queryForObject(sql, Long.class);\n    \t\t\t        System.out.println(total);\n    \t\t\t    }\n\n    \t\t\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;JDBC连接池-JDBCTemplate&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;JDBC连接池&amp;JDBCTemplate&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JDBC连接池&#34;,&#34;slug&#34;:&#34;ZRt8sBVHK4&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/ZRt8sBVHK4/&#34;},{&#34;name&#34;:&#34;JDBCTemplate&#34;,&#34;slug&#34;:&#34;_ryo7rrMp3&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/_ryo7rrMp3/&#34;}],&#34;date&#34;:&#34;2020-02-20 19:02:03&#34;,&#34;dateFormat&#34;:&#34;2020-02-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/JDBC连接池-JDBCTemplate/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:437000,&#34;words&#34;:1576,&#34;minutes&#34;:8},&#34;description&#34;:&#34;数据库连接池\n1. 概念：\n\n\n其实就是一个容器(集合)，存放数据库连接的容器。\n当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。\n\n\n2. 好处：...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0\&#34;&gt;数据库连接池&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%A6%82%E5%BF%B5\&#34;&gt;1. 概念：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%A5%BD%E5%A4%84\&#34;&gt;2. 好处：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%AE%9E%E7%8E%B0\&#34;&gt;3. 实现：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-c3p0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%8A%80%E6%9C%AF\&#34;&gt;4. C3P0：数据库连接池技术&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E7%94%B1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%8F%90%E4%BE%9B%E7%9A%84\&#34;&gt;5. Druid：数据库连接池实现技术，由阿里巴巴提供的&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#spring-jdbc\&#34;&gt;Spring JDBC&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;端口\&#34;&gt;端口&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;1-端口读写指令\&#34;&gt;1. 端口读写指令&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;in&lt;/li&gt;\n&lt;li&gt;out&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;访问端口&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;in al , 60h;把60h中的数据读入al中\n;1.cpu 通过地址线 将地址信息 60h 发出\n;2.cpu 通过控制总线发出读命令 选择端口所在的芯片 并通知他 要从中读取数据\n;3.端口所在的芯片 将60h端口中的数据通过数据线送入cpu\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2cmos-ram\&#34;&gt;2.CMOS RAM&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;地址端口&lt;mark&gt;70h&lt;/mark&gt;&lt;/li&gt;\n&lt;li&gt;数据端口 &lt;mark&gt;71h&lt;/mark&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;3shlshr\&#34;&gt;3.shl,shr&lt;/h2&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;移位指令&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;左移&lt;/strong&gt;--&amp;gt;  *2&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;右移&lt;/strong&gt;–&amp;gt; \\2&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-端口&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-端口&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:42:33&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-端口/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:29000,&#34;words&#34;:126,&#34;minutes&#34;:1},&#34;description&#34;:&#34;端口\n\n1. 端口读写指令\n\n\nin\nout\n\n\n访问端口\n\nin al , 60h;把60h中的数据读入al中\n;1.cpu 通过地址线 将地址信息 60h 发出\n;2.cpu 通过控制总线发出读命令 选择端口所在的芯片 并通知他 要从中...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AB%AF%E5%8F%A3\&#34;&gt;端口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E7%AB%AF%E5%8F%A3%E8%AF%BB%E5%86%99%E6%8C%87%E4%BB%A4\&#34;&gt;1. 端口读写指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2cmos-ram\&#34;&gt;2.CMOS RAM&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3shlshr\&#34;&gt;3.shl,shr&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;内中断&lt;/p&gt;\n&lt;h2 id=\&#34;1产生\&#34;&gt;1.产生&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;除法溢出&lt;/li&gt;\n&lt;li&gt;单步执行&lt;/li&gt;\n&lt;li&gt;执行into指令&lt;/li&gt;\n&lt;li&gt;执行Int 指令&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;2-中断处理程序\&#34;&gt;2. 中断处理程序&lt;/h2&gt;\n&lt;h2 id=\&#34;3-中断向量表\&#34;&gt;3. 中断向量表&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;中断程序的入口地址&lt;/li&gt;\n&lt;li&gt;存放256个中断程序入口地址&lt;/li&gt;\n&lt;li&gt;存放在 &lt;strong&gt;0000:0000&lt;/strong&gt; 到 &lt;strong&gt;0000:03FF&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;一个表项占两个字，高-&amp;gt;段地址&lt;strong&gt;CS&lt;/strong&gt; 低-&amp;gt;偏移地址&lt;strong&gt;IP&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;4中断的过程\&#34;&gt;4.中断的过程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;取得中断类型码N&lt;/li&gt;\n&lt;li&gt;pushf&lt;/li&gt;\n&lt;li&gt;TF=0,IF=0&lt;/li&gt;\n&lt;li&gt;push CS&lt;/li&gt;\n&lt;li&gt;push IP&lt;/li&gt;\n&lt;li&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=\&#34;true\&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(IP)=(N*4),CS=(N*4)+2\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07847em;\&#34;&gt;I&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;4&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mpunct\&#34;&gt;,&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.16666666666666666em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.05764em;\&#34;&gt;S&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;4&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;开始执行中断程序&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;5中断处理程序和iret指令\&#34;&gt;5.中断处理程序和iret指令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;中断程序写法的常规步骤\n&lt;ul&gt;\n&lt;li&gt;保存要用的寄存器&lt;/li&gt;\n&lt;li&gt;处理中断&lt;/li&gt;\n&lt;li&gt;回复寄存器&lt;/li&gt;\n&lt;li&gt;用iret指令返回 --&amp;gt; pop ip,pop cs,pop popf(pop psw)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;6-除法错误中断的处理\&#34;&gt;6. 除法错误中断的处理&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;1. 出现溢出\n2. 产生0号中断信息\n3. 执行0号中断\n4. 返回操作系统\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;7-编程处理0号中断\&#34;&gt;7. 编程处理0号中断&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;分析：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;当发生除法溢出时，产生0号中断信息，从而引发中断过程\n&lt;ol&gt;\n&lt;li&gt;取得中断类型码N&lt;/li&gt;\n&lt;li&gt;pushf&lt;/li&gt;\n&lt;li&gt;TF=0,IF=0&lt;/li&gt;\n&lt;li&gt;push CS&lt;/li&gt;\n&lt;li&gt;push IP&lt;/li&gt;\n&lt;li&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=\&#34;true\&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(IP)=(N*4),CS=(N*4)+2\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07847em;\&#34;&gt;I&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;4&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mpunct\&#34;&gt;,&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.16666666666666666em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.05764em;\&#34;&gt;S&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;4&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;发生0号中断时，Cpu转去执行中断处理程序\n&lt;ol&gt;\n&lt;li&gt;相关处理&lt;/li&gt;\n&lt;li&gt;向显示缓冲区送字符串&lt;/li&gt;\n&lt;li&gt;返回DOS&lt;/li&gt;\n&lt;li&gt;&lt;mark&gt;do0&lt;/mark&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;do0的程序应该放在那里\n&lt;ol&gt;\n&lt;li&gt;放在0号中断的向量表中0000:0200-0000:02FF&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;中断程序的入口地址放在那里\n&lt;ol&gt;\n&lt;li&gt;cs:0000:0002,ip:0000:0000&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;总结&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;编写中断处理程序do0&lt;/li&gt;\n&lt;li&gt;将do0送入0000:0200&lt;/li&gt;\n&lt;li&gt;将do0的入口地址送到存储在中断向量表0号表项中&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;assume cs:code\n\ncode segment\n\nstart:\tdo0安装程序\n\t\t设置中断向量表\n\t\tmov ax,4c00h\n\t\tint 21h\ndo0:\t显示字符串“overflow”\n\t\tmov ax,4c00h\n\t\tint 21h\n\ncode ends\nend start\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-内中断&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-内中断&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:40:53&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-内中断/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:116000,&#34;words&#34;:459,&#34;minutes&#34;:2},&#34;description&#34;:&#34;内中断\n1.产生\n\n除法溢出\n单步执行\n执行into指令\n执行Int 指令\n\n2. 中断处理程序\n3. 中断向量表\n\n中断程序的入口地址\n存放256个中断程序入口地址\n存放在 0000:0000 到 0000:03FF\n一个表项占两个字，高...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E4%BA%A7%E7%94%9F\&#34;&gt;1.产生&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F\&#34;&gt;2. 中断处理程序&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8\&#34;&gt;3. 中断向量表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E4%B8%AD%E6%96%AD%E7%9A%84%E8%BF%87%E7%A8%8B\&#34;&gt;4.中断的过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8Ciret%E6%8C%87%E4%BB%A4\&#34;&gt;5.中断处理程序和iret指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E9%99%A4%E6%B3%95%E9%94%99%E8%AF%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86\&#34;&gt;6. 除法错误中断的处理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%860%E5%8F%B7%E4%B8%AD%E6%96%AD\&#34;&gt;7. 编程处理0号中断&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;标志寄存器\&#34;&gt;标志寄存器&lt;/h1&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023411.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;cf标志位carry-flag\&#34;&gt;CF标志位&lt;strong&gt;Carry Flag&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023554.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;进位（最高位进位）add&lt;/li&gt;\n&lt;li&gt;和运算相关的指令会影响标志位 like &lt;mark&gt;add , sub&lt;/mark&gt;&lt;/li&gt;\n&lt;li&gt;把操作数当作无符号数字&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;zf标志位zero-flag\&#34;&gt;ZF标志位&lt;strong&gt;Zero Flag&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023620.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;判断相等&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;最后结果是否为零&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;pf标志位pairty-flag\&#34;&gt;PF标志位&lt;strong&gt;pairty Flag&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;一的个数是否位偶数0 or 奇数1&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023658.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;sf标志位sign-flag\&#34;&gt;SF标志位&lt;strong&gt;Sign Flag&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;正0负1&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023719.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;计算的结果看陈整数和负数&lt;/li&gt;\n&lt;li&gt;add sub 影响sf&lt;/li&gt;\n&lt;li&gt;mul 不影响sf&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;of标志位overflow\&#34;&gt;OF标志位&lt;strong&gt;Overflow&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023748.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;运算过程中看是否溢出&lt;/li&gt;\n&lt;li&gt;两个操作数都当做有符号 运算过程中决定是否溢出&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;adc-带进位的加法寄存器\&#34;&gt;adc 带进位的加法寄存器&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;可以对更大的数字进行加法运算&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;sbb-带借位减法\&#34;&gt;sbb 带借位减法&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;实现对更大数的减法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;cmp-比较指令\&#34;&gt;cmp 比较指令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;类似于减法指令 只是不保存结果，只是影响相关的标志位寄存器&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可以判断两个操作数的大小 通过 sf of 标志位&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;sf&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;of&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;大小&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;0&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&amp;lt;2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;0&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&amp;lt;2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&amp;gt;2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;0&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;0&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&amp;gt;2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;检测比较结果的转移指令&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;和 cmp指令配合使用\n&lt;ul&gt;\n&lt;li&gt;\n&lt;blockquote&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;指令&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;含义&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;检测相关的标志位&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;je&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;equal&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;zf=1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;jne&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;not equal&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;zf=0&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;jb&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;below&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;cf=0&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;jnb&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;not below&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;cf=1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;ja&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;above&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;cf=0 &amp;amp;&amp;amp; zf=1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;jna&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;not above&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;cf=1 || zf=1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;df-标志和串传送指令\&#34;&gt;DF 标志和串传送指令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;movsb&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;movsw&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;配合rep 使用 rep like loop 由cx 的大小决定 执行 上述 两条指令的 次数&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;exp&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;;-========movsb=====\nmov cx,16\nrep movsb\n;循环16次 每次执行完后 si di ++\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;;========movsw\nmov cx,16\nrep movsw\n;循环16次每次 执行完 si,di --\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;cld -&amp;gt; df==0**++**&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;std -&amp;gt; df==1**--**&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;pushf-popf\&#34;&gt;pushf &amp;amp;&amp;amp; popf&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;使 标志位寄存器 压栈和出栈&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-标志寄存器&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-标志寄存器&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:29:12&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-标志寄存器/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:105000,&#34;words&#34;:423,&#34;minutes&#34;:2},&#34;description&#34;:&#34;标志寄存器\n\n\n\n\n\nCF标志位Carry Flag\n\n\n进位（最高位进位）add\n和运算相关的指令会影响标志位 like add , sub\n把操作数当作无符号数字\n\nZF标志位Zero Flag\n\n\n\n\n\n判断相等\n\n\n最后结果是否为零...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8\&#34;&gt;标志寄存器&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#cf%E6%A0%87%E5%BF%97%E4%BD%8Dcarry-flag\&#34;&gt;CF标志位&lt;strong&gt;Carry Flag&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#zf%E6%A0%87%E5%BF%97%E4%BD%8Dzero-flag\&#34;&gt;ZF标志位&lt;strong&gt;Zero Flag&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#pf%E6%A0%87%E5%BF%97%E4%BD%8Dpairty-flag\&#34;&gt;PF标志位&lt;strong&gt;pairty Flag&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sf%E6%A0%87%E5%BF%97%E4%BD%8Dsign-flag\&#34;&gt;SF标志位&lt;strong&gt;Sign Flag&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#of%E6%A0%87%E5%BF%97%E4%BD%8Doverflow\&#34;&gt;OF标志位&lt;strong&gt;Overflow&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#adc-%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E5%AF%84%E5%AD%98%E5%99%A8\&#34;&gt;adc 带进位的加法寄存器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sbb-%E5%B8%A6%E5%80%9F%E4%BD%8D%E5%87%8F%E6%B3%95\&#34;&gt;sbb 带借位减法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cmp-%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4\&#34;&gt;cmp 比较指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#df-%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4\&#34;&gt;DF 标志和串传送指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#pushf-popf\&#34;&gt;pushf &amp;amp;&amp;amp; popf&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;ret-和-call\&#34;&gt;ret 和 call&lt;/h1&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;指令执行过程\n&lt;ul&gt;\n&lt;li&gt;{% asset_img 20190928095954.png %}&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;通过栈中的数据来修改 cs  和 ip 同时还会 修改栈顶标志&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;ret用栈中的数据\&#34;&gt;ret（用栈中的数据）&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;弹栈&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;近转移 ret 修改 IP &lt;em&gt;&lt;strong&gt;pop ip&lt;/strong&gt;&lt;/em&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(ip)=((ss)*16+(sp))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;i&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.72777em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;\n&lt;li&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(sp)=(sp)+2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;远转移 retf 修改 cs:ip &lt;em&gt;&lt;strong&gt;pop ip,pop cs&lt;/strong&gt;&lt;/em&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(ip)=((ss)*16+(sp))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;i&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.72777em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;\n&lt;li&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(sp)=(sp)+2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;\n&lt;li&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(cs)=((ss)*16+(sp))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;c&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.72777em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;\n&lt;li&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(sp)=(sp)+2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;p&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;call不能实现短转移\&#34;&gt;call(不能实现短转移)&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;类似&lt;strong&gt;jmp&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;call程序处理的数据一般要进行压栈&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;1根据位移进行转移\&#34;&gt;1.根据位移进行转移&lt;/h3&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;push ip\njmp near ptr 标号\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;执行过程 原理\n&lt;ul&gt;\n&lt;li&gt;call下一条指令的IP压栈后，转到标号处&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;2转移目的地址在指令中\&#34;&gt;2.转移目的地址在指令中&lt;/h3&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;call far ptr\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;执行过程 原理\n&lt;ul&gt;\n&lt;li&gt;call下一条指令的CS:IP压栈后，转到标号处&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;3转移地址在寄存器中\&#34;&gt;3.转移地址在寄存器中&lt;/h3&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;call 16 位 reg\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;执行过程 原理\n&lt;ul&gt;\n&lt;li&gt;call下一条指令的IP压栈后，转到&lt;mark&gt;reg&lt;/mark&gt; 处&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;4-转移地址在内存中\&#34;&gt;4. 转移地址在内存中&lt;/h3&gt;\n&lt;hr&gt;\n&lt;h4 id=\&#34;1\&#34;&gt;1&lt;/h4&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;call word ptr 内存单元地址\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;执行过程 原理\n&lt;ul&gt;\n&lt;li&gt;call下一条指令的IP压栈后，转到&lt;mark&gt;内存单元地址&lt;/mark&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;2\&#34;&gt;2&lt;/h4&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;call dword ptr 内存单元地址\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;执行过程 原理\n&lt;ul&gt;\n&lt;li&gt;call下一条指令的CS:IP压栈后，转到标号处&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;call-和-ret-共同应用\&#34;&gt;call 和 ret 共同应用&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;就像函数调用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;批量数据处理\&#34;&gt;批量数据处理&lt;/h3&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;assume cs:code,ds:data,ss:stack\n\ndata segment\n\tdb &#39;conversation&#39;\ndata ends\n\nstack segment\n\tdb 16 dup(0)\nstack ends\n\ncode segment\n\n\n\tstart:  mov ax,data\n\t\t\tmov ds,ax\n\t\t\tmov si,0\n\t\t\tmov cx,12\n\t\t\tcall capital\n\t\t\tmov ax,4c00h\n\t\t\tint 21h\n\n\tcapital: and byte ptr ds:[si],11011111b\n\t\t\t inc si;\n\t\t\t loop capital\n\t\t\t ret\n\n\ncode ends\n\n\n\nend start\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;寄存器冲突问题\&#34;&gt;寄存器冲突问题&lt;/h3&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;在子程序执行开头，把所需要用到的寄存器压栈&lt;/li&gt;\n&lt;li&gt;在子程序完成后，从栈中弹出各个寄存其的值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;assume cs:code,ds:data,ss:stack\n\ndata segment\n\tdb &#39;word&#39;,0\n\tdb &#39;unix&#39;,0\n\tdb &#39;wind&#39;,0\n\tdb &#39;good&#39;,0\ndata ends\n\nstack segment\n\tdb 128 dup(0)\nstack ends\n\ncode segment\n\n\n\tstart:  mov ax,data\n\t\t\tmov ds,ax\n\n\t\t\tmov cx,4\n\t\t\tmov bx,0\n\n\ts:      mov di,bx\n\t\t\tcall capital\n\t\t\tadd bx,5\n\t\t\tloop s\n\n\t\t\tmov ax,4c00h\n\t\t\tint 21h\n\n\tcapital: push cx;执行子程序前压栈\n\t\t\t push si\n\n\tchange:\t mov cl,ds:[si]\n\t\t\t mov ch,0\n\t\t\t jcxz ok\n\t\t\t and byte ptr ds:[si],11011111b\n\t\t\t inc si\n\t\t\t jmp change\n\n\t\tok:\t pop si;执行完后弹栈\n\t\t\t pop cx\n\t\t\t ret\n\n\ncode ends\n\n\n\nend start\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;mul\&#34;&gt;mul&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;1-8位\&#34;&gt;1. 8位&lt;/h3&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;一个默认放在&lt;mark&gt;AL&lt;/mark&gt;，另一个放在&lt;mark&gt;内存字节单元&lt;/mark&gt;或者&lt;mark&gt;8位reg&lt;/mark&gt;。&lt;/p&gt;\n&lt;p&gt;结果 默认 &lt;mark&gt;AX&lt;/mark&gt;。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;2-16位\&#34;&gt;2. 16位&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;一个默认放在&lt;mark&gt;AX&lt;/mark&gt;，另一个放在&lt;mark&gt;内存字单元&lt;/mark&gt;或者&lt;mark&gt;16位reg&lt;/mark&gt;。&lt;/p&gt;\n&lt;p&gt;结果 默认 高位在&lt;mark&gt;DX&lt;/mark&gt; ，低位在&lt;mark&gt;AX&lt;/mark&gt;。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;模块化程序设计\&#34;&gt;模块化程序设计&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;通过&lt;mark&gt;ret&lt;/mark&gt;,&lt;mark&gt;call&lt;/mark&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;参数和结果的传递\&#34;&gt;参数和结果的传递&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;assume cs:code,ds:data,ss:stack\n\ndata segment\n\tdw 1,2,3,4,5,6,7,8\n\tdd 0,0,0,0,0,0,0,0\n\tdb &#39;word&#39;,0\n\tdb &#39;unix&#39;,0\n\tdb &#39;wind&#39;,0\n\tdb &#39;good&#39;,0\ndata ends\n\nstack segment\n\tdb 128 dup(0)\nstack ends\n\ncode segment\n\n\n\tstart:  mov ax,data\n\t\t\tmov ds,ax\n\t\t\tmov si,0\n\t\t\tmov bp,0\n\t\t\tcall r_start\n\n\n\t\t\tmov ax,4c00h\n\t\t\tint 21h\n\n\n\tr_start:\tmov bx,ds:[si]\n\t\t\t\tcall cube\n\t\t\t\tmov ds:[16+bp],ax\n\t\t\t\tadd si,2\n\t\t\t\tadd bp,4\n\t\t\t\tloop r_start\n\t\t\t\tret\n\n\t\tcube:\tmov ax,bx\n\t\t\t\tmul bx\n\t\t\t\tmul bx\n\t\t\t\tret\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-ret和call&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-ret和call&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:23:28&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-ret和call/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:219000,&#34;words&#34;:758,&#34;minutes&#34;:4},&#34;description&#34;:&#34;ret 和 call\n\n\n指令执行过程\n\n{% asset_img 20190928095954.png %}\n\n\n\n通过栈中的数据来修改 cs  和 ip 同时还会 修改栈顶标志\nret（用栈中的数据）\n\n\n弹栈\n\n\n近转移 ret 修改...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#ret-%E5%92%8C-call\&#34;&gt;ret 和 call&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ret%E7%94%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE\&#34;&gt;ret（用栈中的数据）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#call%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E7%9F%AD%E8%BD%AC%E7%A7%BB\&#34;&gt;call(不能实现短转移)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB\&#34;&gt;1.根据位移进行转移&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E8%BD%AC%E7%A7%BB%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD\&#34;&gt;2.转移目的地址在指令中&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD\&#34;&gt;3.转移地址在寄存器中&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD\&#34;&gt;4. 转移地址在内存中&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1\&#34;&gt;1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2\&#34;&gt;2&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#call-%E5%92%8C-ret-%E5%85%B1%E5%90%8C%E5%BA%94%E7%94%A8\&#34;&gt;call 和 ret 共同应用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86\&#34;&gt;批量数据处理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98\&#34;&gt;寄存器冲突问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#mul\&#34;&gt;mul&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-8%E4%BD%8D\&#34;&gt;1. 8位&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-16%E4%BD%8D\&#34;&gt;2. 16位&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\&#34;&gt;模块化程序设计&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E4%BC%A0%E9%80%92\&#34;&gt;参数和结果的传递&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;转移指令\&#34;&gt;转移指令&lt;/h1&gt;\n&lt;h2 id=\&#34;1-操作符-offset\&#34;&gt;1. 操作符 offset&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;取得标号的偏移地址&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2-jmp-指令\&#34;&gt;2. jmp 指令&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;无条件转移指令&lt;/li&gt;\n&lt;li&gt;可同时修改 cs 和 ip 或者 ip&lt;/li&gt;\n&lt;li&gt;给出两种信息\n&lt;ul&gt;\n&lt;li&gt;目的地址&lt;/li&gt;\n&lt;li&gt;转移的距离（段间，段内短转移，段内近转移）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;3-依据位移进行的jmp指令\&#34;&gt;3. 依据位移进行的jmp指令&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;jmp-short-标号\&#34;&gt;jmp short 标号&lt;/h3&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;在编译是就已经处理好 要偏移的地址&lt;/li&gt;\n&lt;li&gt;无论 本 命令在哪 只有 偏移地址&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;jmp-near-ptr-标号\&#34;&gt;jmp near ptr 标号&lt;/h3&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;段内短转移&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;4-转移的目的地址在指令中的jmp指令\&#34;&gt;4. 转移的目的地址在指令中的jmp指令&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h3 id=\&#34;jmp-far-ptr-标号\&#34;&gt;jmp far ptr 标号&lt;/h3&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;同时修改 cs 和 ip&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;5-转移地址在寄存器中的jmp指令\&#34;&gt;5. 转移地址在寄存器中的jmp指令&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;jmp ax&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;6-在内存中转移\&#34;&gt;6 .在内存中转移&lt;/h2&gt;\n&lt;hr&gt;\n&lt;h4 id=\&#34;jmp-word-ptr-标号\&#34;&gt;jmp word ptr 标号&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;jmp word ptr ds:[0]&lt;/li&gt;\n&lt;li&gt;只修改 IP&lt;/li&gt;\n&lt;li&gt;段内转移&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;jmp-dword-ptr-标号\&#34;&gt;jmp dword ptr 标号&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;段间转移&lt;/li&gt;\n&lt;li&gt;ip[X+0],cs[X+2]&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;jcxz-短转移\&#34;&gt;jcxz （短转移）&lt;/h3&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;所有的有条件的跳转指令都是短转移&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;jmp cx zero&lt;/li&gt;\n&lt;li&gt;只有在cx 为0 的情况下 才 执行 转移&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;loop短转移\&#34;&gt;loop（短转移）&lt;/h3&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;所有的循环指令都是短转移&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;cx 不为0 执行loop&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-转移指令&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-转移指令&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:18:59&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-转移指令/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:62000,&#34;words&#34;:266,&#34;minutes&#34;:2},&#34;description&#34;:&#34;转移指令\n1. 操作符 offset\n\n\n取得标号的偏移地址\n\n2. jmp 指令\n\n\n无条件转移指令\n可同时修改 cs 和 ip 或者 ip\n给出两种信息\n\n目的地址\n转移的距离（段间，段内短转移，段内近转移）\n\n\n\n3. 依据位移进行的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4\&#34;&gt;转移指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%93%8D%E4%BD%9C%E7%AC%A6-offset\&#34;&gt;1. 操作符 offset&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-jmp-%E6%8C%87%E4%BB%A4\&#34;&gt;2. jmp 指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E7%9A%84jmp%E6%8C%87%E4%BB%A4\&#34;&gt;3. 依据位移进行的jmp指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#jmp-short-%E6%A0%87%E5%8F%B7\&#34;&gt;jmp short 标号&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jmp-near-ptr-%E6%A0%87%E5%8F%B7\&#34;&gt;jmp near ptr 标号&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4\&#34;&gt;4. 转移的目的地址在指令中的jmp指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#jmp-far-ptr-%E6%A0%87%E5%8F%B7\&#34;&gt;jmp far ptr 标号&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4\&#34;&gt;5. 转移地址在寄存器中的jmp指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BD%AC%E7%A7%BB\&#34;&gt;6 .在内存中转移&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#jmp-word-ptr-%E6%A0%87%E5%8F%B7\&#34;&gt;jmp word ptr 标号&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jmp-dword-ptr-%E6%A0%87%E5%8F%B7\&#34;&gt;jmp dword ptr 标号&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jcxz-%E7%9F%AD%E8%BD%AC%E7%A7%BB\&#34;&gt;jcxz （短转移）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#loop%E7%9F%AD%E8%BD%AC%E7%A7%BB\&#34;&gt;loop（短转移）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;数据处理的两个基本问题\&#34;&gt;数据处理的两个基本问题&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;sreg 段地址寄存器&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;reg&lt;/strong&gt; 寄存器&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;bxsidi和bp\&#34;&gt;bx,si,di和bp&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;bx si/di组合&lt;/li&gt;\n&lt;li&gt;bp si/di组合&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;指令要处理的数据\&#34;&gt;指令要处理的数据&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;保存在CPU&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;在内存中&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;在端口中&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;数据位置的表达\&#34;&gt;数据位置的表达&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;立即数(idata)&lt;/li&gt;\n&lt;li&gt;寄存器&lt;/li&gt;\n&lt;li&gt;段地址加偏移地址&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;数据的长度\&#34;&gt;数据的长度&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;byte 和 word&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;在处理数据的时候要 告知 CPU 要处理的数据有多大可以通过一些方法来告知&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;1. 通过寄存器来指明 如 &lt;mark&gt;ax&lt;/mark&gt;,代表对word操作而 &lt;mark&gt;al&lt;/mark&gt;,代表对byte 操作&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;2. 无寄存器 则用 &lt;mark&gt;X ptr&lt;/mark&gt; 来表示 X 为byte 或者 word  如 ： mov word ptr ds:[0],1&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;3.  用 push or pop 就不用 声明 因为 栈就是 对字进行操作&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;div-指令\&#34;&gt;div 指令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;除数&lt;/strong&gt; 有8位和16位 在一个reg或内存单元中&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;被除数&lt;/strong&gt; 默认 放在 &lt;mark&gt;ax（16位）&lt;/mark&gt; 或者 &lt;mark&gt;dx（高16位） 和 ax（低16位）&lt;/mark&gt; 中&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;  &lt;mark&gt;al(商) ah(余数)&lt;/mark&gt; 或者 &lt;mark&gt;ax(商) dx(余数)&lt;/mark&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;伪指令-dd-占两个字\&#34;&gt;伪指令 dd (占两个字)&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;相当于 两个 &lt;mark&gt;dw&lt;/mark&gt;&lt;/li&gt;\n&lt;li&gt;四个 &lt;mark&gt;db&lt;/mark&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dup\&#34;&gt;dup&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;用来重复数据&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;db 3 dup (0)  ==&amp;gt; db 0 ,0, 0&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-数据处理的两个基本问题&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-数据处理的两个基本问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:16:30&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-数据处理的两个基本问题/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:66000,&#34;words&#34;:278,&#34;minutes&#34;:2},&#34;description&#34;:&#34;数据处理的两个基本问题\n\nsreg 段地址寄存器\nreg 寄存器\n\nbx,si,di和bp\n\nbx si/di组合\nbp si/di组合\n\n指令要处理的数据\n\n保存在CPU\n在内存中\n在端口中\n\n数据位置的表达\n\n立即数(idata)\n寄存...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98\&#34;&gt;数据处理的两个基本问题&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#bxsidi%E5%92%8Cbp\&#34;&gt;bx,si,di和bp&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E4%BB%A4%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE\&#34;&gt;指令要处理的数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE\&#34;&gt;数据位置的表达&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%95%BF%E5%BA%A6\&#34;&gt;数据的长度&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#div-%E6%8C%87%E4%BB%A4\&#34;&gt;div 指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%AA%E6%8C%87%E4%BB%A4-dd-%E5%8D%A0%E4%B8%A4%E4%B8%AA%E5%AD%97\&#34;&gt;伪指令 dd (占两个字)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dup\&#34;&gt;dup&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;定位内存地址的方法\&#34;&gt;定位内存地址的方法&lt;/h1&gt;\n&lt;h2 id=\&#34;and-和-or\&#34;&gt;and 和 or&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;and 逻辑与  0  置为0\n&lt;ol&gt;\n&lt;li&gt;全为 &lt;strong&gt;1&lt;/strong&gt; 才出 &lt;strong&gt;1&lt;/strong&gt; 否则全部为 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;可用于 对 二进制位的数字 设 &lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;or 逻辑或     1  置为1\n&lt;ol&gt;\n&lt;li&gt;只要有&lt;strong&gt;1&lt;/strong&gt; 就为 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;可用于对 二进制数字设 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;以字符的形式给出数据\&#34;&gt;以字符的形式给出数据&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;like  ‘………’ \t其中单引号包含的 内容 编译器将把 其中的内容 转化为相应的 ASCII&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;大小写转换\&#34;&gt;大小写转换&lt;/h2&gt;\n&lt;p&gt;and 置为大写 1101 1111b&lt;/p&gt;\n&lt;p&gt;or    置为小写 0100 0000b&lt;/p&gt;\n&lt;h2 id=\&#34;bxidata\&#34;&gt;[bx+idata]&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;idata 是立即数&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;常用格式&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;mov ax,[200+bx]&lt;/li&gt;\n&lt;li&gt;mov ax,200[bx]&lt;/li&gt;\n&lt;li&gt;mov ax,[bx].200&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;可以处理数组&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;si-和-di\&#34;&gt;SI 和 DI&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;类似于&lt;strong&gt;BX&lt;/strong&gt; &lt;mark&gt;但是&lt;/mark&gt; 不能 分成两个 8 为寄存器&lt;/li&gt;\n&lt;li&gt;全为偏移地址寄存器 &lt;strong&gt;&lt;mark&gt;bx为基址寄存器&lt;/mark&gt;&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;bxsi-和-bxdi\&#34;&gt;[BX+SI] \t和 [BX+DI]&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;常用格式&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;mov ax,[bx] [si]&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;bxsiidata-和-bxdiidata\&#34;&gt;[BX+SI+idata] 和 [bx+di+idata]&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-定位内存地址的方法&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-定位内存地址的方法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:13:02&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-定位内存地址的方法/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:52000,&#34;words&#34;:213,&#34;minutes&#34;:1},&#34;description&#34;:&#34;定位内存地址的方法\nand 和 or\n\nand 逻辑与  0  置为0\n\n全为 1 才出 1 否则全部为 0\n可用于 对 二进制位的数字 设 0\n\n\nor 逻辑或     1  置为1\n\n只要有1 就为 1\n可用于对 二进制数字设 1\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;定位内存地址的方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#and-%E5%92%8C-or\&#34;&gt;and 和 or&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A5%E5%AD%97%E7%AC%A6%E7%9A%84%E5%BD%A2%E5%BC%8F%E7%BB%99%E5%87%BA%E6%95%B0%E6%8D%AE\&#34;&gt;以字符的形式给出数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2\&#34;&gt;大小写转换&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bxidata\&#34;&gt;[bx+idata]&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#si-%E5%92%8C-di\&#34;&gt;SI 和 DI&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bxsi-%E5%92%8C-bxdi\&#34;&gt;[BX+SI] \t和 [BX+DI]&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bxsiidata-%E5%92%8C-bxdiidata\&#34;&gt;[BX+SI+idata] 和 [bx+di+idata]&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;自己分配内存\&#34;&gt;自己分配内存&lt;/h1&gt;\n&lt;h2 id=\&#34;自己分配内存-2\&#34;&gt;自己分配内存&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;一个 segement 最少占据 16 个字节&lt;/li&gt;\n&lt;li&gt;\n&lt;blockquote&gt;\n&lt;p&gt;假设 数据段 有 N个字节 则 实际占用 $$(N/16 + 1)*16$$ 个&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;都是 16 的倍数&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Assembly\&#34;&gt;//实验5\nassume cs:codesg\n\na segment\n\t\tdb 1,2,3,4,5,6,7,8\na ends\n\nb segment\n\t\tdb 1,2,3,4,5,6,7,8\nb ends\n\nc segment\n\t\tdb 0,0,0,0,0,0,0,0\nc ends\n\ncodesg segment\n\nstart:\n\n\n\t\tmov ax,c\n\t\tmov es,ax\n\n\n\t\tsub cx,cx\n\t\tsub bx,bx\n\t\tadd cx,8\n\naddnum: mov ax,a\n\t\tmov ds,ax\n\n\t\tsub dx,dx\n\n\t\tmov dl,ds:[bx] ;拿出第一个数据\n\n\t\tmov ax,b\n\t\tmov ds,ax\n\n\t\tadd dl,ds:[bx]  ;拿出第二个数据,并且相加\n\n\t\tmov es:[bx],dl\n\n\t\tinc bx\n\n\t\tloop addnum\n\n\n\n\tmov ax,4c00h\n\tint 21h\n\ncodesg ends\n\nend start\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;db 字节型&lt;/li&gt;\n&lt;li&gt;dw 字型&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-自己分配内存&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-自己分配内存&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:10:29&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-自己分配内存/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:55000,&#34;words&#34;:180,&#34;minutes&#34;:1},&#34;description&#34;:&#34;自己分配内存\n自己分配内存\n\n一个 segement 最少占据 16 个字节\n\n\n假设 数据段 有 N个字节 则 实际占用 $$(N/16 + 1)*16$$ 个\n\n\n都是 16 的倍数\n\n//实验5\nassume cs:codesg\n\na...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%B7%B1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\&#34;&gt;自己分配内存&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%B7%B1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98-2\&#34;&gt;自己分配内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;第一个程序\&#34;&gt;第一个程序&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;编译和链接\&#34;&gt;编译和链接&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;编译 masm .mas --&amp;gt; .obj&lt;/li&gt;\n&lt;li&gt;链接 link .obj --&amp;gt; .exe&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;exe 文件 的描述信息中 保存的程序入口 地址&lt;br&gt;\n然后 系统 通过 描述文件 来设置 cs:ip 和 其它内存&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;asm 文件 -- 汇编语言（&lt;strong&gt;1.汇编指令2.伪指令3.符号体系&lt;/strong&gt;）&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;汇编指令 由编译器 翻译成010101 的机器指令 最后由 &lt;em&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;/em&gt; 执行&lt;/li&gt;\n&lt;li&gt;伪指令和符号体系 由编译器执行&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;程序返回功能&lt;br&gt;\n把系统加载程序的时候 给程序分配的内存 ， 设置的寄存器 返还给系统，因为 系统资源 是有限的&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt; mov ax,4c00\n int 21H\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;程序的跟踪-debug-程序名\&#34;&gt;程序的跟踪 debug + 程序名&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;p 执行 int 指令&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;q 退出&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;cx == 程序长度&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;PSP区 从 &lt;em&gt;&lt;strong&gt;ds:0&lt;/strong&gt;&lt;/em&gt; 开始的 256 个字节&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;快速编译\&#34;&gt;快速编译&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;字母型数字前面 必须加 0；&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;默认代码（目前）&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;assum cs:code\n\ncode segment\n\n     ;填写内容\n\n     mov ax,4c00H\n     int 21H\n\ncode ends\n\nend\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;偏移地址寄存器-bx\&#34;&gt;偏移地址寄存器 &lt;em&gt;&lt;strong&gt;bx&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-第一个程序&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-第一个程序&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 22:01:09&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-第一个程序/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:57000,&#34;words&#34;:249,&#34;minutes&#34;:1},&#34;description&#34;:&#34;第一个程序\n\n编译和链接\n\n编译 masm .mas --&amp;gt; .obj\n链接 link .obj --&amp;gt; .exe\n\n\nexe 文件 的描述信息中 保存的程序入口 地址\n然后 系统 通过 描述文件 来设置 cs:ip 和 其它内...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F\&#34;&gt;第一个程序&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5\&#34;&gt;编译和链接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B7%9F%E8%B8%AA-debug-%E7%A8%8B%E5%BA%8F%E5%90%8D\&#34;&gt;程序的跟踪 debug + 程序名&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BF%AB%E9%80%9F%E7%BC%96%E8%AF%91\&#34;&gt;快速编译&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8-bx\&#34;&gt;偏移地址寄存器 &lt;em&gt;&lt;strong&gt;bx&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;寄存器内存访问\&#34;&gt;寄存器（内存访问）&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h4 id=\&#34;3个段\&#34;&gt;3个段&lt;/h4&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;数据段\&#34;&gt;数据段&lt;/h2&gt;\n&lt;h3 id=\&#34;1-字的存储\&#34;&gt;1. 字的存储&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;一次存放两个字节&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;2\&#34;&gt;2.&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;内存地址由 &lt;strong&gt;段地址&lt;/strong&gt; 和 &lt;strong&gt;偏移地址&lt;/strong&gt; 构成&lt;br&gt;\n其中段地址默认保存在DS寄存器当中&lt;br&gt;\n偏移地址由 &lt;strong&gt;[address]&lt;/strong&gt; 保存告知&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;3-movaddsub-指令\&#34;&gt;3. mov，add，sub 指令&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923023855.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;4-d-段地址偏移地址\&#34;&gt;4. -d 段地址：偏移地址&lt;/h3&gt;\n&lt;h3 id=\&#34;5-在内存中存放自己定义的数据通过-ds和-来-让cpu访问数据\&#34;&gt;5. 在内存中存放自己定义的数据，通过 &lt;em&gt;&lt;strong&gt;ds和[]&lt;/strong&gt;&lt;/em&gt; 来 让CPU访问数据&lt;/h3&gt;\n&lt;h2 id=\&#34;代码段\&#34;&gt;代码段&lt;/h2&gt;\n&lt;h3 id=\&#34;1-段地址存放在cs寄存器中\&#34;&gt;1. 段地址存放在cs寄存器中&lt;/h3&gt;\n&lt;h3 id=\&#34;2-偏移地址存放在ip寄存器当中\&#34;&gt;2. 偏移地址存放在ip寄存器当中&lt;/h3&gt;\n&lt;h3 id=\&#34;3-内存中存放代码\&#34;&gt;3. 内存中存放代码&lt;/h3&gt;\n&lt;h3 id=\&#34;4-修改csip中的值就可使cpu执行代码\&#34;&gt;4. 修改cs:ip中的值就可使CPU执行代码&lt;/h3&gt;\n&lt;h2 id=\&#34;栈段\&#34;&gt;栈段&lt;/h2&gt;\n&lt;h3 id=\&#34;1-栈的作用\&#34;&gt;1. 栈的作用&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;临时性保存数据&lt;/li&gt;\n&lt;li&gt;进行数据交换&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-assembly\&#34;&gt;-a\nmov ax,1000\nmov bx,2000\npush ax\npush bx\npop ax\npop bx\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;2-栈的寄存器sssp\&#34;&gt;2. 栈的寄存器ss:sp&lt;/h3&gt;\n&lt;h3 id=\&#34;3-操作指令puship\&#34;&gt;3. 操作指令push&amp;amp;ip&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;push 执行过程&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;1.sp=sp-2（栈顶标记）&lt;br&gt;\n2.传入字型数据&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;pop 执行过程&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;1.传出字或字节&lt;br&gt;\n2.sp=sp+2(栈顶标记）&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;栈顶标记 在 数据（内存地址）的上面 的 内存地址&lt;br&gt;\nsp 偏移地址寄存器 ss 段地址寄存器&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;4-处理数据时要-临时存放数据\&#34;&gt;4. 处理数据时要 ，临时存放数据&lt;/h3&gt;\n&lt;h3 id=\&#34;5-修改sssp中的值决定栈顶位置cpu在执行的过程中把我们定义的栈段当作栈使用\&#34;&gt;5. 修改ss:sp中的值，决定栈顶位置，CPU在执行的过程中把我们定义的栈段当作栈使用&lt;/h3&gt;\n&lt;h3 id=\&#34;6-一段连续的内存地址\&#34;&gt;6. 一段连续的内存地址&lt;/h3&gt;\n&lt;h3 id=\&#34;7-栈的容量的最大极限\&#34;&gt;7. 栈的容量的最大极限&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;sp 的变化范围 0~ffffH 32768 个字型数据&lt;br&gt;\ncall 将指令IP 保存到内存的哪里？  ret 可以拿回&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;保存到栈中 为了让 ret 从栈中取回&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;8每执行-一条-t-指令-就会将寄存器的值保存到-栈中\&#34;&gt;8.每执行 一条 -t 指令 就会将寄存器的值保存到 栈中&lt;/h3&gt;\n&lt;h2 id=\&#34;内存的安全访问\&#34;&gt;内存的安全访问&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;安全空间 0：200~0: 2ffH&lt;/li&gt;\n&lt;li&gt;内存分配的时间 1. 系统加载程序的时候 为程序分配的内存。2. 程序执行过程中，向系统再去要内存空间&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;承上启下\&#34;&gt;承上启下&lt;/h1&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;我们可以把内存任意的划分为 栈，数据，指令 ，他们可以是同一块内存，亦可以是不同的内存&lt;/li&gt;\n&lt;li&gt;cpu 通过 ss:sp 所指向的 内存作为 栈&lt;/li&gt;\n&lt;li&gt;ds:[] 所指向的 内存 作为数据&lt;/li&gt;\n&lt;li&gt;cs:ip 所指向的 内存 作为指令&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;指令从哪里？数据从哪来？临时性的数据存放到哪里？&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-寄存器（内存访问）&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-寄存器（内存访问）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 21:40:21&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-寄存器（内存访问）/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:131000,&#34;words&#34;:578,&#34;minutes&#34;:3},&#34;description&#34;:&#34;寄存器（内存访问）\n\n3个段\n\n数据段\n1. 字的存储\n\n一次存放两个字节\n\n2.\n\n内存地址由 段地址 和 偏移地址 构成\n其中段地址默认保存在DS寄存器当中\n偏移地址由 [address] 保存告知\n\n3. mov，add，sub 指令...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE\&#34;&gt;寄存器（内存访问）&lt;/a&gt;&lt;br&gt;\n*&lt;br&gt;\n*&lt;br&gt;\n* &lt;a href=\&#34;#3%E4%B8%AA%E6%AE%B5\&#34;&gt;3个段&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E6%AE%B5\&#34;&gt;数据段&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%AD%97%E7%9A%84%E5%AD%98%E5%82%A8\&#34;&gt;1. 字的存储&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2\&#34;&gt;2.&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-movaddsub-%E6%8C%87%E4%BB%A4\&#34;&gt;3. mov，add，sub 指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-d-%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80\&#34;&gt;4. -d 段地址：偏移地址&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%BF%87-ds%E5%92%8C-%E6%9D%A5-%E8%AE%A9cpu%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE\&#34;&gt;5. 在内存中存放自己定义的数据，通过 &lt;em&gt;&lt;strong&gt;ds和[]&lt;/strong&gt;&lt;/em&gt; 来 让CPU访问数据&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E6%AE%B5\&#34;&gt;代码段&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%AD%98%E6%94%BE%E5%9C%A8cs%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD\&#34;&gt;1. 段地址存放在cs寄存器中&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%AD%98%E6%94%BE%E5%9C%A8ip%E5%AF%84%E5%AD%98%E5%99%A8%E5%BD%93%E4%B8%AD\&#34;&gt;2. 偏移地址存放在ip寄存器当中&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E4%BB%A3%E7%A0%81\&#34;&gt;3. 内存中存放代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E4%BF%AE%E6%94%B9csip%E4%B8%AD%E7%9A%84%E5%80%BC%E5%B0%B1%E5%8F%AF%E4%BD%BFcpu%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81\&#34;&gt;4. 修改cs:ip中的值就可使CPU执行代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%88%E6%AE%B5\&#34;&gt;栈段&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8\&#34;&gt;1. 栈的作用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E6%A0%88%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8sssp\&#34;&gt;2. 栈的寄存器ss:sp&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4puship\&#34;&gt;3. 操作指令push&amp;amp;ip&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E6%97%B6%E8%A6%81-%E4%B8%B4%E6%97%B6%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE\&#34;&gt;4. 处理数据时要 ，临时存放数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E4%BF%AE%E6%94%B9sssp%E4%B8%AD%E7%9A%84%E5%80%BC%E5%86%B3%E5%AE%9A%E6%A0%88%E9%A1%B6%E4%BD%8D%E7%BD%AEcpu%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8A%8A%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A0%88%E6%AE%B5%E5%BD%93%E4%BD%9C%E6%A0%88%E4%BD%BF%E7%94%A8\&#34;&gt;5. 修改ss:sp中的值，决定栈顶位置，CPU在执行的过程中把我们定义的栈段当作栈使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E4%B8%80%E6%AE%B5%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80\&#34;&gt;6. 一段连续的内存地址&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E6%A0%88%E7%9A%84%E5%AE%B9%E9%87%8F%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9E%81%E9%99%90\&#34;&gt;7. 栈的容量的最大极限&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8%E6%AF%8F%E6%89%A7%E8%A1%8C-%E4%B8%80%E6%9D%A1-t-%E6%8C%87%E4%BB%A4-%E5%B0%B1%E4%BC%9A%E5%B0%86%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%80%BC%E4%BF%9D%E5%AD%98%E5%88%B0-%E6%A0%88%E4%B8%AD\&#34;&gt;8.每执行 一条 -t 指令 就会将寄存器的值保存到 栈中&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE\&#34;&gt;内存的安全访问&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B\&#34;&gt;承上启下&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;寄存器\&#34;&gt;寄存器&lt;/h1&gt;\n&lt;hr&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;小例子&lt;br&gt;\n1.1 B800：0400 回车&lt;br&gt;\n1.2 1空格 1空格&lt;br&gt;\n1.3 2空格 2空格&lt;br&gt;\n1.4    ...&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;汇编程序员 就是 通过 汇编语言 中的 汇编指令 去修改 寄存器的值 从而 控制 CPU 控制整个计算机&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;通用寄存器\&#34;&gt;通用寄存器&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;AX,BX,CX,DX&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;他们各自可分为两个 8 位寄存器(only)&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: Can&amp;#039;t use function &amp;#039;$&amp;#039; in math mode at position 9: ax=ah+al$̲$ $$(h==high,l=…&#39;&gt;ax=ah+al$$ $$(h==high,l==low)\n&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;1 byte = 8 bit(8位寄存器)==字节型数据&lt;br&gt;\n2 byte =16 bit(16位寄存器)&lt;mark&gt;字型数据  &lt;code&gt;2个字节&lt;/code&gt;&lt;br&gt;\n一个字型数据&lt;/mark&gt;2个字节型数据=高位字节+低位字&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;数据与寄存器之间 要 保持一致性，8位寄存器给8位数据，16为寄存器给16位数据&lt;/strong&gt;&lt;br&gt;\n&lt;mark&gt;不区&lt;/mark&gt;分大小写&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;地址寄存器指令寄存器-cs段地址和ip偏移地址\&#34;&gt;（地址寄存器）指令寄存器 CS（段地址）和IP（偏移地址）&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;jmp指令 jmp 2000:0 &lt;mark&gt;&lt;mark&gt;&amp;gt; cs&lt;/mark&gt;2000,ip&lt;/mark&gt;=0;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;mov ax,1000&lt;br&gt;\njmp ax&lt;br&gt;\n==&amp;gt; ip=1000;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;只能用jmp指令修改cs,ip&lt;/p&gt;\n&lt;p&gt;1.CPU从cs:ip 所指的内存单元中读取内容，存取到 指令缓存器当中&lt;br&gt;\n2.然后IP跳转到下一个指令位置，并且在执行指令缓存器当中的指令&lt;br&gt;\n3.重复1。&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;段地址寄存器&lt;/th&gt;\n&lt;th&gt;偏移地址寄存器&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;ds（内存）,es,ss（栈）,cs&lt;/td&gt;\n&lt;td&gt;sp（栈）,bp,si,di,ip,bx&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;指令的执行过程\&#34;&gt;指令的执行过程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;CPU从cs:ip所指向的内存单元 读取 指令 然后 存放到 指令缓存器当中&lt;/li&gt;\n&lt;li&gt;IP = IP + 所读指令的长度，从而指向下一条指令&lt;/li&gt;\n&lt;li&gt;执行指令缓存器的内容，回到步骤1&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;debug\&#34;&gt;debug&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;-r 查看和修改寄存器中的内容&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;-r cs&lt;br&gt;\ncs value&lt;br&gt;\nenter&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;-d 查看内存中的内容&lt;/strong&gt;  段地址加偏移地址&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;-d ss:00&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;-v 将机器指令翻译成汇编指令&lt;/strong&gt;&lt;br&gt;\n&lt;strong&gt;-a 以汇编指令的格式 在内存中写入一条汇编指令&lt;/strong&gt; 每次debug都的写&lt;br&gt;\n&lt;strong&gt;-t 执行当前 cs:ip 所指的机器指令&lt;/strong&gt; 代码段&lt;br&gt;\n&lt;strong&gt;-e 可以改写 内存中的内容（数据）&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;-p 快速执行完loop 指令&lt;/strong&gt;&lt;br&gt;\n&lt;em&gt;*-g 地址 ==== 一直执行到 地址 的 位置&lt;/em&gt;*&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;汇编语言-寄存器&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;汇编语言-寄存器&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;归纳&#34;,&#34;slug&#34;:&#34;9EqYBcXwSl&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/9EqYBcXwSl/&#34;}],&#34;date&#34;:&#34;2020-02-17 21:36:01&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/汇编语言-寄存器/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:122000,&#34;words&#34;:520,&#34;minutes&#34;:3},&#34;description&#34;:&#34;寄存器\n\n\n\n小例子\n1.1 B800：0400 回车\n1.2 1空格 1空格\n1.3 2空格 2空格\n1.4    ...\n\n\n汇编程序员 就是 通过 汇编语言 中的 汇编指令 去修改 寄存器的值 从而 控制 CPU 控制整个计算机\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%84%E5%AD%98%E5%99%A8\&#34;&gt;寄存器&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\&#34;&gt;通用寄存器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8-cs%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%92%8Cip%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80\&#34;&gt;（地址寄存器）指令寄存器 CS（段地址）和IP（偏移地址）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\&#34;&gt;指令的执行过程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#debug\&#34;&gt;debug&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;jdbc\&#34;&gt;JDBC：&lt;/h1&gt;\n&lt;h2 id=\&#34;1-概念\&#34;&gt;1. 概念：&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;2代码实现\&#34;&gt;2.代码实现：&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t\t  \t//1. 导入驱动jar包\n\t        //2.注册驱动\n\t        Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);\n\t        //3.获取数据库连接对象\n\t        Connection conn = DriverManager.getConnection(&amp;quot;jdbc:mysql://localhost:3306/db3&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);\n\t        //4.定义sql语句\n\t        String sql = &amp;quot;update account set balance = 500 where id = 1&amp;quot;;\n\t        //5.获取执行sql的对象 Statement\n\t        Statement stmt = conn.createStatement();\n\t        //6.执行sql\n\t        int count = stmt.executeUpdate(sql);\n\t        //7.处理结果\n\t        System.out.println(count);\n\t        //8.释放资源\n\t        stmt.close();\n\t        conn.close();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;3-详解各个对象\&#34;&gt;3. 详解各个对象：&lt;/h2&gt;\n&lt;h3 id=\&#34;drivermanager驱动管理对象\&#34;&gt;DriverManager：驱动管理对象&lt;/h3&gt;\n&lt;h4 id=\&#34;功能\&#34;&gt;功能：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;注册驱动：告诉程序该使用哪一个数据库驱动jar&lt;/li&gt;\n&lt;li&gt;获取数据库连接：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;connection数据库连接对象\&#34;&gt;Connection：数据库连接对象&lt;/h3&gt;\n&lt;h4 id=\&#34;功能-2\&#34;&gt;功能：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;获取执行sql 的对象(&lt;strong&gt;Statement&lt;/strong&gt;)&lt;/li&gt;\n&lt;li&gt;管理事务：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;statement执行sql的对象\&#34;&gt;Statement：执行sql的对象&lt;/h3&gt;\n&lt;h4 id=\&#34;功能-3\&#34;&gt;功能：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;执行sql&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;boolean execute(String sql) ：可以执行任意的sql 了解&lt;/li&gt;\n&lt;li&gt;int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句\n&lt;ol&gt;\n&lt;li&gt;返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 &lt;strong&gt;返回值&amp;gt;0&lt;/strong&gt;的则执行&lt;strong&gt;成功&lt;/strong&gt;，反之，则失败。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;ResultSet executeQuery(String sql)  ：执行DQL（select)语句&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;练习：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JAVA\&#34;&gt;/*\n1. account表 添加一条记录\n2. account表 修改记录\t\n3. account表 删除一条记录\n*/\n\n\t    Statement stmt = null;\n\t    Connection conn = null;\n\t    try {\n\t        //1. 注册驱动\n\t        Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);\n\t        //2. 定义sql\n\t        String sql = &amp;quot;insert into account values(null,&#39;王五&#39;,3000)&amp;quot;;\n\t        //3.获取Connection对象\n\tconn = DriverManager.getConnection(&amp;quot;jdbc:mysql:///db3&amp;quot;,&amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);\n\t        //4.获取执行sql的对象 Statement\n\t        stmt = conn.createStatement();\n\t        //5.执行sql\n\t        int count = stmt.executeUpdate(sql);//影响的行数\n\t        //6.处理结果\n\t        System.out.println(count);\n\t        if(count &amp;gt; 0){\n\t            System.out.println(&amp;quot;添加成功！&amp;quot;);\n\t        }else{\n\t            System.out.println(&amp;quot;添加失败！&amp;quot;);\n\t        }\n\t    } catch (ClassNotFoundException e) {\n\t        e.printStackTrace();\n\t    } catch (SQLException e) {\n\t        e.printStackTrace();\n\t    }finally {\n\t        //stmt.close();\n\t        //7. 释放资源\n\t        //避免空指针异常\n\t        if(stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t        if(conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;resultset结果集对象封装查询结果\&#34;&gt;ResultSet：结果集对象,封装查询结果&lt;/h3&gt;\n&lt;h4 id=\&#34;方法\&#34;&gt;方法&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true&lt;/li&gt;\n&lt;li&gt;getXxx(参数):获取数据\n&lt;ol&gt;\n&lt;li&gt;Xxx：代表数据类型   如： int getInt() ,    String getString()&lt;/li&gt;\n&lt;li&gt;参数：\n&lt;ol&gt;\n&lt;li&gt;int：代表列的编号,从1开始   如： getString(1)&lt;/li&gt;\n&lt;li&gt;String：代表列名称。 如： getDouble(&amp;quot;balance&amp;quot;)&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;注意：\n&lt;ol&gt;\n&lt;li&gt;使用步骤：\n&lt;ol&gt;\n&lt;li&gt;游标向下移动一行&lt;/li&gt;\n&lt;li&gt;判断是否有数据&lt;/li&gt;\n&lt;li&gt;获取数据&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;练习\&#34;&gt;练习&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/* 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。\n\t1. 定义Emp类\n\t2. 定义方法 public List&amp;lt;Emp&amp;gt; findAll(){}\n\t3. 实现方法 select * from emp;\n*/\npackage cn.itcast.jdbc;\n\nimport cn.itcast.domain.Emp;\nimport cn.itcast.util.JDBCUtils;\n\nimport java.sql.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。\n */\npublic class JDBCDemo8 {\n\n    public static void main(String[] args) {\n        List&amp;lt;Emp&amp;gt; list = new JDBCDemo8().findAll2();\n        System.out.println(list);\n        System.out.println(list.size());\n    }\n    /**\n     * 查询所有emp对象\n     * @return\n     */\n    public List&amp;lt;Emp&amp;gt; findAll(){\n        Connection conn = null;\n        Statement stmt = null;\n        ResultSet rs = null;\n        List&amp;lt;Emp&amp;gt; list = null;\n        try {\n            //1.注册驱动\n            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);\n            //2.获取连接\n            conn = DriverManager.getConnection(&amp;quot;jdbc:mysql:///db3&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);\n            //3.定义sql\n            String sql = &amp;quot;select * from emp&amp;quot;;\n            //4.获取执行sql的对象\n            stmt = conn.createStatement();\n            //5.执行sql\n            rs = stmt.executeQuery(sql);\n            //6.遍历结果集，封装对象，装载集合\n\n            Emp emp = null;\n            list = new ArrayList&amp;lt;Emp&amp;gt;();\n            while(rs.next()){\n                //获取数据\n                int id = rs.getInt(&amp;quot;id&amp;quot;);\n                String ename = rs.getString(&amp;quot;ename&amp;quot;);\n                int job_id = rs.getInt(&amp;quot;job_id&amp;quot;);\n                int mgr = rs.getInt(&amp;quot;mgr&amp;quot;);\n                Date joindate = rs.getDate(&amp;quot;joindate&amp;quot;);\n                double salary = rs.getDouble(&amp;quot;salary&amp;quot;);\n                double bonus = rs.getDouble(&amp;quot;bonus&amp;quot;);\n                int dept_id = rs.getInt(&amp;quot;dept_id&amp;quot;);\n                // 创建emp对象,并赋值\n                emp = new Emp();\n                emp.setId(id);\n                emp.setEname(ename);\n                emp.setJob_id(job_id);\n                emp.setMgr(mgr);\n                emp.setJoindate(joindate);\n                emp.setSalary(salary);\n                emp.setBonus(bonus);\n                emp.setDept_id(dept_id);\n\n                //装载集合\n                list.add(emp);\n            }\n\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally {\n            if(rs != null){\n                try {\n                    rs.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if(stmt != null){\n                try {\n                    stmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if(conn != null){\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return list;\n    }\n\n\n    /**\n     * 演示JDBC工具类\n     * @return\n     */\n    public List&amp;lt;Emp&amp;gt; findAll2(){\n        Connection conn = null;\n        Statement stmt = null;\n        ResultSet rs = null;\n        List&amp;lt;Emp&amp;gt; list = null;\n        try {\n           /* //1.注册驱动\n            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);\n            //2.获取连接\n            conn = DriverManager.getConnection(&amp;quot;jdbc:mysql:///db3&amp;quot;, &amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;);*/\n            conn = JDBCUtils.getConnection();\n            //3.定义sql\n            String sql = &amp;quot;select * from emp&amp;quot;;\n            //4.获取执行sql的对象\n            stmt = conn.createStatement();\n            //5.执行sql\n            rs = stmt.executeQuery(sql);\n            //6.遍历结果集，封装对象，装载集合\n            Emp emp = null;\n            list = new ArrayList&amp;lt;Emp&amp;gt;();\n            while(rs.next()){\n                //获取数据\n                int id = rs.getInt(&amp;quot;id&amp;quot;);\n                String ename = rs.getString(&amp;quot;ename&amp;quot;);\n                int job_id = rs.getInt(&amp;quot;job_id&amp;quot;);\n                int mgr = rs.getInt(&amp;quot;mgr&amp;quot;);\n                Date joindate = rs.getDate(&amp;quot;joindate&amp;quot;);\n                double salary = rs.getDouble(&amp;quot;salary&amp;quot;);\n                double bonus = rs.getDouble(&amp;quot;bonus&amp;quot;);\n                int dept_id = rs.getInt(&amp;quot;dept_id&amp;quot;);\n                // 创建emp对象,并赋值\n                emp = new Emp();\n                emp.setId(id);\n                emp.setEname(ename);\n                emp.setJob_id(job_id);\n                emp.setMgr(mgr);\n                emp.setJoindate(joindate);\n                emp.setSalary(salary);\n                emp.setBonus(bonus);\n                emp.setDept_id(dept_id);\n\n                //装载集合\n                list.add(emp);\n            }\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally {\n            /*if(rs != null){\n                try {\n                    rs.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if(stmt != null){\n                try {\n                    stmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if(conn != null){\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }*/\n\n            JDBCUtils.close(rs,stmt,conn);\n        }\n        return list;\n    }\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;preparedstatement执行sql的对象\&#34;&gt;PreparedStatement：执行sql的对象&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题\n&lt;ol&gt;\n&lt;li&gt;输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a&lt;/li&gt;\n&lt;li&gt;sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;解决sql注入问题：使用PreparedStatement对象来解决&lt;/li&gt;\n&lt;li&gt;预编译的SQL：参数使用?作为占位符&lt;/li&gt;\n&lt;li&gt;步骤：&lt;/li&gt;\n&lt;li&gt;导入驱动jar包 mysql-connector-java-5.1.37-bin.jar&lt;/li&gt;\n&lt;li&gt;注册驱动&lt;/li&gt;\n&lt;li&gt;获取数据库连接对象 Connection&lt;/li&gt;\n&lt;li&gt;定义sql\n&lt;ol&gt;\n&lt;li&gt;注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)&lt;/li&gt;\n&lt;li&gt;给？赋值：\n&lt;ol&gt;\n&lt;li&gt;方法： setXxx(参数1,参数2)\n&lt;ol&gt;\n&lt;li&gt;参数1：？的位置编号 从1 开始&lt;/li&gt;\n&lt;li&gt;参数2：？的值&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;执行sql，接受返回结果，不需要传递sql语句&lt;/li&gt;\n&lt;li&gt;处理结果&lt;/li&gt;\n&lt;li&gt;释放资源&lt;/li&gt;\n&lt;li&gt;注意：后期都会使用PreparedStatement来完成增删改查的所有操作\n&lt;ol&gt;\n&lt;li&gt;可以防止SQL注入&lt;/li&gt;\n&lt;li&gt;效率更高&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;抽取jdbc工具类-jdbcutils\&#34;&gt;抽取JDBC工具类 ： JDBCUtils&lt;/h1&gt;\n&lt;h3 id=\&#34;目的简化书写\&#34;&gt;目的：简化书写&lt;/h3&gt;\n&lt;h3 id=\&#34;分析\&#34;&gt;分析：&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;注册驱动也抽取&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;抽取一个方法获取连接对象&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;需求：不想传递参数（麻烦），还得保证工具类的通用性。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;解决：配置文件&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;blockquote&gt;\n&lt;p&gt;jdbc.properties&lt;/p&gt;\n&lt;p&gt;​                    url=&lt;/p&gt;\n&lt;p&gt;​                    user=&lt;/p&gt;\n&lt;p&gt;​                    password=&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;抽取一个方法释放资源&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;代码实现\&#34;&gt;代码实现：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class JDBCUtils {\n\t    private static String url;\n\t    private static String user;\n\t    private static String password;\n\t    private static String driver;\n\t    /**\n\t     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块\n\t     */\n\t    static{\n\t        //读取资源文件，获取值。\n\t\n\t        try {\n\t            //1. 创建Properties集合类。\n\t            Properties pro = new Properties();\n\t\n\t            //获取src路径下的文件的方式---&amp;gt;ClassLoader 类加载器\n\t            ClassLoader classLoader = JDBCUtils.class.getClassLoader();\n\t            URL res  = classLoader.getResource(&amp;quot;jdbc.properties&amp;quot;);\n\t            String path = res.getPath();\n\t            System.out.println(path);\n\t            //2. 加载文件\n\t            pro.load(new FileReader(path));\n\t\n\t            //3. 获取数据，赋值\n\t            url = pro.getProperty(&amp;quot;url&amp;quot;);\n\t            user = pro.getProperty(&amp;quot;user&amp;quot;);\n\t            password = pro.getProperty(&amp;quot;password&amp;quot;);\n\t            driver = pro.getProperty(&amp;quot;driver&amp;quot;);\n\t            //4. 注册驱动\n\t            Class.forName(driver);\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } catch (ClassNotFoundException e) {\n\t            e.printStackTrace();\n\t        }\n\t    }\n\t\n\t\n\t    /**\n\t     * 获取连接\n\t     * @return 连接对象\n\t     */\n\t    public static Connection getConnection() throws SQLException {\n\t\n\t        return DriverManager.getConnection(url, user, password);\n\t    }\n\t\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(Statement stmt,Connection conn){\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\t\n\t\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(ResultSet rs,Statement stmt, Connection conn){\n\t        if( rs != null){\n\t            try {\n\t                rs.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\t\n\t}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;JDBC课堂笔记&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;JDBC课堂笔记&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JDBC&#34;,&#34;slug&#34;:&#34;2sJ-pShYyD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/2sJ-pShYyD/&#34;},{&#34;name&#34;:&#34;Java_basic&#34;,&#34;slug&#34;:&#34;oenOsAIQjU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/oenOsAIQjU/&#34;}],&#34;date&#34;:&#34;2020-02-17 17:37:56&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/JDBC课堂笔记/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:572000,&#34;words&#34;:1979,&#34;minutes&#34;:10},&#34;description&#34;:&#34;JDBC：\n1. 概念：\nJava DataBase Connectivity  Java 数据库连接， Java语言操作数据库\n\nJDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#jdbc\&#34;&gt;JDBC：&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%A6%82%E5%BF%B5\&#34;&gt;1. 概念：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\&#34;&gt;2.代码实现：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E8%AF%A6%E8%A7%A3%E5%90%84%E4%B8%AA%E5%AF%B9%E8%B1%A1\&#34;&gt;3. 详解各个对象：&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#drivermanager%E9%A9%B1%E5%8A%A8%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1\&#34;&gt;DriverManager：驱动管理对象&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%9F%E8%83%BD\&#34;&gt;功能：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#connection%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%AF%B9%E8%B1%A1\&#34;&gt;Connection：数据库连接对象&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%9F%E8%83%BD-2\&#34;&gt;功能：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#statement%E6%89%A7%E8%A1%8Csql%E7%9A%84%E5%AF%B9%E8%B1%A1\&#34;&gt;Statement：执行sql的对象&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%9F%E8%83%BD-3\&#34;&gt;功能：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#resultset%E7%BB%93%E6%9E%9C%E9%9B%86%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C\&#34;&gt;ResultSet：结果集对象,封装查询结果&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95\&#34;&gt;方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%83%E4%B9%A0\&#34;&gt;练习&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#preparedstatement%E6%89%A7%E8%A1%8Csql%E7%9A%84%E5%AF%B9%E8%B1%A1\&#34;&gt;PreparedStatement：执行sql的对象&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8A%BD%E5%8F%96jdbc%E5%B7%A5%E5%85%B7%E7%B1%BB-jdbcutils\&#34;&gt;抽取JDBC工具类 ： JDBCUtils&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%AE%E7%9A%84%E7%AE%80%E5%8C%96%E4%B9%A6%E5%86%99\&#34;&gt;目的：简化书写&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E6%9E%90\&#34;&gt;分析：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\&#34;&gt;代码实现：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;[TOC]&lt;/p&gt;\n&lt;h1 id=\&#34;常用api\&#34;&gt;常用API&lt;/h1&gt;\n&lt;h1 id=\&#34;api\&#34;&gt;API&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;概述\&#34;&gt;概述&lt;/h2&gt;\n&lt;hr&gt;\n&lt;p&gt;API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给 我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学 习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。&lt;/p&gt;\n&lt;h2 id=\&#34;api使用过程\&#34;&gt;API使用过程&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ol&gt;\n&lt;li&gt;打开帮助文档。&lt;/li&gt;\n&lt;li&gt;点击显示，找到索引，看到输入框。&lt;/li&gt;\n&lt;li&gt;你要找谁？在输入框里输入，然后回车。&lt;/li&gt;\n&lt;li&gt;看包。java.lang下的类不需要导包，其他需要。&lt;/li&gt;\n&lt;li&gt;看类的解释和说明。&lt;/li&gt;\n&lt;li&gt;学习构造方法。&lt;/li&gt;\n&lt;li&gt;使用成员方法&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;scanner类\&#34;&gt;Scanner类&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;读取一个数\&#34;&gt;读取一个数&lt;/h2&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Scanner sc = new Scanner(System.in);\nint num = sc.nextInt();\nSystem.out.println(num);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;random类\&#34;&gt;Random类&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;产生随机数\&#34;&gt;产生随机数&lt;/h2&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Random rm = new Random();\nint num = rm.nextInt();\nSystem.out.println(num);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;产生-0n-之间的随机数\&#34;&gt;产生 [0，n) 之间的随机数&lt;/h2&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;int num = rm.nextInt(10);\nSystem.out.println(num);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;arraylist类\&#34;&gt;ArrayList类&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;对象数组\&#34;&gt;对象数组&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class demo01 {\n    public static void main(String[] args) {\n        Person[] array = new Person[3];\n\n        Person one = new Person(&amp;quot;01&amp;quot;,1);\n        Person two = new Person(&amp;quot;02&amp;quot;,2);\n        Person three = new Person(&amp;quot;03&amp;quot;,3);\n\n        array[0]=one;//把one的地址值存到array[0]中\n        array[1]=two;\n        array[2]=three;\n\n        System.out.println(array[0]);\n        System.out.println(array[0].getName());//\n        System.out.println(one.getAge());//\n\n        for(int x=0;x&amp;lt;array.length;x++){\n            System.out.println(array[x].getName()+&amp;quot; ---- &amp;quot;+array[x].getAge());\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;em&gt;&lt;strong&gt;alt + insert&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;arraylist容器\&#34;&gt;ArrayList容器&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;是&lt;strong&gt;大小可变的数组的实现&lt;/strong&gt;，存储在内的数据称为元素。此类提供一些方法来操作内部存储 的元素。 ArrayList 中可不断添加元素，其&lt;strong&gt;大小也自动增长&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;泛型只能是&lt;strong&gt;引用类型&lt;/strong&gt;，&lt;strong&gt;不&lt;/strong&gt;能是&lt;strong&gt;基本类型&lt;/strong&gt;，要在array list中存储基本类型数据，必须使用基本类型对应的&lt;strong&gt;包装类&lt;/strong&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;包装类&lt;/strong&gt; 位于Java lang 下，不需要导包&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;基本类型&lt;/th&gt;\n&lt;th&gt;包装类&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;byte&lt;/td&gt;\n&lt;td&gt;Byte&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;short&lt;/td&gt;\n&lt;td&gt;Short&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;int&lt;/td&gt;\n&lt;td&gt;Integer&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;long&lt;/td&gt;\n&lt;td&gt;Long&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;float&lt;/td&gt;\n&lt;td&gt;Float&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;double&lt;/td&gt;\n&lt;td&gt;Double&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;char&lt;/td&gt;\n&lt;td&gt;Character&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;boolean&lt;/td&gt;\n&lt;td&gt;Boolean&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h2 id=\&#34;常用方法\&#34;&gt;常用方法&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public boolean add(E e)//向集合中添加元素，参数类型和泛型一致\n\npublic E get(int index)//从集合中获取元素，参数是索引编号，从0开始，返回值为对应位置的元素，不删除\n    \npublic E remove(int index)//从集合中删除元素，参数是索引编号，返回值就是所删除的元素\n    \npublic int size() //获取集合的长度，返回值是集合中包含的元素个数\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;string-类\&#34;&gt;String 类&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;注意\&#34;&gt;注意&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ol&gt;\n&lt;li&gt;String类代表字符串&lt;/li&gt;\n&lt;li&gt;字符串都是常量，在创建后不可改变，&lt;mark&gt;如果要改变StringBuilder类对象&lt;/mark&gt;&lt;/li&gt;\n&lt;li&gt;字符串可共享使用&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;创建字符串31种\&#34;&gt;创建字符串&lt;em&gt;3+1&lt;/em&gt;种&lt;/h2&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;mark&gt;三种构造方法，一种直接创建&lt;/mark&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: Can&amp;#039;t use function &amp;#039;$&amp;#039; in math mode at position 7: public$̲$     $$String(…&#39;&gt;public$$     $$String()$$  创建空白字符串\n&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: Can&amp;#039;t use function &amp;#039;$&amp;#039; in math mode at position 7: public$̲$  $$String(byt…&#39;&gt;public$$  $$String(byte[]$$   $$array$$$$)$$ 根据字节数组来创建字符串\n&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;字符串常量池堆中\&#34;&gt;字符串常量池（堆中）&lt;/h2&gt;\n&lt;p&gt;&lt;mark&gt;双引号直接创建的字符串在常量池&lt;/mark&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;对于基本类型来说 ，==是值的比较&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;对于引用类型来说， ==是地址值的比较&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024303.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024324.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;字符串比较\&#34;&gt;字符串比较&lt;/h2&gt;\n&lt;h3 id=\&#34;内容比较\&#34;&gt;内容比较&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;public boolean  equals(Object obj) &lt;strong&gt;参数可以是任何对象，但只有字符串且相等才返回true&lt;/strong&gt;\n&lt;ol&gt;\n&lt;li&gt;比较双方无序&lt;/li&gt;\n&lt;li&gt;一个常量和一个变量 推荐 用常量调用&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;public boolean equalsIgnoreCase(Object obj)  &lt;strong&gt;忽略大小写&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;mark&gt;alt + enter&lt;/mark&gt; local variable&lt;/p&gt;\n&lt;h2 id=\&#34;字符串相关信息获取\&#34;&gt;字符串相关信息获取&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;int length（）；获取长度&lt;/li&gt;\n&lt;li&gt;String contact（String str）；拼接字符串，返回拼接后的字符串&lt;/li&gt;\n&lt;li&gt;char charAt(int index);获取指定位置的字符&lt;/li&gt;\n&lt;li&gt;int indexOf(String str);返回字符串中首次出现str的index&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;字符串的截取\&#34;&gt;字符串的截取&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;public String substring(int index),//截取从index开始直到末尾&lt;/li&gt;\n&lt;li&gt;public String substring（int begin,int end）//截取==[begin ,end)==&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;字符串的转换\&#34;&gt;字符串的转换&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;public char[] toCharArray();//返回字符数组&lt;/li&gt;\n&lt;li&gt;public byte[] getBytes(); //返回字节数据&lt;/li&gt;\n&lt;li&gt;public String replace(CharSequence  oldstring,CharSequence newstring);// 替换，返回结果&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;字符串的分割\&#34;&gt;字符串的分割&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JAVA\&#34;&gt;String[] s = str3.split(&amp;quot; &amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;static静态\&#34;&gt;static静态&lt;/h1&gt;\n&lt;h2 id=\&#34;关键字概述\&#34;&gt;关键字概述&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;一个类成员变量或者方法，一旦使用&lt;strong&gt;static&lt;/strong&gt; 那么其内容不在属于 对象 ，而是属于 类本身&lt;/li&gt;\n&lt;li&gt;凡是本类对象，共享同一份 数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;关键字修饰成员变量\&#34;&gt;关键字修饰成员变量&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\npublic class studentdemotest {\n    public static void main(String[] args) {\n        Student one = new Student(&amp;quot;001&amp;quot;,1);\n        one.room=&amp;quot;100&amp;quot;;\n        System.out.println(one.getName()+&amp;quot; &amp;quot;+one.getAge()+&amp;quot; &amp;quot;+one.getId()+&amp;quot; &amp;quot;+one.room);\n\n        Student two = new Student(&amp;quot;002&amp;quot;,2);\n        System.out.println(two.getName()+&amp;quot; &amp;quot;+two.getAge()+&amp;quot; &amp;quot;+two.getId()+&amp;quot; &amp;quot;+two.room);\n    }\n}\npackage cn.itcast.day07.static_demo;\n\npublic class Student {\n    private  String name;\n    private int age;\n    private int id;\n    static String room;\n    private static int id_counter=0;\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n        this.id=++id_counter;\n    }\n\n    public Student() {\n        id_counter++;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;arrays\&#34;&gt;Arrays&lt;/h1&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;java.until.Arrays 与数组相关的工具类，提供大量静态方法 来实现操作&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;1-将数组转换为字符串\&#34;&gt;1. 将数组转换为字符串&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;默认输出&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t\t\tint[] a = {1,2,3,444,56};\n        String str = Arrays.toString(a);\n        System.out.println(str);\n//[1, 2, 3, 444, 56]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2排序\&#34;&gt;2.排序&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;升序(从小到大)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t\t\tint[] a = {1,2,3,444,56};\n\t\t\tArrays.sort(a);\n        String str1 = Arrays.toString(a);\n        System.out.println(str1);\n//[1, 2, 3, 56, 444]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;练习\&#34;&gt;练习&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;字符串排序后倒序输出&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.Arrays;\n\npublic class practise {\n    public static void main(String[] args) {\n        String str = &amp;quot;sadfsfaleuwaefhlefaksfa&amp;quot;;\n\n        char[] chars = str.toCharArray();\n        Arrays.sort(chars);\n\n        for (int i = chars.length - 1; i &amp;gt;= 0; i--) {\n            System.out.println(chars[i]);\n        }\n    }\n}\n//wusssllkhfffffeeedaaaaa\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;math类\&#34;&gt;Math类&lt;/h1&gt;\n&lt;h2 id=\&#34;1abs绝对值\&#34;&gt;1.abs绝对值&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt; System.out.println(Math.abs(-5));//5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-ceil-向上取整\&#34;&gt;2. ceil 向上取整&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;System.out.println(Math.ceil(4.1));//5.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;3-floor-向下取整\&#34;&gt;3. floor 向下取整&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;System.out.println(Math.floor(4.8));//4.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;4-round-四舍五入\&#34;&gt;4. round 四舍五入&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt; System.out.println(Math.round(4.5));//5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;练习-2\&#34;&gt;练习&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024236.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;objects\&#34;&gt;objects&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;1-tostring方法\&#34;&gt;1. toString方法&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;如果类中没重写，则打印输出的为地址值，否则则为其它&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2equals方法\&#34;&gt;2.equals方法&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;默认比较两个对象的地址&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;空指针安全\&#34;&gt;空指针安全&lt;/h2&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;null 不能调用方法，会抛出空指针异常&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;data类\&#34;&gt;Data类&lt;/h1&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;unti&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;精确到毫秒&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;日期和毫秒可相互转换&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;日期-》毫秒 === 当前日期到时间原点的毫秒值&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;毫秒-》日期&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;getime()  把日期转换为毫秒&lt;/li&gt;\n&lt;li&gt;Data（Long Date）long型数据 毫秒------带参构造&lt;/li&gt;\n&lt;li&gt;Data（）–---------无参构造&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dataformat类抽象类\&#34;&gt;DataFormat类(抽象类)&lt;/h2&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;text&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;时间和字符串之间来转换&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;system类\&#34;&gt;System类&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;获取ms\&#34;&gt;获取ms&lt;/h2&gt;\n&lt;hr&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;  public static void test01(){\n        //获取毫秒值\n        long b = System.currentTimeMillis();\n        for (int i = 0; i &amp;lt; 9999; i++) {\n            System.out.println(i);\n        }\n        long e = System.currentTimeMillis();\n        System.out.println(&amp;quot;共计：&amp;quot;+(e-b)+&amp;quot;ms&amp;quot;);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;copy-数组\&#34;&gt;copy 数组&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static void test02(){\n\n        int [] s={1,2,3,4,5,};\n        int [] d={6,7,8,9,10,};\n\n        System.out.println(&amp;quot;befor copy:&amp;quot;+ Arrays.toString(d));\n        System.arraycopy(s,0,d,0,3);\n        System.out.println(&amp;quot;after cpoy:&amp;quot;+ Arrays.toString(d));\n\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;stringbuilder\&#34;&gt;StringBuilder&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;java.lang.StringBUilder&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;mark&gt;字符串缓冲区&lt;/mark&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;//构造方法//StringBuilder()默认长度16//StringBuilder(str)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;constructor\&#34;&gt;Constructor&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt; StringBuilder bu1 = new StringBuilder();\n        System.out.println(&amp;quot;bu1: &amp;quot;+bu1);\n\n        StringBuilder bu2=new StringBuilder(&amp;quot;abc&amp;quot;);\n        System.out.println(&amp;quot;bu2: &amp;quot;+bu2);\n        /**\n         * bu1:\n         * bu2: abc\n         */\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;methord\&#34;&gt;methord&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;append&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static void main(String[] args) {\n        //创建\n        StringBuilder bu1=new StringBuilder();\n\t\t\n        //String --&amp;gt; StringBuilder\n        StringBuilder bu2 = bu1.append(&amp;quot;abc&amp;quot;);\n\n        System.out.println(&amp;quot;bu1:&amp;quot;+bu1+&amp;quot; bu2: &amp;quot;+bu2+&amp;quot; &amp;quot;+(bu1==bu2));\n        /*\n        * bu1:abc bu2: abc true\n        * */\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;toString()&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;        //StringBuilder---&amp;gt;String\n        String s=bu1.toString();\n        System.out.println(s);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;包装类\&#34;&gt;包装类&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;把基本数据类型打包就可以使用相应的方法&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;int  ===&amp;gt; Integer&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;char ==&amp;gt; Character&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;其余全部为首字母大写&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;装箱\&#34;&gt;装箱&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//装箱\n        //构造方法\n        Integer in1 = new Integer(5);\n        Integer in2 = new Integer(&amp;quot;4&amp;quot;);\n\n        System.out.println(&amp;quot;in1: &amp;quot;+in1+&amp;quot; in2: &amp;quot;+in2);\n\n        //静态方法\n        Integer in3 = Integer.valueOf(1);\n        System.out.println(&amp;quot;in3: &amp;quot;+in3);\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;拆箱\&#34;&gt;拆箱&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt; //拆箱\n        int int1=in1.intValue();\n        int int2=in2.intValue();\n        int int3=in3.intValue();\n\n        System.out.println(&amp;quot;in1: &amp;quot;+in1+&amp;quot; in2: &amp;quot;+in2);\n        System.out.println(&amp;quot;in3: &amp;quot;+in3);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;自动拆箱于装箱\&#34;&gt;自动拆箱于装箱&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static void main(String[] args) {\n        Integer integer = new Integer(5);\n        integer=integer+2;//自动拆箱\n        System.out.println(&amp;quot;integer: &amp;quot;+integer);\n\n        ArrayList&amp;lt;Integer&amp;gt; al1=new ArrayList&amp;lt;&amp;gt;(1);\n        //自动装箱\n        al1.add(1);//al1.add(new Integer(1))\n        int one=al1.get(0);//al1.get(1).valueOf ();\n        int two=al1.get(0).intValue();\n        System.out.println(&amp;quot;one: &amp;quot;+one+&amp;quot; two:&amp;quot;+two);\n\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;基本数据类型于字符串之间的相互转换\&#34;&gt;基本数据类型于字符串之间的相互转换&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static void main(String[] args) {\n        //基本类型转换成字符串\n            //1.基本类型的值+“string”\n        int int1 = 100;\n        String s1 = int1 + &amp;quot;200&amp;quot;;\n        System.out.println(&amp;quot;s1: &amp;quot;+s1);\n            //包装类的静态方法toString(args)\n        String s2 = Integer.toString(100);\n        System.out.println(&amp;quot;s2: &amp;quot;+s2+100);\n            //string类的静态方法valueOf()\n        String s3=String.valueOf(200);\n        System.out.println(&amp;quot;s3: &amp;quot;+s3+100);\n\n        //String--&amp;gt;基本类型\n            //使用包装类的静态方法paresXXX()\n        int i = Integer.parseInt(s1);\n        System.out.println(&amp;quot;s1: &amp;quot;+(i-200));\n\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;常用API&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;常用API&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_basic&#34;,&#34;slug&#34;:&#34;oenOsAIQjU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/oenOsAIQjU/&#34;}],&#34;date&#34;:&#34;2020-02-14 11:42:41&#34;,&#34;dateFormat&#34;:&#34;2020-02-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/常用API/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:576000,&#34;words&#34;:2064,&#34;minutes&#34;:10},&#34;description&#34;:&#34;[TOC]\n常用API\nAPI\n\n概述\n\nAPI(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的 字典 ，是JDK中提供给 我们使用的类的说明文档。这些类将底层的代码实...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8api\&#34;&gt;常用API&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#api\&#34;&gt;API&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E8%BF%B0\&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#api%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B\&#34;&gt;API使用过程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#scanner%E7%B1%BB\&#34;&gt;Scanner类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E6%95%B0\&#34;&gt;读取一个数&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#random%E7%B1%BB\&#34;&gt;Random类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0\&#34;&gt;产生随机数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;[产生 &lt;a href=\&#34;#%E4%BA%A7%E7%94%9F-0n-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0\&#34;&gt;0，n) 之间的随机数&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arraylist%E7%B1%BB\&#34;&gt;ArrayList类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84\&#34;&gt;对象数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arraylist%E5%AE%B9%E5%99%A8\&#34;&gt;ArrayList容器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\&#34;&gt;常用方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#string-%E7%B1%BB\&#34;&gt;String 类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F\&#34;&gt;注意&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B231%E7%A7%8D\&#34;&gt;创建字符串&lt;em&gt;3+1&lt;/em&gt;种&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%A0%86%E4%B8%AD\&#34;&gt;字符串常量池（堆中）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\&#34;&gt;字符串比较&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AE%B9%E6%AF%94%E8%BE%83\&#34;&gt;内容比较&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96\&#34;&gt;字符串相关信息获取&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96\&#34;&gt;字符串的截取&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2\&#34;&gt;字符串的转换&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%86%E5%89%B2\&#34;&gt;字符串的分割&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#static%E9%9D%99%E6%80%81\&#34;&gt;static静态&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E9%94%AE%E5%AD%97%E6%A6%82%E8%BF%B0\&#34;&gt;关键字概述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\&#34;&gt;关键字修饰成员变量&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arrays\&#34;&gt;Arrays&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\&#34;&gt;1. 将数组转换为字符串&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E6%8E%92%E5%BA%8F\&#34;&gt;2.排序&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%83%E4%B9%A0\&#34;&gt;练习&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#math%E7%B1%BB\&#34;&gt;Math类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1abs%E7%BB%9D%E5%AF%B9%E5%80%BC\&#34;&gt;1.abs绝对值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-ceil-%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4\&#34;&gt;2. ceil 向上取整&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-floor-%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4\&#34;&gt;3. floor 向下取整&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-round-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5\&#34;&gt;4. round 四舍五入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%83%E4%B9%A0-2\&#34;&gt;练习&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#objects\&#34;&gt;objects&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-tostring%E6%96%B9%E6%B3%95\&#34;&gt;1. toString方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2equals%E6%96%B9%E6%B3%95\&#34;&gt;2.equals方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A9%BA%E6%8C%87%E9%92%88%E5%AE%89%E5%85%A8\&#34;&gt;空指针安全&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#data%E7%B1%BB\&#34;&gt;Data类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#dataformat%E7%B1%BB%E6%8A%BD%E8%B1%A1%E7%B1%BB\&#34;&gt;DataFormat类(抽象类)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#system%E7%B1%BB\&#34;&gt;System类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96ms\&#34;&gt;获取ms&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#copy-%E6%95%B0%E7%BB%84\&#34;&gt;copy 数组&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#stringbuilder\&#34;&gt;StringBuilder&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#constructor\&#34;&gt;Constructor&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#methord\&#34;&gt;methord&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%85%E8%A3%85%E7%B1%BB\&#34;&gt;包装类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A3%85%E7%AE%B1\&#34;&gt;装箱&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8B%86%E7%AE%B1\&#34;&gt;拆箱&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E4%BA%8E%E8%A3%85%E7%AE%B1\&#34;&gt;自动拆箱于装箱&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2\&#34;&gt;基本数据类型于字符串之间的相互转换&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;[TOC]&lt;/p&gt;\n&lt;h1 id=\&#34;面向对象\&#34;&gt;面向对象&lt;/h1&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;1概念\&#34;&gt;1.概念&lt;/h2&gt;\n&lt;p&gt;当实现一个功能的时候，不考虑具体的每一步该怎么做，而是让一个有该功能的人来做&lt;br&gt;\n区别 &lt;strong&gt;面向过程&lt;/strong&gt;--每一步都亲历亲为&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;代码用例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;      //面向过程\n      System.out.print(&amp;quot;[&amp;quot;);\n      for (int i = 0; i &amp;lt; arr.length; i++) {\n          if (i == arr.length - 1) {\n              System.out.println(arr[i] + &amp;quot;]&amp;quot;);\n          } else\n              System.out.print(arr[i] + &amp;quot;, &amp;quot;);\n      }\n      System.out.println(&amp;quot;*********************&amp;quot;);\n      //面向对象\n      System.out.println(Arrays.toString(arr));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;2基本特征\&#34;&gt;2.基本特征&lt;/h2&gt;\n&lt;h3 id=\&#34;1封装\&#34;&gt;1.&lt;strong&gt;封装&lt;/strong&gt;&lt;/h3&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;方法就是封装&lt;/p&gt;\n&lt;p&gt;private关键字也是一种分封装，修饰成员变量&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;间接访问成员变量，就必须定义一对方法  getter\\setter&lt;/p&gt;\n&lt;p&gt;封装就是隐藏细节信息，对外界不可见&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;2继承\&#34;&gt;2.&lt;strong&gt;继承&lt;/strong&gt;&lt;/h3&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;*继承是多态的前提&lt;br&gt;\n*没有继承就没有多态&lt;br&gt;\n*共性抽取&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;父类&lt;/th&gt;\n&lt;th&gt;子类&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;基类，超类&lt;/td&gt;\n&lt;td&gt;派生类&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;如果子类与父类成员变量重名，则会有两种访问成员变量的方法&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;1.间接&lt;/th&gt;\n&lt;th&gt;2. 直接&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;方法属于谁，优先用，若无则向上找&lt;/td&gt;\n&lt;td&gt;等号左边优先使用，属于本类若无则向上找&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;如果子类，父类和局部成员变量重名&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;局部变量&lt;/th&gt;\n&lt;th&gt;直接写&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;本类的成员变量&lt;/td&gt;\n&lt;td&gt;this.成员变量&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;父类的成员变量&lt;/td&gt;\n&lt;td&gt;super.成员变量&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;子类方法的返回值必须 &amp;lt;= 父类的返回值&lt;br&gt;\n子类方法的权限必须 &amp;gt;= 父类的权限&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;public &amp;gt; protected &amp;gt; (default) &amp;gt; private&lt;/p&gt;\n&lt;p&gt;子类的构造方法中默认调用父类的构造方法super（）；&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;3多态\&#34;&gt;3.&lt;strong&gt;多态&lt;/strong&gt;&lt;/h3&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;多种形态  秀明为学生又是人，既有学生形态，又有人类形态&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;格式polymorphic &lt;strong&gt;左父右子  $$fatherclassName- obj = new- childclassName()$$&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;3类和对象\&#34;&gt;3.类和对象&lt;/h2&gt;\n&lt;hr&gt;\n&lt;blockquote&gt;\n&lt;p&gt;类 是抽象的（设计图纸）&lt;br&gt;\n对象 是具体的（手里的产品）&lt;br&gt;\n类是对象的模板，对象是类的实体&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;1类的定义\&#34;&gt;1.类的定义&lt;/h3&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;strong&gt;类和事务的对比&lt;/strong&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;世界&lt;/th&gt;\n&lt;th&gt;属性&lt;/th&gt;\n&lt;th&gt;行为&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;现实&lt;/td&gt;\n&lt;td&gt;事务的状态信息&lt;/td&gt;\n&lt;td&gt;事务可以干什么&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java&lt;/td&gt;\n&lt;td&gt;成员变量&lt;/td&gt;\n&lt;td&gt;成员方法&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;&lt;strong&gt;类的定义实例&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt; public class student {\n     //成员变量\n     String name;\n     int age;\n     //成员方法\n     public void eat(){\n         System.out.println(&amp;quot;eaaaaaaaaaaaaaaat&amp;quot;);\n     }\n     public  void  sleep(){\n         System.out.println(&amp;quot;sleeeeeeeeeeeeeeep&amp;quot;);\n     }\n     public void study(){\n         System.out.println(&amp;quot;stuuuuuuuuuuuuuuuudy&amp;quot;);\n     }\n }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;2类的使用\&#34;&gt;2.类的使用&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;     //1.导包\n     //2.创建\n     student mike = new student();\n\n     String name=&amp;quot;root&amp;quot;;\n     mike.name=name;\n     mike.age=18;\n\n     System.out.println(mike.name);\n     System.out.println(mike.age);\n\n     mike.eat();\n     mike.sleep();\n     mike.study();\n }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;当一个对象作为参数，传递到方法中，实际上是传递的对象的地址值&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;        返回值，其实就是返回对象的地址值\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;4成员变量与局部变量\&#34;&gt;4.成员变量与局部变量&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;成员变量相当于c里的全局变量&lt;/li&gt;\n&lt;li&gt;生存期不同&lt;/li&gt;\n&lt;li&gt;所处的内存区不同&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;5this-类似于c的this指针\&#34;&gt;5.this 类似于c++的this指针&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;参数的名字和成员变量的名字相同的时候用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;6-标准的类组成java-bean\&#34;&gt;6. 标准的类组成（Java bean）&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;all 成员变量都有private关键字&lt;/li&gt;\n&lt;li&gt;为每一个成员变量编写 (getter和setter)&lt;/li&gt;\n&lt;li&gt;编写一个无参构造函数和一个有参构造函数&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;7-快速生成代码\&#34;&gt;7. 快速生成代码&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;code -&amp;gt; generate -&amp;gt; getter &amp;amp; setter&lt;/li&gt;\n&lt;li&gt;or constructor&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;8-继承代码规范\&#34;&gt;8. 继承代码规范&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;父类就是普通的类&lt;/li&gt;\n&lt;li&gt;子类格式为&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;public class 子类名 &lt;mark&gt;extends&lt;/mark&gt; 父类名&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;9-匿名对象\&#34;&gt;9. 匿名对象&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;new 类名（）；&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;10-final关键字最终的不可变的\&#34;&gt;10. final关键字，最终的不可变的&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;可以修饰一个类&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public final class name(){\n    ....\n    }\n    翻译不能有任何子类（太监类）\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;可以修饰一个方法,则该方法不可被子类覆盖重写（override）不可和abstract关键字同时使用&lt;/li&gt;\n&lt;li&gt;可以修饰局部变量，一次赋值，终身不变，只能赋值一次&lt;/li&gt;\n&lt;li&gt;可以修饰成员变量，此变量不可变，必须手动直接赋值或者通过构造赋值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;4-內部类\&#34;&gt;4. 內部类&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;一个事务内包含另一个事务，一个类中包含另一个类&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;身体和心脏&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;类中套类，类随便用外，但是外用内需要局部类对象&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;分类\&#34;&gt;分类&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;1.成员内部类&lt;br&gt;\n2.局部內部类（匿名内部类）&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;格式\&#34;&gt;格式&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//1.成员内部类\n修饰符 class 外部类名称{\n  ·······\n  修饰符 class 內部类名称{\n  ·····\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;内部类访问\&#34;&gt;内部类访问&lt;/h3&gt;\n&lt;p&gt;1.直接访问&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//间接访问内部类\n        body body = new body(&amp;quot;Jim&amp;quot;);\n        body.methonBody();//外部类对象\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2.间接访问&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//直接访问\n        body.heart heart= new body(&amp;quot;Tom&amp;quot;).new heart();\n        heart.methonHeart();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;重名变量访问&lt;mark&gt;outer&lt;/mark&gt;&lt;br&gt;\n&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024039.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n局部内部类（方法里面的类）&lt;br&gt;\n&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024053.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;类定义的权限修饰符规则\&#34;&gt;类定义的权限修饰符规则&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;外部类&lt;/th&gt;\n&lt;th&gt;成员內部类&lt;/th&gt;\n&lt;th&gt;局部内部类&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;public（/default）&lt;/td&gt;\n&lt;td&gt;全部都可&lt;/td&gt;\n&lt;td&gt;什么都不写&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;匿名内部类（重点）&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;格式&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;接口名 对象名 = new 接口名（）{&lt;br&gt;\n@override&lt;br&gt;\n方法实现&lt;br&gt;\n}&lt;br&gt;\n&lt;img src=\&#34;https://gitee.com/bgst009/markdownPicUrl/raw/master/20200923024114.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;注意事项&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;面向对象和封装&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;面向对象和封装&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_basic&#34;,&#34;slug&#34;:&#34;oenOsAIQjU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/oenOsAIQjU/&#34;}],&#34;date&#34;:&#34;2020-02-14 11:34:43&#34;,&#34;dateFormat&#34;:&#34;2020-02-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/面向对象和封装/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:269000,&#34;words&#34;:1159,&#34;minutes&#34;:5},&#34;description&#34;:&#34;[TOC]\n面向对象\n\n1.概念\n当实现一个功能的时候，不考虑具体的每一步该怎么做，而是让一个有该功能的人来做\n区别 面向过程--每一步都亲历亲为\n\n代码用例\n      //面向过程\n      System.out.print(&amp;quo...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\&#34;&gt;面向对象&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%A6%82%E5%BF%B5\&#34;&gt;1.概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81\&#34;&gt;2.基本特征&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E5%B0%81%E8%A3%85\&#34;&gt;1.&lt;strong&gt;封装&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E7%BB%A7%E6%89%BF\&#34;&gt;2.&lt;strong&gt;继承&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E5%A4%9A%E6%80%81\&#34;&gt;3.&lt;strong&gt;多态&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\&#34;&gt;3.类和对象&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89\&#34;&gt;1.类的定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8\&#34;&gt;2.类的使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\&#34;&gt;4.成员变量与局部变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5this-%E7%B1%BB%E4%BC%BC%E4%BA%8Ec%E7%9A%84this%E6%8C%87%E9%92%88\&#34;&gt;5.this 类似于c++的this指针&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB%E7%BB%84%E6%88%90java-bean\&#34;&gt;6. 标准的类组成（Java bean）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81\&#34;&gt;7. 快速生成代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-%E7%BB%A7%E6%89%BF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83\&#34;&gt;8. 继承代码规范&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1\&#34;&gt;9. 匿名对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#10-final%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%80%E7%BB%88%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84\&#34;&gt;10. final关键字，最终的不可变的&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E5%85%A7%E9%83%A8%E7%B1%BB\&#34;&gt;4. 內部类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E7%B1%BB\&#34;&gt;分类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%BC%E5%BC%8F\&#34;&gt;格式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE\&#34;&gt;内部类访问&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%A7%84%E5%88%99\&#34;&gt;类定义的权限修饰符规则&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;shell编程\&#34;&gt;shell编程&lt;/h1&gt;\n&lt;h2 id=\&#34;编写简单的脚本\&#34;&gt;&lt;strong&gt;编写简单的脚本&lt;/strong&gt;&lt;/h2&gt;\n&lt;p&gt;例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# vim example.sh\n#!/bin/bash \n#For Example BY linuxprobe.com \npwd \nls -al\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;​\tShell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第三、四行的可执行语句也就是我们平时执行的Linux命令了&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;bash xxxxx.sh &lt;em&gt;执行&lt;/em&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;接收用户的参数\&#34;&gt;&lt;strong&gt;接收用户的参数&lt;/strong&gt;&lt;/h2&gt;\n&lt;p&gt;但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板了。为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。&lt;/p&gt;\n&lt;p&gt;其实，Linux系统中的Shell脚本语言早就考虑到了这些，已经内设了用于接收参数的变量，变量之间可以使用空格间隔。例如&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;对&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;应&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;当&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;前&lt;/mi&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;脚&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;本&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;名&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;称&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;，&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;0对应的是当前Shell脚本程序的名称，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.69444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;对&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;应&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;是&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;当&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;前&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.05764em;\&#34;&gt;S&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;h&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;e&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.01968em;\&#34;&gt;l&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.01968em;\&#34;&gt;l&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;脚&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;本&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;序&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;名&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;称&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;#对应的是总共有几个参数，&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;对&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;应&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;所&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;位&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;置&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;值&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;，&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;*对应的是所有位置的参数值，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.46528em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;对&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;应&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;是&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;所&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;有&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;位&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;置&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;参&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;数&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;值&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第N个位置的参数值，如图4-15所示。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/Shell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE%E5%8F%98%E9%87%8F.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;图4-15  Shell脚本程序中的参数位置变量&lt;/p&gt;\n&lt;p&gt;理论过后我们来练习一下。尝试编写一个脚本程序示例，通过引用上面的变量参数来看下真实效果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# vim example.sh\n#!/bin/bash\necho &amp;quot;当前脚本名称为$0&amp;quot;\necho &amp;quot;总共有$#个参数，分别是$*。&amp;quot;\necho &amp;quot;第1个参数为$1，第5个为$5。&amp;quot;\n[root@linuxprobe ~]# sh example.sh one two three four five six\n当前脚本名称为example.sh\n总共有6个参数，分别是one two three four five six。\n第1个参数为one，第5个为five。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;判断用户的参数\&#34;&gt;&lt;strong&gt;判断用户的参数&lt;/strong&gt;&lt;/h2&gt;\n&lt;p&gt;在本书前面章节中讲到，系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。条件测试语法的执行格式如图4-16所示。切记，条件表达式两边均应有一个空格。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;图4-16  条件测试语句的执行格式&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;按照测试对象来划分，条件测试语句可以分为4种：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;文件测试语句；&lt;/p&gt;\n&lt;p&gt;逻辑测试语句；&lt;/p&gt;\n&lt;p&gt;整数值比较语句；&lt;/p&gt;\n&lt;p&gt;字符串比较语句。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表4-3所示。&lt;/p&gt;\n&lt;p&gt;表4-3                                                    文件测试所用的参数&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;操作符&lt;/th&gt;\n&lt;th&gt;作用&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;-d&lt;/td&gt;\n&lt;td&gt;测试文件是否为目录类型&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-e&lt;/td&gt;\n&lt;td&gt;测试文件是否存在&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-f&lt;/td&gt;\n&lt;td&gt;判断是否为一般文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-r&lt;/td&gt;\n&lt;td&gt;测试当前用户是否有权限读取&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-w&lt;/td&gt;\n&lt;td&gt;测试当前用户是否有权限写入&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-x&lt;/td&gt;\n&lt;td&gt;测试当前用户是否有权限执行&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着目录不存在：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# [ -d /etc/fstab ]\n[root@linuxprobe ~]# echo $?\n1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;再使用文件测试语句来判断/etc/fstab是否为一般文件，如果返回值为0，则代表文件存在，且为一般文件：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# [ -f /etc/fstab ]\n[root@linuxprobe ~]# echo $?\n0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&amp;amp;&amp;amp;，&lt;strong&gt;它表示当前面的命令执行成功后才会执行它后面的命令&lt;/strong&gt;，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# [ -e /dev/cdrom ] &amp;amp;&amp;amp; echo &amp;quot;Exist&amp;quot;\nExist\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;除了逻辑“与”外，还有逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的&lt;strong&gt;命令执行失败后才会执行它后面的命令&lt;/strong&gt;，因此可以用来结合系统环境变量USER来判断当前登录的用户是否为非管理员身份：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# echo $USER\nroot\n[root@linuxprobe ~]# [ $USER = root ] || echo &amp;quot;user&amp;quot;\n[root@linuxprobe ~]# su - linuxprobe \n[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo &amp;quot;user&amp;quot;\nuser\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第三种逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果则将其变成正确的。&lt;/p&gt;\n&lt;p&gt;我们现在切换回到root管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[linuxprobe@linuxprobe ~]$ exit\nlogout\n[root@linuxprobe root]# [ $USER != root ] || echo &amp;quot;administrator&amp;quot;\nadministrator\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;就技术图书的写作来讲，一般有两种套路：让读者真正搞懂技术了；让读者觉得自己搞懂技术了。因此市面上很多浅显的图书会让读者在学完之后感觉进步特别快，这基本上是作者有意为之，目的就是让您觉得“图书很有料，自己收获很大”，但是在步入工作岗位后就露出短板吃大亏。所以刘遄老师决定继续提高难度，为读者增加一个综合的示例，一方面作为前述知识的总结，另一方面帮助读者夯实基础，能够在今后工作中更灵活地使用逻辑符号。&lt;/p&gt;\n&lt;p&gt;当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的USER变量名称是否等于root，然后用逻辑运算符“非”进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运算符输出user字样；或条件不满足则会通过逻辑“或”运算符输出root字样，而如果前面的&amp;amp;&amp;amp;不成立才会执行后面的||符号。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# [ $USER != root ] &amp;amp;&amp;amp; echo &amp;quot;user&amp;quot; || echo &amp;quot;root&amp;quot;\nroot\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表4-4所示。&lt;/p&gt;\n&lt;p&gt;表4-4                                                  可用的整数比较运算符&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;操作符&lt;/th&gt;\n&lt;th&gt;作用&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;-eq&lt;/td&gt;\n&lt;td&gt;是否等于&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-ne&lt;/td&gt;\n&lt;td&gt;是否不等于&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-gt&lt;/td&gt;\n&lt;td&gt;是否大于&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-lt&lt;/td&gt;\n&lt;td&gt;是否小于&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-le&lt;/td&gt;\n&lt;td&gt;是否等于或小于&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-ge&lt;/td&gt;\n&lt;td&gt;是否大于或等于&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;接下来小试牛刀。我们先测试一下10是否大于10以及10是否等于10（通过输出的返回值内容来判断）：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# [ 10 -gt 10 ]\n[root@linuxprobe ~]# echo $?\n1\n[root@linuxprobe ~]# [ 10 -eq 10 ]\n[root@linuxprobe ~]# echo $?\n0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在2.4节曾经讲过free命令，它可以用来获取当前系统正在使用及可用的内存量信息。接下来先使用free -m命令查看内存使用量情况（单位为MB），然后通过grep Mem:命令过滤出剩余内存量的行，再用awk &#39;{print $4}&#39;命令只保留第四列，最后用FreeMem=&lt;code&gt;语句&lt;/code&gt;的方式把语句内执行的结果赋值给变量。&lt;/p&gt;\n&lt;p&gt;这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# free -m\n            total     used     free     shared     buffers     cached\nMem:        1826      1244     582      9          1           413\n-/+ buffers/cache:    830 996\nSwap:       2047      0        2047\n[root@linuxprobe ~]# free -m | grep Mem:\nMem:        1826      1244     582      9 \n[root@linuxprobe ~]# free -m | grep Mem: | awk &#39;{print $4}&#39;\n582\n[root@linuxprobe ~]# FreeMem=`free -m | grep Mem: | awk &#39;{print $4}&#39;`\n[root@linuxprobe ~]# echo $FreeMem \n582\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于1024，若小于则会提示“Insufficient Memory”（内存不足）的字样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# [ $FreeMem -lt 1024 ] &amp;amp;&amp;amp; echo &amp;quot;Insufficient Memory&amp;quot;\nInsufficient Memory\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;字符串&lt;/code&gt;比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表4-5所示。&lt;/p&gt;\n&lt;p&gt;表4-5                                                常见的字符串比较运算符&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;操作符&lt;/th&gt;\n&lt;th&gt;作用&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;=&lt;/td&gt;\n&lt;td&gt;比较字符串内容是否相同&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;!=&lt;/td&gt;\n&lt;td&gt;比较字符串内容是否不同&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;-z&lt;/td&gt;\n&lt;td&gt;判断字符串内容是否为空&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;接下来通过判断String变量是否为空值，进而判断是否定义了这个变量：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# [ -z $String ]\n[root@linuxprobe ~]# echo $?\n0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;再尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值LANG不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# echo $LANG\nen_US.UTF-8\n[root@linuxprobe ~]# [ $LANG != &amp;quot;en.US&amp;quot; ] &amp;amp;&amp;amp; echo &amp;quot;Not en.US&amp;quot;\nNot en.US\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;流程控制语句\&#34;&gt;&lt;strong&gt;流程控制语句&lt;/strong&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;if、for、while、case这4种流程控制语句来学习编写难度更大、功能更强的Shell脚本。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;if条件测试语句\&#34;&gt;&lt;strong&gt;if条件测试语句&lt;/strong&gt;&lt;/h3&gt;\n&lt;p&gt;if条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。&lt;/p&gt;\n&lt;p&gt;if条件语句的单分支结构由if、then、fi关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的if语句属于最简单的一种条件判断结构，语法格式如图4-17所示。&lt;br&gt;\n&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8D%95%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-2.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;图4-17  单分支的if语句&lt;/p&gt;\n&lt;p&gt;下面使用单分支的if条件语句来判断/media/cdrom文件是否存在，若存在就结束条件判断和整个Shell脚本，反之则去创建这个目录：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# vim mkcdrom.sh\n#!/bin/bash\nDIR=&amp;quot;/media/cdrom&amp;quot;\nif [ ! -e $DIR ]\nthen\nmkdir -p $DIR\nfi\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于第5章才讲解用户身份与权限，因此这里继续用“bash 脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用ls命令验证/media/cdrom目录是否已经成功创建：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# bash mkcdrom.sh\n[root@linuxprobe ~]# ls -d /media/cdrom\n/media/cdrom\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if条件语句的双分支结构也是一种很简单的判断结构，语法格式如图4-18所示。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8F%8C%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-1.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;图4-18 双分支的if条件语句&lt;/p&gt;\n&lt;p&gt;下面使用双分支的if条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用ping命令来测试与对方主机的网络联通性，而Linux系统中的ping命令不像Windows一样尝试4次就结束，因此为了避免用户等待时间过长，需要通过-c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# vim chkhost.sh\n#!/bin/bash\nping -c 3 -i 0.2 -W 3 $1 &amp;amp;&amp;gt; /dev/null\nif [ $? -eq 0 ]\nthen\necho &amp;quot;Host $1 is On-line.&amp;quot;\nelse\necho &amp;quot;Host $1 is Off-line.&amp;quot;\nfi\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们在4.2.3小节中用过&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;作&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;显&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;示&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;次&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;命&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;令&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;返&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;回&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;值&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;。&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;若&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;前&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;面&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;那&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;条&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;语&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;句&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;则&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.69444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;?&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;变&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;量&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;，&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;作&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;用&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;是&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;显&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;示&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;上&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;一&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;次&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;命&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;令&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;返&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;回&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;值&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;。&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;若&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;前&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;面&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;那&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;条&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;语&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;句&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;成&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;功&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;，&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为0，从而获知那条语句的最终判断情况。这里的服务器IP地址为192.168.10.10，我们来验证一下脚本的效果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# bash chkhost.sh 192.168.10.10\nHost 192.168.10.10 is On-line.\n[root@linuxprobe ~]# bash chkhost.sh 192.168.10.20\nHost 192.168.10.20 is Off-line.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图4-19所示。&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%A4%9A%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-2.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;图 4-19 多分支的if条件语句&lt;/p&gt;\n&lt;p&gt;下面使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如Excellent、Pass、Fail等提示信息。在Linux系统中，read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于向用户显示一定的提示信息。在下面的脚本示例中，只有当用户输入的分数大于等于85分且小于等于100分，才输出Excellent字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于70分且小于等于84分，如果是，则输出Pass字样；若两次都落空（即两次的匹配操作都失败了），则输出Fail字样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-bash\&#34;&gt;[root@linuxprobe ~]# vim chkscore.sh\n#!/bin/bash\nread -p &amp;quot;Enter your score（0-100）：&amp;quot; GRADE\nif [ $GRADE -ge 85 ] &amp;amp;&amp;amp; [ $GRADE -le 100 ] ; then\necho &amp;quot;$GRADE is Excellent&amp;quot;\nelif [ $GRADE -ge 70 ] &amp;amp;&amp;amp; [ $GRADE -le 84 ] ; then\necho &amp;quot;$GRADE is Pass&amp;quot;\nelse\necho &amp;quot;$GRADE is Fail&amp;quot; \nfi\n[root@linuxprobe ~]# bash chkscore.sh\nEnter your score（0-100）：88\n88 is Excellent\n[root@linuxprobe ~]# bash chkscore.sh \nEnter your score（0-100）：80\n80 is Pass\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面执行该脚本。当用户输入的分数分别为30和200时，其结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# bash chkscore.sh  \nEnter your score（0-100）：30\n30 is Fail\n[root@linuxprobe ~]# bash chkscore.sh\nEnter your score（0-100）：200 \n200 is Fail\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;为什么输入的分数为200时，依然显示Fail呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于100或小于0的分数时，给予Error报错字样的提示。&lt;/p&gt;\n&lt;h3 id=\&#34;for条件循环语句\&#34;&gt;&lt;strong&gt;for条件循环语句&lt;/strong&gt;&lt;/h3&gt;\n&lt;p&gt;or循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用for循环语句再适合不过了。for循环语句的语法格式如图4-20所示。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/for%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;图4-20  for循环语句的语法格式&lt;/p&gt;\n&lt;p&gt;下面使用for循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# vim users.txt\nandy\nbarry\ncarl\nduke\neric\ngeorge\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接下来编写Shell脚本Example.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id 用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。&lt;/p&gt;\n&lt;p&gt;需要多说一句，/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# vim Example.sh\n#!/bin/bash\nread -p &amp;quot;Enter The Users Password : &amp;quot; PASSWD\nfor UNAME in `cat users.txt`\ndo\nid $UNAME &amp;amp;&amp;gt; /dev/null\nif [ $? -eq 0 ]\nthen\necho &amp;quot;Already exists&amp;quot;\nelse\nuseradd $UNAME &amp;amp;&amp;gt; /dev/null\necho &amp;quot;$PASSWD&amp;quot; | passwd --stdin $UNAME &amp;amp;&amp;gt; /dev/null\nif [ $? -eq 0 ]\nthen\necho &amp;quot;$UNAME , Create success&amp;quot;\nelse\necho &amp;quot;$UNAME , Create failure&amp;quot;\nfi\nfi\ndone\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行批量创建用户的Shell脚本Example.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后不会有其他内容。&lt;/p&gt;\n&lt;p&gt;在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# bash Example.sh\nEnter The Users Password : linuxprobe\nandy , Create success\nbarry , Create success\ncarl , Create success\nduke , Create success\neric , Create success\ngeorge , Create success\n[root@linuxprobe ~]# tail -6 /etc/passwd\nandy:x:1001:1001::/home/andy:/bin/bash\nbarry:x:1002:1002::/home/barry:/bin/bash\ncarl:x:1003:1003::/home/carl:/bin/bash\nduke:x:1004:1004::/home/duke:/bin/bash\neric:x:1005:1005::/home/eric:/bin/bash\ngeorge:x:1006:1006::/home/george:/bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;您还记得在学习双分支if条件语句时，用到的那个测试主机是否在线的脚本么？既然我们现在已经掌握了for循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。&lt;/p&gt;\n&lt;p&gt;首先创建一个主机列表文件ipadds.txt：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# vim ipadds.txt\n192.168.10.10\n192.168.10.11\n192.168.10.12\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后前面的双分支if条件语句与for循环语句相结合，让脚本从主机列表文件ipadds.txt中自动读取IP地址（用来表示主机）并将其赋值给HLIST变量，从而通过判断ping命令执行后的返回值来逐个测试主机是否在线。脚本中出现的$（命令）是一种完全类似于第3章的转义字符中反引号&lt;code&gt;命令&lt;/code&gt;的Shell操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# vim CheckHosts.sh\n#!/bin/bash\nHLIST=$(cat ~/ipadds.txt)\nfor IP in $HLIST\ndo\nping -c 3 -i 0.2 -W 3 $IP &amp;amp;&amp;gt; /dev/null\nif [ $? -eq 0 ] ; then\necho &amp;quot;Host $IP is On-line.&amp;quot;\nelse\necho &amp;quot;Host $IP is Off-line.&amp;quot;\nfi\ndone\n[root@linuxprobe ~]# ./CheckHosts.sh\nHost 192.168.10.10 is On-line.\nHost 192.168.10.11 is Off-line.\nHost 192.168.10.12 is Off-line.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;while条件循环语句\&#34;&gt;&lt;strong&gt;while条件循环语句&lt;/strong&gt;&lt;/h3&gt;\n&lt;p&gt;while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while语句的语法格式如图4-21所示。&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/while%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;图4-21  while循环语句的语法格式&lt;/p&gt;\n&lt;p&gt;接下来结合使用多分支的if条件测试语句与while条件循环语句，编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们当前要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，这两者相等之后才运行exit 0命令，终止脚本的执行。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# vim Guess.sh\n#!/bin/bash\nPRICE=$(expr $RANDOM % 1000)\nTIMES=0\necho &amp;quot;商品实际价格为0-999之间，猜猜看是多少？&amp;quot;\nwhile true\ndo\nread -p &amp;quot;请输入您猜测的价格数目：&amp;quot; INT\nlet TIMES++\nif [ $INT -eq $PRICE ] ; then\necho &amp;quot;恭喜您答对了，实际价格是 $PRICE&amp;quot;\necho &amp;quot;您总共猜测了 $TIMES 次&amp;quot;\nexit 0\nelif [ $INT -gt $PRICE ] ; then\necho &amp;quot;太高了！&amp;quot;\nelse\necho &amp;quot;太低了！&amp;quot;\nfi\ndone\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这个Guess.sh脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到let TIMES++命令时都会让TIMES变量内的数值加1，用来统计循环总计执行了多少次。这可以让用户得知总共猜测了多少次之后，才猜对价格。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# bash Guess.sh\n商品实际价格为0-999之间，猜猜看是多少？\n请输入您猜测的价格数目：500\n太低了！\n请输入您猜测的价格数目：800\n太高了！\n请输入您猜测的价格数目：650\n太低了！\n请输入您猜测的价格数目：720\n太高了！\n请输入您猜测的价格数目：690\n太低了！\n请输入您猜测的价格数目：700\n太高了！\n请输入您猜测的价格数目：695\n太高了！\n请输入您猜测的价格数目：692\n太高了！\n请输入您猜测的价格数目：691\n恭喜您答对了，实际价格是 691\n您总共猜测了 9 次\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;case条件测试语句\&#34;&gt;&lt;strong&gt;case条件测试语句&lt;/strong&gt;&lt;/h3&gt;\n&lt;p&gt;如果您之前学习过C语言，看到这一小节的标题肯定会会心一笑“这不就是switch语句嘛！”是的，case条件测试语句和switch语句的功能非常相似！case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。case语句的语法结构如图4-22所示。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://www.linuxprobe.com/wp-content/uploads/2015/07/case%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png\&#34; alt=\&#34;第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;图4-22  case条件测试语句的语法结构&lt;/p&gt;\n&lt;p&gt;在前文介绍的Guess.sh脚本中有一个致命的弱点—只能接受数字！您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a是否大于等于3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。&lt;/p&gt;\n&lt;p&gt;通过在脚本中组合使用case条件测试语句和通配符（详见第3章），完全可以满足这里的需求。接下来我们编写脚本Checkkeys.sh，提示用户输入一个字符并将其赋值给变量KEY，然后根据变量KEY的值向用户显示其值是字母、数字还是其他字符。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;[root@linuxprobe ~]# vim Checkkeys.sh\n#!/bin/bash\nread -p &amp;quot;请输入一个字符，并按Enter键确认：&amp;quot; KEY\ncase &amp;quot;$KEY&amp;quot; in\n[a-z]|[A-Z])\necho &amp;quot;您输入的是 字母。&amp;quot;\n;;\n[0-9])\necho &amp;quot;您输入的是 数字。&amp;quot;\n;;\n*)\necho &amp;quot;您输入的是 空格、功能键或其他控制字符。&amp;quot;\nesac\n[root@linuxprobe ~]# bash Checkkeys.sh\n请输入一个字符，并按Enter键确认：6\n您输入的是 数字。\n[root@linuxprobe ~]# bash Checkkeys.sh\n请输入一个字符，并按Enter键确认：p\n您输入的是 字母。\n[root@linuxprobe ~]# bash Checkkeys.sh\n请输入一个字符，并按Enter键确认：^[[15~\n您输入的是 空格、功能键或其他控制字符。\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;shell编程&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;shell编程&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;shell编程&#34;,&#34;slug&#34;:&#34;cwvOdNjtLD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/cwvOdNjtLD/&#34;}],&#34;date&#34;:&#34;2020-02-13 21:14:58&#34;,&#34;dateFormat&#34;:&#34;2020-02-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/shell编程/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;26 min read&#34;,&#34;time&#34;:1524000,&#34;words&#34;:6612,&#34;minutes&#34;:26},&#34;description&#34;:&#34;shell编程\n编写简单的脚本\n例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：\n[root@linuxprobe ~]# vim example.sh\n#!/bin/bash \n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#shell%E7%BC%96%E7%A8%8B\&#34;&gt;shell编程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%9C%AC\&#34;&gt;&lt;strong&gt;编写简单的脚本&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E7%9A%84%E5%8F%82%E6%95%B0\&#34;&gt;&lt;strong&gt;接收用户的参数&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E7%9A%84%E5%8F%82%E6%95%B0\&#34;&gt;&lt;strong&gt;判断用户的参数&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5\&#34;&gt;&lt;strong&gt;流程控制语句&lt;/strong&gt;&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#if%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5\&#34;&gt;&lt;strong&gt;if条件测试语句&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#for%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\&#34;&gt;&lt;strong&gt;for条件循环语句&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#while%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\&#34;&gt;&lt;strong&gt;while条件循环语句&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#case%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5\&#34;&gt;&lt;strong&gt;case条件测试语句&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;文件处理命令\&#34;&gt;文件处理命令&lt;/h1&gt;\n&lt;h2 id=\&#34;文件处理命令ls\&#34;&gt;文件处理命令：ls&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：ls&lt;/p&gt;\n&lt;p&gt;命令英文原意：list&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/ls&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;功能描述：显示目录文件&lt;/p&gt;\n&lt;p&gt;语法：ls  选项[-ald]  [文件或目录]&lt;/p&gt;\n&lt;p&gt;-a    显示所有文件，包括隐藏文件&lt;/p&gt;\n&lt;p&gt;-l    详细信息显示(具体)&lt;/p&gt;\n&lt;p&gt;-d  查看目录属性&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令cd\&#34;&gt;文件处理命令：cd&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：cd&lt;/p&gt;\n&lt;p&gt;命令英文原意：change directory&lt;/p&gt;\n&lt;p&gt;命令所在路径：shell内置命令&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：cd [目录]&lt;/p&gt;\n&lt;p&gt;功能描述：切换目录&lt;/p&gt;\n&lt;p&gt;范例： $ cd  / 切换到根目录&lt;/p&gt;\n&lt;p&gt;$ cd  ..回到上一级目录&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令touch\&#34;&gt;文件处理命令：touch&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：touch&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/touch&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：touch  [文件名]&lt;/p&gt;\n&lt;p&gt;功能描述：创建空文件&lt;/p&gt;\n&lt;p&gt;范例： $ touch newfile&lt;/p&gt;\n&lt;p&gt;有些服务器日志文件。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令mkdir\&#34;&gt;文件处理命令：mkdir&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：mkdir&lt;/p&gt;\n&lt;p&gt;命令英文原意：make directories&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/mkdir&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：mkdir  [目录名]&lt;/p&gt;\n&lt;p&gt;功能描述：创建新目录&lt;/p&gt;\n&lt;p&gt;范例： $ mkdir newdir&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令cp\&#34;&gt;文件处理命令：cp&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：cp&lt;/p&gt;\n&lt;p&gt;命令英文原意：copy&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/cp&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：cp  -R  [源文件或目录] [目的目录]&lt;/p&gt;\n&lt;p&gt;​                   -R    复制目录&lt;/p&gt;\n&lt;p&gt;功能描述：复制文件或目录&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;cp  file1 file2  dir1 &lt;strong&gt;将文件file1、file2复制到目录dir1&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;cp  -R dir1 dir2 &lt;strong&gt;将dir1下的所有文件及子目录复制到dir2&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令mv\&#34;&gt;文件处理命令：mv&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;文件处理命令：mv&lt;/p&gt;\n&lt;p&gt;命令英文原意：move&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/mv&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：mv  [源文件或目录]  [目的目录]&lt;/p&gt;\n&lt;p&gt;功能描述：移动文件、更名&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;mv  file1 file3&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;将当前目录下文件file1更名为file3&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;mv  file2  dir2&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;将文件file2移动到目录dir2下&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令rm\&#34;&gt;文件处理命令：rm&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：rm&lt;/p&gt;\n&lt;p&gt;命令英文原意：remove&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/rm&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：rm  -r   [文件或目录]&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t\t-r 删除目录&lt;/p&gt;\n&lt;p&gt;功能描述：删除文件&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;$ rm file3 &lt;strong&gt;删除文件file3&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;rm -r dir1&lt;strong&gt;删除目录dir1&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;rm -f 强制不提问删除&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;rmdir命令\&#34;&gt;rmdir命令&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;nrmdir 命令参数说明：&lt;/p&gt;\n&lt;p&gt;n-p 表示递归删除目录，如果子目录删除后若其父目录为空，则将一同删除；&lt;/p&gt;\n&lt;p&gt;n比如rmdir  -p ccc/new表示删除ccc/目录中的new目录，若ccc也为空，则ccc目录也将被删除后。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令cat\&#34;&gt;文件处理命令：cat&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：cat&lt;/p&gt;\n&lt;p&gt;命令英文原意：concatenate and display files&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/cat&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：cat 文件名&lt;/p&gt;\n&lt;p&gt;功能描述：显示文件内容&lt;/p&gt;\n&lt;p&gt;范例： $ cat  /etc/issue&lt;/p&gt;\n&lt;p&gt;​             $ cat  /etc/services&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令more\&#34;&gt;文件处理命令：more&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：more&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/more&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：more  文件名&lt;/p&gt;\n&lt;p&gt;(空格) 或f  \t  显示下一页&lt;/p&gt;\n&lt;p&gt;(Enter)\t\t\t显示下一行&lt;/p&gt;\n&lt;p&gt;q或Q\t\t\t 退出&lt;/p&gt;\n&lt;p&gt;功能描述：分页显示文件内容&lt;/p&gt;\n&lt;p&gt;范例：   $ more  /etc/services&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理指令head\&#34;&gt;文件处理指令：head&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;文件处理指令：head&lt;/p&gt;\n&lt;p&gt;指令所在路径：/bin/head&lt;/p&gt;\n&lt;p&gt;执行权限：All User&lt;/p&gt;\n&lt;p&gt;语法：head  -num  [文件名]&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t\t  -num  显示文件的前num行&lt;/p&gt;\n&lt;p&gt;功能描述：查看文件的前几行&lt;/p&gt;\n&lt;p&gt;范例：$ head  -20  /etc/services&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理指令tail\&#34;&gt;文件处理指令：tail&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;指令名称：tail&lt;/p&gt;\n&lt;p&gt;指令所在路径：/bin/tail&lt;/p&gt;\n&lt;p&gt;执行权限：All User&lt;/p&gt;\n&lt;p&gt;语法：tail  -num  [文件名]&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t\t  -num  显示文件的后num行&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t\t-f   \t动态显示文件内容&lt;/p&gt;\n&lt;p&gt;功能描述：查看文件的后几行&lt;/p&gt;\n&lt;p&gt;范例： $ tail  -30  /etc/services&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;catmore-less-命令差异\&#34;&gt;cat,more, less 命令差异&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;n这三者命令均具有查看文件内容之功能。&lt;/p&gt;\n&lt;p&gt;ncat命令一次显示所有文件内容，而后两者可与用户交换以方便用户查看。&lt;/p&gt;\n&lt;p&gt;ncat命令还具有合并文件之功能。&lt;/p&gt;\n&lt;p&gt;nless允许用户后翻查看已经阅读过的内容；less并未在一开始就读入文件所有内容，因此其在查看文件时比vi速度快。&lt;/p&gt;\n&lt;p&gt;nless比more支持更多的控制命令。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件处理命令ln\&#34;&gt;文件处理命令：ln&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：ln&lt;/p&gt;\n&lt;p&gt;命令英文原意：link&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/ln&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：ln  -s  [源文件]  [目标文件]&lt;/p&gt;\n&lt;p&gt;​\t\t\t-s  创建软链接&lt;/p&gt;\n&lt;p&gt;功能描述：产生链接文件&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569395728536.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;权限管理命令\&#34;&gt;权限管理命令&lt;/h1&gt;\n&lt;h2 id=\&#34;权限管理命令chmod\&#34;&gt;权限管理命令：chmod&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569395787748.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569395805127.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;代表字符&lt;/th&gt;\n&lt;th&gt;权限&lt;/th&gt;\n&lt;th&gt;对文件的含义&lt;/th&gt;\n&lt;th&gt;对目录的含义&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;r&lt;/td&gt;\n&lt;td&gt;读权限&lt;/td&gt;\n&lt;td&gt;可以查看文件   内容&lt;/td&gt;\n&lt;td&gt;可以列出目录中   的内容&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;w&lt;/td&gt;\n&lt;td&gt;写权限&lt;/td&gt;\n&lt;td&gt;可以修改文件   内容&lt;/td&gt;\n&lt;td&gt;可以在目录中创   建、删除文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;x&lt;/td&gt;\n&lt;td&gt;执行权限&lt;/td&gt;\n&lt;td&gt;可以执行文件&lt;/td&gt;\n&lt;td&gt;可以进入目录&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;权限管理命令chown\&#34;&gt;权限管理命令：chown&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569395894091.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;权限管理命令chgrp\&#34;&gt;权限管理命令：chgrp&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569395920736.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;权限管理命令umask\&#34;&gt;权限管理命令：umask&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569395952435.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件搜索命令which\&#34;&gt;文件搜索命令：which&lt;/h2&gt;\n&lt;p&gt;{% asset_img 1569395976657.png  %}&lt;/p&gt;\n&lt;h1 id=\&#34;文件搜索命令\&#34;&gt;文件搜索命令&lt;/h1&gt;\n&lt;h2 id=\&#34;文件搜索命令find\&#34;&gt;文件搜索命令：find&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396005329.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396018569.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396030692.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件搜索指令locate\&#34;&gt;文件搜索指令：locate&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396058511.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件搜索指令updatedb\&#34;&gt;文件搜索指令：updatedb&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396210406.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;文件搜索命令grep\&#34;&gt;文件搜索命令：grep&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396232647.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;帮助命令\&#34;&gt;帮助命令&lt;/h1&gt;\n&lt;h2 id=\&#34;帮助命令man\&#34;&gt;帮助命令：man&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396254275.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396293782.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;帮助指令info\&#34;&gt;帮助指令：info&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396339210.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;ninfo命令浏览系统在线帮助文档&lt;/p&gt;\n&lt;p&gt;ninfo可通过链接和交叉引用来浏览文档&lt;/p&gt;\n&lt;p&gt;ninfo也可直接跳转到相关章节&lt;/p&gt;\n&lt;p&gt;ninfo命令用法： info command&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;帮助指令whatis\&#34;&gt;帮助指令：whatis&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;指令名称：whatis  apropos  makewhatis&lt;/p&gt;\n&lt;p&gt;指令英文原义：search the whatis database for strings&lt;/p&gt;\n&lt;p&gt;指令所在路径：/usr/bin/whatis apropos&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t\t\t  /usr/sbin/makewhatis&lt;/p&gt;\n&lt;p&gt;执行权限：All User， All User，root&lt;/p&gt;\n&lt;p&gt;语法：whatis apropos [任何关键字]&lt;/p&gt;\n&lt;p&gt;功能描述：获得索引的简短说明信息&lt;/p&gt;\n&lt;p&gt;范例：$whatis ls&lt;/p&gt;\n&lt;p&gt;​\t\t\t\tapropos fstab   &lt;mark&gt;相当于man -k&lt;/mark&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;压缩解压命令\&#34;&gt;压缩解压命令&lt;/h1&gt;\n&lt;h2 id=\&#34;压缩解压命令gzip\&#34;&gt;压缩解压命令：gzip&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396473842.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;压缩解压命令gunzip\&#34;&gt;压缩解压命令：gunzip&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396499742.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;压缩解压命令tar\&#34;&gt;压缩解压命令：tar&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：tar&lt;/p&gt;\n&lt;p&gt;命令所在路径：/bin/tar&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：tar  选项[cvf]  [目录]&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t  -c    产生.tar打包文件&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t  -v显示详细信息&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t\t-f  指定压缩后的文件名&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t\t-z  打包同时压缩&lt;/p&gt;\n&lt;p&gt;功能描述：打包目录&lt;/p&gt;\n&lt;p&gt;压缩后文件格式：.tar.gz&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396569481.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;tar命令解压缩语法：&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396599104.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;压缩解压命令zip\&#34;&gt;压缩解压命令：zip&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;命令名称：zip&lt;/p&gt;\n&lt;p&gt;命令所在路径：/usr/bin/zip&lt;/p&gt;\n&lt;p&gt;执行权限：所有用户&lt;/p&gt;\n&lt;p&gt;语法：&lt;/p&gt;\n&lt;p&gt;zip  选项[-r]  [压缩后文件名称]  [文件或目录]&lt;/p&gt;\n&lt;p&gt;​\t\t\t\t-r 压缩目录&lt;/p&gt;\n&lt;p&gt;功能描述：压缩文件或目录&lt;/p&gt;\n&lt;p&gt;压缩后文件格式：.zip&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396692106.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;压缩解压命令unzip\&#34;&gt;压缩解压命令：unzip&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396725382.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;压缩解压命令bzip2\&#34;&gt;压缩解压命令：bzip2&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396753381.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;压缩解压命令bunzip2\&#34;&gt;压缩解压命令：bunzip2&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396783950.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;网络通信命令\&#34;&gt;网络通信命令&lt;/h1&gt;\n&lt;h2 id=\&#34;网络通信指令write\&#34;&gt;网络通信指令：write&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396810754.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;网络通信指令wall\&#34;&gt;网络通信指令：wall&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396832808.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;网络通信命令ping\&#34;&gt;网络通信命令：ping&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396959724.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;网络通信命令ifconfig\&#34;&gt;网络通信命令：ifconfig&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569396978054.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;​&lt;/p&gt;\n&lt;h1 id=\&#34;系统关机命令\&#34;&gt;系统关机命令&lt;/h1&gt;\n&lt;h2 id=\&#34;系统关机命令shutdown\&#34;&gt;系统关机命令：shutdown&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569397008585.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;-k&lt;/strong&gt; &lt;strong&gt;并不真正关机，只是发出警告信息&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;​    &lt;strong&gt;-r&lt;/strong&gt;  &lt;strong&gt;关机后立即重新启动&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;​    &lt;strong&gt;-h&lt;/strong&gt;  &lt;strong&gt;关机后不重新启动&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;​    &lt;strong&gt;-f&lt;/strong&gt;   &lt;strong&gt;快速关机，重启时跳过****fcsk&lt;/strong&gt; &lt;strong&gt;命令&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;​    &lt;strong&gt;-n&lt;/strong&gt; &lt;strong&gt;快速关机，不经过****init&lt;/strong&gt; &lt;strong&gt;程序&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;​    &lt;strong&gt;-c&lt;/strong&gt; &lt;strong&gt;shutdown&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;系统关机命令reboot\&#34;&gt;系统关机命令：reboot&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569397091666.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;shell应用技巧\&#34;&gt;Shell应用技巧&lt;/h1&gt;\n&lt;h2 id=\&#34;命令别名\&#34;&gt;命令别名&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569397200117.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;输入输出重定向\&#34;&gt;输入/输出重定向&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569397234285.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569397219217.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;管道\&#34;&gt;管道&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;管道（&lt;/strong&gt;** pipe ** &lt;strong&gt;）是&lt;/strong&gt; &lt;strong&gt;UNIX&lt;/strong&gt; &lt;strong&gt;中最古老的进程间通信工具，它提供进程之间单向通信的方法。简单说，管道是连接一个进程的输出到另一个进程的输入的一种方法&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;管道：将一个命令的输出传送给另一个命令，&lt;/p&gt;\n&lt;p&gt;作为另一个命令的输入。&lt;/p&gt;\n&lt;p&gt;使用方法：&lt;/p&gt;\n&lt;p&gt;命令1|命令2|命令3……|命令n&lt;/p&gt;\n&lt;p&gt;范例：&lt;/p&gt;\n&lt;p&gt;ls -l /etc | more&lt;/p&gt;\n&lt;p&gt;ls -l /etc | grep init&lt;/p&gt;\n&lt;p&gt;ls -l /etc | grep init | wc -l&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;命令连接符\&#34;&gt;命令连接符&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569397503944.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;命令替换符\&#34;&gt;命令替换符&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;{% asset_img 1569397519948.png  %}&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;​&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;常用命令&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;常用命令&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Linux常用命令&#34;,&#34;slug&#34;:&#34;HihrMzbE0oJ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://bgst009.github.io/tag/HihrMzbE0oJ/&#34;}],&#34;date&#34;:&#34;2020-02-13 20:55:36&#34;,&#34;dateFormat&#34;:&#34;2020-02-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/常用命令/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:454000,&#34;words&#34;:1934,&#34;minutes&#34;:8},&#34;description&#34;:&#34;文件处理命令\n文件处理命令：ls\n\n命令名称：ls\n命令英文原意：list\n命令所在路径：/bin/ls\n执行权限：所有用户\n功能描述：显示目录文件\n语法：ls  选项[-ald]  [文件或目录]\n-a    显示所有文件，包括隐藏文件\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4\&#34;&gt;文件处理命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4ls\&#34;&gt;文件处理命令：ls&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4cd\&#34;&gt;文件处理命令：cd&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4touch\&#34;&gt;文件处理命令：touch&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4mkdir\&#34;&gt;文件处理命令：mkdir&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4cp\&#34;&gt;文件处理命令：cp&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4mv\&#34;&gt;文件处理命令：mv&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4rm\&#34;&gt;文件处理命令：rm&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rmdir%E5%91%BD%E4%BB%A4\&#34;&gt;rmdir命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4cat\&#34;&gt;文件处理命令：cat&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4more\&#34;&gt;文件处理命令：more&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4head\&#34;&gt;文件处理指令：head&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4tail\&#34;&gt;文件处理指令：tail&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#catmore-less-%E5%91%BD%E4%BB%A4%E5%B7%AE%E5%BC%82\&#34;&gt;cat,more, less 命令差异&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4ln\&#34;&gt;文件处理命令：ln&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4\&#34;&gt;权限管理命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4chmod\&#34;&gt;权限管理命令：chmod&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4chown\&#34;&gt;权限管理命令：chown&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4chgrp\&#34;&gt;权限管理命令：chgrp&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4umask\&#34;&gt;权限管理命令：umask&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4which\&#34;&gt;文件搜索命令：which&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4\&#34;&gt;文件搜索命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4find\&#34;&gt;文件搜索命令：find&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E6%8C%87%E4%BB%A4locate\&#34;&gt;文件搜索指令：locate&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E6%8C%87%E4%BB%A4updatedb\&#34;&gt;文件搜索指令：updatedb&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4grep\&#34;&gt;文件搜索命令：grep&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4\&#34;&gt;帮助命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4man\&#34;&gt;帮助命令：man&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4info\&#34;&gt;帮助指令：info&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4whatis\&#34;&gt;帮助指令：whatis&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4\&#34;&gt;压缩解压命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4gzip\&#34;&gt;压缩解压命令：gzip&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4gunzip\&#34;&gt;压缩解压命令：gunzip&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4tar\&#34;&gt;压缩解压命令：tar&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4zip\&#34;&gt;压缩解压命令：zip&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4unzip\&#34;&gt;压缩解压命令：unzip&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4bzip2\&#34;&gt;压缩解压命令：bzip2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4bunzip2\&#34;&gt;压缩解压命令：bunzip2&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%91%BD%E4%BB%A4\&#34;&gt;网络通信命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%8C%87%E4%BB%A4write\&#34;&gt;网络通信指令：write&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%8C%87%E4%BB%A4wall\&#34;&gt;网络通信指令：wall&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%91%BD%E4%BB%A4ping\&#34;&gt;网络通信命令：ping&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%91%BD%E4%BB%A4ifconfig\&#34;&gt;网络通信命令：ifconfig&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B3%BB%E7%BB%9F%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4\&#34;&gt;系统关机命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B3%BB%E7%BB%9F%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4shutdown\&#34;&gt;系统关机命令：shutdown&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B3%BB%E7%BB%9F%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4reboot\&#34;&gt;系统关机命令：reboot&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#shell%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7\&#34;&gt;Shell应用技巧&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D\&#34;&gt;命令别名&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91\&#34;&gt;输入/输出重定向&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%A1%E9%81%93\&#34;&gt;管道&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E8%BF%9E%E6%8E%A5%E7%AC%A6\&#34;&gt;命令连接符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2%E7%AC%A6\&#34;&gt;命令替换符&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;学习备忘&lt;/p&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;p&gt;Nobody&lt;/p&gt;\n&lt;h2 id=\&#34;兴趣爱好\&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;\n&lt;p&gt;骑行&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://bgst009.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:7000,&#34;words&#34;:38,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n学习备忘\n👨‍💻 博主是谁\nNobody\n⛹ 兴趣爱好\n骑行\n📬 联系我呀\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD\&#34;&gt;⛹ 兴趣爱好&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->


</html>