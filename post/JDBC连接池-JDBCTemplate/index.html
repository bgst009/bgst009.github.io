<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JDBC连接池&amp;JDBCTemplate | Gridea</title>
<link rel="shortcut icon" href="https://bgst009.github.io//favicon.ico?v=1611835942733">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://bgst009.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JDBC连接池&amp;JDBCTemplate | Gridea - Atom Feed" href="https://bgst009.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="数据库连接池
1. 概念：


其实就是一个容器(集合)，存放数据库连接的容器。
当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。


2. 好处：..." />
    <meta name="keywords" content="JDBC连接池,JDBCTemplate" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://bgst009.github.io/">
  <img class="avatar" src="https://bgst009.github.io//images/avatar.png?v=1611835942733" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JDBC连接池&amp;JDBCTemplate
            </h2>
            <div class="post-info">
              <span>
                2020-02-20
              </span>
              <span>
                8 min read
              </span>
              
                <a href="https://bgst009.github.io/tag/ZRt8sBVHK4/" class="post-tag">
                  # JDBC连接池
                </a>
              
                <a href="https://bgst009.github.io/tag/_ryo7rrMp3/" class="post-tag">
                  # JDBCTemplate
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="数据库连接池">数据库连接池</h1>
<h2 id="1-概念">1. 概念：</h2>
<blockquote>
<ol>
<li>其实就是一个容器(集合)，存放数据库连接的容器。</li>
<li>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</li>
</ol>
</blockquote>
<h2 id="2-好处">2. 好处：</h2>
<ol>
<li>节约资源</li>
<li>用户访问高效</li>
</ol>
<h2 id="3-实现">3. 实现：</h2>
<ol>
<li>标准接口：DataSource   javax.sql包下的
<ol>
<li>方法：
<ol>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li>
</ol>
</li>
</ol>
</li>
<li>一般我们不去实现它，有数据库厂商来实现
<ol>
<li>C3P0：数据库连接池技术</li>
<li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li>
</ol>
</li>
</ol>
<h2 id="4-c3p0数据库连接池技术">4. C3P0：数据库连接池技术</h2>
<ol>
<li>
<p>步骤：</p>
<ol>
<li>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar
<ol>
<li><strong>不要忘记导入数据库驱动jar包</strong></li>
</ol>
</li>
<li>定义配置文件：
<ol>
<li>名称： c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>代码：</p>
<pre><code class="language-java"> //1.创建数据库连接池对象
 DataSource ds  = new ComboPooledDataSource();
  //2. 获取连接对象
  Connection conn = ds.getConnection();
</code></pre>
</li>
</ol>
<h2 id="5-druid数据库连接池实现技术由阿里巴巴提供的">5. Druid：数据库连接池实现技术，由阿里巴巴提供的</h2>
<ol>
<li>
<p>步骤：</p>
<ol>
<li>导入jar包 druid-1.0.9.jar</li>
<li>定义配置文件：
<ol>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ol>
</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过<strong>工厂</strong>来来获取  <strong>DruidDataSourceFactory</strong></li>
<li>获取连接：<strong>getConnection</strong></li>
<li>代码：</li>
</ol>
<pre><code class="language-java">		 //3.加载配置文件
	        Properties pro = new Properties();
	        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
	        pro.load(is);
	        //4.获取连接池对象
	        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
	        //5.获取连接
	        Connection conn = ds.getConnection();
</code></pre>
</li>
<li>
<p>定义工具类</p>
<ol>
<li>
<p>定义一个类 JDBCUtils</p>
</li>
<li>
<p>提供静态代码块加载配置文件，初始化连接池对象</p>
</li>
<li>
<p>提供方法</p>
<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池的方法</li>
</ol>
</li>
<li>
<p>代码：</p>
<pre><code class="language-java">public class JDBCUtils {

			    //1.定义成员变量 DataSource
			    private static DataSource ds ;
			
			    static{
			        try {
			            //1.加载配置文件
			            Properties pro = new Properties();
			            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));
			            //2.获取DataSource
			            ds = DruidDataSourceFactory.createDataSource(pro);
			        } catch (IOException e) {
			            e.printStackTrace();
			        } catch (Exception e) {
			            e.printStackTrace();
			        }
			    }
			
			    /**
			     * 获取连接
			     */
			    public static Connection getConnection() throws SQLException {
			        return ds.getConnection();
			    }
			
			    /**
			     * 释放资源
			     */
			    public static void close(Statement stmt,Connection conn){
			       /* if(stmt != null){
			            try {
			                stmt.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			        if(conn != null){
			            try {
			                conn.close();//归还连接
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }*/
			
			       close(null,stmt,conn);
			    }
			
			
			    public static void close(ResultSet rs , Statement stmt, Connection conn){
			
			
			        if(rs != null){
			            try {
			                rs.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			
			        if(stmt != null){
			            try {
			                stmt.close();
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			
			        if(conn != null){
			            try {
			                conn.close();//归还连接
			            } catch (SQLException e) {
			                e.printStackTrace();
			            }
			        }
			    }
			
			    /**
			     * 获取连接池方法
			     */
			
			    public static DataSource getDataSource(){
			        return  ds;
			    }
			
			}
</code></pre>
</li>
</ol>
</li>
</ol>
<h1 id="spring-jdbc">Spring JDBC</h1>
<ul>
<li>
<p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
</li>
<li>
<p>步骤：</p>
<ol>
<li>
<p>导入jar包</p>
</li>
<li>
<p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
<ol>
<li>JdbcTemplate template = new JdbcTemplate(ds);</li>
</ol>
</li>
<li>
<p>调用JdbcTemplate的方法来完成CRUD的操作</p>
<ul>
<li>update():执行DML语句。增、删、改语句</li>
<li>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
<ul>
<li><strong>注意</strong>：这个方法查询的结果集长度只能是1</li>
</ul>
</li>
<li>queryForList():查询结果将结果集封装为list集合
<ul>
<li><strong>注意</strong>：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
</li>
<li>query():查询结果，将结果封装为JavaBean对象</li>
<li>query的参数：RowMapper
<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li>
</ul>
</li>
<li>queryForObject：查询结果，将结果封装为对象
<ul>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
</li>
<li>
<p>练习：</p>
<blockquote>
<p>需求：</p>
<ol>
<li>修改1号数据的 salary 为 10000</li>
<li>添加一条记录</li>
<li>删除刚才添加的记录</li>
<li>查询id为1的记录，将其封装为Map集合</li>
<li>查询所有记录，将其封装为List</li>
<li>查询所有记录，将其封装为Emp对象的List集合</li>
<li>查询总记录数</li>
</ol>
</blockquote>
</li>
<li>
<p>code</p>
</li>
</ol>
<pre><code class="language-java">    			import cn.itcast.domain.Emp;
    			import cn.itcast.utils.JDBCUtils;
    			import org.junit.Test;
    			import org.springframework.jdbc.core.BeanPropertyRowMapper;
    			import org.springframework.jdbc.core.JdbcTemplate;
    			import org.springframework.jdbc.core.RowMapper;

    			import java.sql.Date;
    			import java.sql.ResultSet;
    			import java.sql.SQLException;
    			import java.util.List;
    			import java.util.Map;

    			public class JdbcTemplateDemo2 {

    			    //Junit单元测试，可以让方法独立执行


    			    //1. 获取JDBCTemplate对象
    			    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
    			    /**
    			     * 1. 修改1号数据的 salary 为 10000
    			     */
    			    @Test
    			    public void test1(){

    			        //2. 定义sql
    			        String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;
    			        //3. 执行sql
    			        int count = template.update(sql);
    			        System.out.println(count);
    			    }

    			    /**
    			     * 2. 添加一条记录
    			     */
    			    @Test
    			    public void test2(){
    			        String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;
    			        int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);
    			        System.out.println(count);

    			    }

    			    /**
    			     * 3.删除刚才添加的记录
    			     */
    			    @Test
    			    public void test3(){
    			        String sql = &quot;delete from emp where id = ?&quot;;
    			        int count = template.update(sql, 1015);
    			        System.out.println(count);
    			    }

    			    /**
    			     * 4.查询id为1001的记录，将其封装为Map集合
    			     * 注意：这个方法查询的结果集长度只能是1
    			     */
    			    @Test
    			    public void test4(){
    			        String sql = &quot;select * from emp where id = ? or id = ?&quot;;
    			        Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);
    			        System.out.println(map);
    			        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}

    			    }

    			    /**
    			     * 5. 查询所有记录，将其封装为List
    			     */
    			    @Test
    			    public void test5(){
    			        String sql = &quot;select * from emp&quot;;
    			        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);

    			        for (Map&lt;String, Object&gt; stringObjectMap : list) {
    			            System.out.println(stringObjectMap);
    			        }
    			    }

    			    /**
    			     * 6. 查询所有记录，将其封装为Emp对象的List集合
    			     */

    			    @Test
    			    public void test6(){
    			        String sql = &quot;select * from emp&quot;;
    			        List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() {

    			            @Override
    			            public Emp mapRow(ResultSet rs, int i) throws SQLException {
    			                Emp emp = new Emp();
    			                int id = rs.getInt(&quot;id&quot;);
    			                String ename = rs.getString(&quot;ename&quot;);
    			                int job_id = rs.getInt(&quot;job_id&quot;);
    			                int mgr = rs.getInt(&quot;mgr&quot;);
    			                Date joindate = rs.getDate(&quot;joindate&quot;);
    			                double salary = rs.getDouble(&quot;salary&quot;);
    			                double bonus = rs.getDouble(&quot;bonus&quot;);
    			                int dept_id = rs.getInt(&quot;dept_id&quot;);

    			                emp.setId(id);
    			                emp.setEname(ename);
    			                emp.setJob_id(job_id);
    			                emp.setMgr(mgr);
    			                emp.setJoindate(joindate);
    			                emp.setSalary(salary);
    			                emp.setBonus(bonus);
    			                emp.setDept_id(dept_id);

    			                return emp;
    			            }
    			        });


    			        for (Emp emp : list) {
    			            System.out.println(emp);
    			        }
    			    }

    			    /**
    			     * 6. 查询所有记录，将其封装为Emp对象的List集合
    			     */

    			    @Test
    			    public void test6_2(){
    			        String sql = &quot;select * from emp&quot;;
    			        List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));
    			        for (Emp emp : list) {
    			            System.out.println(emp);
    			        }
    			    }

    			    /**
    			     * 7. 查询总记录数
    			     */

    			    @Test
    			    public void test7(){
    			        String sql = &quot;select count(id) from emp&quot;;
    			        Long total = template.queryForObject(sql, Long.class);
    			        System.out.println(total);
    			    }

    			}
</code></pre>
</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0">数据库连接池</a>
<ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5">1. 概念：</a></li>
<li><a href="#2-%E5%A5%BD%E5%A4%84">2. 好处：</a></li>
<li><a href="#3-%E5%AE%9E%E7%8E%B0">3. 实现：</a></li>
<li><a href="#4-c3p0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%8A%80%E6%9C%AF">4. C3P0：数据库连接池技术</a></li>
<li><a href="#5-druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E7%94%B1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%8F%90%E4%BE%9B%E7%9A%84">5. Druid：数据库连接池实现技术，由阿里巴巴提供的</a></li>
</ul>
</li>
<li><a href="#spring-jdbc">Spring JDBC</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://bgst009.github.io/post/汇编语言-端口/">
              <h3 class="post-title">
                汇编语言-端口
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://bgst009.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
