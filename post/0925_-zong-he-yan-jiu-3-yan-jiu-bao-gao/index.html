<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> 0925_综合研究3研究报告 | Gridea</title>
<link rel="shortcut icon" href="https://bgst009.github.io//favicon.ico?v=1611835942733">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://bgst009.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title=" 0925_综合研究3研究报告 | Gridea - Atom Feed" href="https://bgst009.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="研究1
摘要

用debug对一下程序编译链接后的代码进行研究

unsigned int n;
void f1();
int f2(int, int);
void far f3();

main() {
    n = 0;
    f1..." />
    <meta name="keywords" content="C" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://bgst009.github.io/">
  <img class="avatar" src="https://bgst009.github.io//images/avatar.png?v=1611835942733" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
               0925_综合研究3研究报告
            </h2>
            <div class="post-info">
              <span>
                2020-09-25
              </span>
              <span>
                14 min read
              </span>
              
                <a href="https://bgst009.github.io/tag/f9uwaThCs/" class="post-tag">
                  # C
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="研究1">研究1</h2>
<h3 id="摘要">摘要</h3>
<blockquote>
<p>用<code>debug</code>对一下程序编译链接后的代码进行研究</p>
</blockquote>
<pre><code class="language-c">unsigned int n;
void f1();
int f2(int, int);
void far f3();

main() {
    n = 0;
    f1();
    n = f2(1, 2);
    f3();
}

void f1() {
    n = 1;
}
int f2(int a, int b) {
    int c;
    c = a + b;
    return c;
}

void far f3() {
    n = 10;
}
</code></pre>
<h3 id="问题">问题</h3>
<ol>
<li>程序运行时n、a、b、c的段地在哪个存器中？</li>
<li>全局变量的存空间在什么段里？局都量的储空间在什么段里？参数的存储空间在什么段里？函数的返回在什么地方？</li>
<li>全局变量的存空间在什么时候分配？什么时候释？</li>
<li>局部变量的存空间在什么时候分配？什么时候释？</li>
<li>参数的存储空间在什么时候分配？什么时候释？</li>
<li>函数3在调用与返回方式上与函数与2有何不同？</li>
</ol>
<h3 id="研究过程">研究过程</h3>
<ul>
<li>
<p>首先通过<code>TCC</code>编译链接生成汇编文件</p>
<pre><code class="language-assembly">	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &quot;\src\three.c&quot;
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP ;数据段地址和栈段地址为同一块内存空间
_TEXT	ends
_DATA	segment word public 'DATA'
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public 'BSS'
b@	label	byte
b@w	label	word
	?debug	C E9826239510C5C7372635C74687265652E63
_BSS	ends
_TEXT	segment	byte public 'CODE'
;	?debug	L 10
_main	proc	near
;	?debug	L 11
	mov	word ptr DGROUP:_n,0 ;变量n
;	?debug	L 12
	call	near ptr _f1
;	?debug	L 13
	mov	ax,2
	push	ax
	mov	ax,1
	push	ax
	call	near ptr _f2
	pop	cx
	pop	cx
	mov	word ptr DGROUP:_n,ax
;	?debug	L 14
	call	far ptr _f3
@1:
;	?debug	L 15
	ret	
_main	endp
;	?debug	L 17
_f1	proc	near
;	?debug	L 17
	mov	word ptr DGROUP:_n,1
@2:
;	?debug	L 17
	ret	
_f1	endp
;	?debug	L 18
_f2	proc	near
	push	bp
	mov	bp,sp
	push	si
;	?debug	L 20
	mov	si,word ptr [bp+4]
	add	si,word ptr [bp+6]
;	?debug	L 21
	mov	ax,si
	jmp	short @3
@3:
;	?debug	L 22
	pop	si
	pop	bp
	ret	
_f2	endp
;	?debug	L 24
_f3	proc	far
;	?debug	L 24
	mov	word ptr DGROUP:_n,10
@4:
;	?debug	L 24
	ret	
_f3	endp
_TEXT	ends
_BSS	segment word public 'BSS'
_n	label	word
	db	2 dup (?)
_BSS	ends
	?debug	C E9
_DATA	segment word public 'DATA'
s@	label	byte
_DATA	ends
_TEXT	segment	byte public 'CODE'
_TEXT	ends
	public	_main
	public	_n
	public	_f3
	public	_f2
	public	_f1
	end

</code></pre>
</li>
<li>
<p>观察汇编代码可以发现变量<code>n</code>的段地址寄存器为<code>ds</code>，而<code>a</code>,<code>b</code>的段地址寄存器为<code>ss</code>，<s><code>c</code>的段地址寄存器为<code>cs</code>。</s>，<code>c</code>的段地址寄存器为<code>ss</code></p>
</li>
<li>
<p>在此程序中<code>n</code>为全局变量并且存放在数据段中故全局变量存放在数据段中。<code>a,b</code>为参数存放在栈中过参数存放在栈中，</p>
</li>
<li>
<p>全局变量的存储空间在编译的时候就分配好有多大然后在执行可执行文件时在分配内存。</p>
</li>
<li>
<p>局部变量在程序执行过程中用到的时候在分配 ，</p>
</li>
<li>
<p>参数在给函数传递前分配空间。</p>
</li>
<li>
<p><code>f3</code>和<code>f2</code>的调用方式可以通过汇编代码观察到<code>call	far ptr _f3</code>和<code>call	near ptr _f2</code>一个是<code>call	fa</code>一个是``	call	near<code>而 返回时</code>f2<code>先进行栈恢复然后在返回，</code>f3`直接返回不进行栈恢复。</p>
</li>
</ul>
<blockquote>
<p>研究全部完成后，可以回答第2个问题</p>
</blockquote>
<ul>
<li>全局变量存储在数据段中</li>
<li>局部变量存储在栈中</li>
<li>参数存储在栈中</li>
<li>返回值存储在寄存器中或者数据段中</li>
</ul>
<h2 id="研究2">研究2</h2>
<h3 id="摘要-2">摘要</h3>
<pre><code class="language-C">void f(void);
main() {
    f();
    f();
}
void f(void) {
    int n = 0;
    static int a = 0;
    n++;
    a++;
    printf(&quot;  %d  %d\n&quot;, n, a);
}
</code></pre>
<h3 id="问题-2">问题</h3>
<ul>
<li>变量 <code>n</code> 与<code>a</code>的存储空间分配方式何不同？</li>
</ul>
<h3 id="研究过程-2">研究过程</h3>
<ul>
<li>
<p>通过<code>tcc</code>生成汇编文件。</p>
<pre><code class="language-assembly">	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &quot;\src\three2.c&quot;
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public 'BSS'
b@	label	byte
b@w	label	word
	?debug	C E9A96A39510D5C7372635C7468726565322E63
_BSS	ends
_TEXT	segment	byte public 'CODE'
;	?debug	L 2
_main	proc	near
;	?debug	L 3
	call	near ptr _f
;	?debug	L 4
	call	near ptr _f
@1:
;	?debug	L 5
	ret	
_main	endp
_TEXT	ends
_DATA	segment word public 'DATA'
	dw	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
;	?debug	L 6
_f	proc	near
	push	si
;	?debug	L 7
	xor	si,si
;	?debug	L 9
	inc	si
;	?debug	L 10
	inc	word ptr DGROUP:d@
;	?debug	L 11
	push	word ptr DGROUP:d@
	push	si
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	add	sp,6
@2:
;	?debug	L 12
	pop	si
	ret	
_f	endp
_TEXT	ends
	?debug	C E9
_DATA	segment word public 'DATA'
s@	label	byte
	db	32
	db	32
	db	37
	db	100
	db	32
	db	32
	db	37
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
_TEXT	ends
	public	_main
	public	_f
	end

</code></pre>
</li>
<li>
<p>观察可以发现<code>n</code>时局部变量分配在栈空间中而<code>a</code>分配在数据段中</p>
</li>
</ul>
<h2 id="研究3">研究3</h2>
<h3 id="摘要-3">摘要</h3>
<pre><code class="language-c">unsigned int a = 1;
unsigned int b = 1;
unsigned char c = 1;
unsigned int a1 = 1;
unsigned long a2 = 1;

main() {
    a++;
    b++;
    c++;
    a1++;
    a2++;
}
</code></pre>
<h3 id="问题-3">问题</h3>
<ol>
<li>程序中所有变量的存储空间相邻吗?tc2.0中，整型、字符型、长整型数据的存储空<br>
间分别为多大？</li>
<li>不同的数据类型对数据运算方式的有何影响？</li>
</ol>
<h3 id="研究过程-3">研究过程</h3>
<ul>
<li>
<p>通过<code>tcc</code>生成<code>asm</code>文件</p>
<pre><code class="language-assembly">	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &quot;\src\three3.c&quot;
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public 'BSS'
b@	label	byte
b@w	label	word
	?debug	C E9496C39510D5C7372635C7468726565332E63
_BSS	ends
_DATA	segment word public 'DATA'
_a	label	word
	dw	1
_b	label	word
	dw	1
_c	label	byte
	db	1
_a1	label	word
	dw	1
_a2	label	word
	dw	1
	dw	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
;	?debug	L 7
_main	proc	near
;	?debug	L 8
	inc	word ptr DGROUP:_a
;	?debug	L 9
	inc	word ptr DGROUP:_b
;	?debug	L 10
	inc	byte ptr DGROUP:_c
;	?debug	L 11
	inc	word ptr DGROUP:_a1
;	?debug	L 12
	add	word ptr DGROUP:_a2,1
	adc	word ptr DGROUP:_a2+2,0
@1:
;	?debug	L 13
	ret	
_main	endp
_TEXT	ends
	?debug	C E9
_DATA	segment word public 'DATA'
s@	label	byte
_DATA	ends
_TEXT	segment	byte public 'CODE'
_TEXT	ends
	public	_main
	public	_c
	public	_b
	public	_a
	public	_a2
	public	_a1
	end

</code></pre>
</li>
<li>
<p>通过汇编代码可以发现只有长整型的运算方式是和其余数据类型的运算方式有所不同，长整型的运算方式为带进位的加法</p>
</li>
<li>
<p>通过汇编代码可以看出，整型的存储空间为一个字，字符型的存储空间为一个字节，长整型的存储空间为两个字大小。</p>
</li>
<li>
<p>修改程序然后生成可执行文件</p>
<ul>
<li>
<p>修改后将数据改成易辨识的数据（1，2，3，4，5）</p>
<pre><code class="language-c">unsigned int a = 1;
unsigned int b = 2;
unsigned char c = 3;
unsigned int a1 = 4;
unsigned long a2 = 5;

main() {
    a++;
    b++;
    c++;
    a1++;
    a2++;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>通过debug来进行查看变量的存储空间是否相邻</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925135108.png" alt="image-20200925135108549" loading="lazy"></figure>
</li>
<li>
<p>从图中可以看出存储空间依次相邻</p>
</li>
</ul>
<h2 id="研究4">研究4</h2>
<h3 id="摘要-4">摘要</h3>
<pre><code class="language-c">/*定义一个结构体类型stu，这个结构体类型描述一个学生的成绩。其中包括
    : 学号（整型）、C、Os、masm三门课程的成绩（字符型）*/
struct stu {
    int number;
    char c;
    char os;
    char masm;
};
/*注意，在实际程序设计中，程序员往往需要定义新的数据类型来对数据进行抽象。C语言支持用基本的数据类型如“char”、“int”等等来构造新的更为复杂的数据类型。

“整型”这一数据类型的名称为“int”:“字符型这一数据类型的名称为“char”:
以上定义了一个 新的数据类型“struct stu”，这个数据类型的名称为“stu

structstu型数据包括4个数据项 : number、c、os、masm*/

struct stu a; /*定义一个struct stu型的变量a*/

main() {
    /*定义一个struct stu型的变量b*/
    struct stu b;

    a.number = 1;
    a.c = 80;
    a.os = 82;
    a.masm = 88;

    b.number = 2;
    b.c = 90;
    b.os = 92;
    b.masm = 98;

    printf(&quot;number c  os masm\n&quot;);
    printf(&quot;-----------------\n&quot;);

    printf(&quot;%d     %d  %d  %d\n&quot;, a.number, a.c, a.os, a.masm);
    printf(&quot;%d     %d  %d  %d\n&quot;, b.number, b.c, b.os, b.masm);
}
</code></pre>
<h3 id="问题-4">问题</h3>
<ul>
<li>变量<code>a</code>，<code>b</code>和他们的各个数据项的存储空间如何分配</li>
</ul>
<h3 id="研究过程-4">研究过程</h3>
<ul>
<li>
<p>将程序通过<code>tcc</code>生成汇编文件</p>
<pre><code class="language-assembly">	ifndef	??version
?debug	macro
	endm
	endif
	?debug	S &quot;\src\three4.c&quot;
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
d@	label	byte
d@w	label	word
_DATA	ends
_BSS	segment word public 'BSS'
b@	label	byte
b@w	label	word
	?debug	C E9127239510D5C7372635C7468726565342E63
_BSS	ends
_TEXT	segment	byte public 'CODE'
;	?debug	L 18
_main	proc	near
	push	bp
	mov	bp,sp
	sub	sp,6
;	?debug	L 22
	mov	word ptr DGROUP:_a,1
;	?debug	L 23
	mov	byte ptr DGROUP:_a+2,80
;	?debug	L 24
	mov	byte ptr DGROUP:_a+3,82
;	?debug	L 25
	mov	byte ptr DGROUP:_a+4,88
;	?debug	L 27
	mov	word ptr [bp-6],2
;	?debug	L 28
	mov	byte ptr [bp-4],90
;	?debug	L 29
	mov	byte ptr [bp-3],92
;	?debug	L 30
	mov	byte ptr [bp-2],98
;	?debug	L 32
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	pop	cx
;	?debug	L 33
	mov	ax,offset DGROUP:s@+19
	push	ax
	call	near ptr _printf
	pop	cx
;	?debug	L 35
	mov	al,byte ptr DGROUP:_a+4
	cbw	
	push	ax
	mov	al,byte ptr DGROUP:_a+3
	cbw	
	push	ax
	mov	al,byte ptr DGROUP:_a+2
	cbw	
	push	ax
	push	word ptr DGROUP:_a
	mov	ax,offset DGROUP:s@+38
	push	ax
	call	near ptr _printf
	add	sp,10
;	?debug	L 36
	mov	al,byte ptr [bp-2]
	cbw	
	push	ax
	mov	al,byte ptr [bp-3]
	cbw	
	push	ax
	mov	al,byte ptr [bp-4]
	cbw	
	push	ax
	push	word ptr [bp-6]
	mov	ax,offset DGROUP:s@+57
	push	ax
	call	near ptr _printf
	add	sp,10
@1:
;	?debug	L 37
	mov	sp,bp
	pop	bp
	ret	
_main	endp
_TEXT	ends
_BSS	segment word public 'BSS'
_a	label	word
	db	5 dup (?)
_BSS	ends
	?debug	C E9
_DATA	segment word public 'DATA'
s@	label	byte
	db	110
	db	117
	db	109
..........
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
_TEXT	ends
	public	_main
	public	_a
	end

</code></pre>
</li>
<li>
<p>观察汇编文件可以发现，变量<code>a</code>，<code>b</code>的各个数据项的存储空间是连续分配的不过<code>a</code>是在数据段中而<code>b</code>是在栈中，而变量a和b是存储的该变量的初始地址</p>
</li>
</ul>
<h2 id="研究5">研究5</h2>
<h3 id="摘要-5">摘要</h3>
<pre><code class="language-c">struct n {
    int a;
    int b;
    int c;
};

int f(struct n);

struct n func(void);

main() {
    struct n a;
    int b;

    a = func();
    b = f(a);

    printf(&quot; %d&quot;, b);
    printf(&quot; %d&quot;, f(func()));
}

int f(struct n a) { return (a.a + a.b) * a.c; }

struct n func(void) {
    struct n a;
    a.a = 1;
    a.b = 2;
    a.c = 3;
    return a;
}
</code></pre>
<h3 id="问题-5">问题</h3>
<ul>
<li>向函数传递结构体型数据是如何实现的？</li>
<li>从函数返回的结构体型数据存储在何处？</li>
</ul>
<h3 id="研究过程-5">研究过程</h3>
<ul>
<li>
<p>要探讨结构体是如何返回的，那么首先应该观察执行函数前后有什么变化。我们开始执行到调用func的汇编语句的前一句然后在执行到后一句观察寄存器的值的变化</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925151809.png" alt="image-20200925151809779" loading="lazy"></figure>
<ul>
<li>
<p>发现ax的值发生变化然后看对应数据段中的数据，发现从函数返回的结构体型数据存储在数据段中</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925152304.png" alt="image-20200925152304087" loading="lazy"></figure>
</li>
<li>
<p>所以从函数返回的结构体型数据存储在数据段中。</p>
</li>
</ul>
</li>
<li>
<p>对于第一个问题向函数传递结构体型数据是如何实现的？</p>
<ol>
<li>
<p>首先观察<code>b = f(a);</code>对应的汇编代码</p>
<pre><code class="language-assembly">;	?debug	L 16
	lea	bx,word ptr [bp-6]
	mov	dx,ss
	mov	ax,bx
	mov	cx,6
	call	far ptr SPUSH@
	call	near ptr _f
	add	sp,6
	mov	si,ax
</code></pre>
</li>
<li>
<p>可以看到在执行<code>call	near ptr _f</code>前先执行了<code>call	far ptr SPUSH@</code>根据名字猜测应该是往栈里吗压入 一些数据，接下来在<code>debug</code>中检验猜测是否正确</p>
</li>
<li>
<p>观察到执行完<code>call	far ptr SPUSH@</code>前后寄存器<code>sp</code>的值发生了改变然后观察栈中的数据可以看到把结构体中的数据压入到栈中(<code>ss:ffce</code>)。然后接下来进入<code>_f</code>中看是否使用了栈中压入的数据</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925153742.png" alt="image-20200925153742447" loading="lazy"></figure>
</li>
<li>
<p>在进入后执行到<code>mov bp,sp</code> 后可以发现确实使用了栈中压入的数据（<code>ss:ffce</code>）</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/bgst009/markdownPicUrl/raw/master/20200925154430.png" alt="image-20200925154430806" loading="lazy"></figure>
</li>
<li>
<p>到此就可以回答了，函数是通过栈来传递结构体的</p>
</li>
</ol>
</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>变量无非就是存储在栈中或者数据段中，如果变量需要长期存在或者要返回那么会将变量存储在数据段中，而如过仅仅只需在函数中存在或者传递参数就需要将数据保存在栈中。</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%A0%94%E7%A9%B61">研究1</a>
<ul>
<li><a href="#%E6%91%98%E8%A6%81">摘要</a></li>
<li><a href="#%E9%97%AE%E9%A2%98">问题</a></li>
<li><a href="#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B">研究过程</a></li>
</ul>
</li>
<li><a href="#%E7%A0%94%E7%A9%B62">研究2</a>
<ul>
<li><a href="#%E6%91%98%E8%A6%81-2">摘要</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-2">问题</a></li>
<li><a href="#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-2">研究过程</a></li>
</ul>
</li>
<li><a href="#%E7%A0%94%E7%A9%B63">研究3</a>
<ul>
<li><a href="#%E6%91%98%E8%A6%81-3">摘要</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-3">问题</a></li>
<li><a href="#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-3">研究过程</a></li>
</ul>
</li>
<li><a href="#%E7%A0%94%E7%A9%B64">研究4</a>
<ul>
<li><a href="#%E6%91%98%E8%A6%81-4">摘要</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-4">问题</a></li>
<li><a href="#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-4">研究过程</a></li>
</ul>
</li>
<li><a href="#%E7%A0%94%E7%A9%B65">研究5</a>
<ul>
<li><a href="#%E6%91%98%E8%A6%81-5">摘要</a></li>
<li><a href="#%E9%97%AE%E9%A2%98-5">问题</a></li>
<li><a href="#%E7%A0%94%E7%A9%B6%E8%BF%87%E7%A8%8B-5">研究过程</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://bgst009.github.io/post/0924_-zong-he-yan-jiu-2-yan-jiu-bao-gao/">
              <h3 class="post-title">
                 0924_综合研究2研究报告
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://bgst009.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
