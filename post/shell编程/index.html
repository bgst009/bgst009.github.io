<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>shell编程 | Gridea</title>
<link rel="shortcut icon" href="https://bgst009.github.io//favicon.ico?v=1611835701765">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://bgst009.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="shell编程 | Gridea - Atom Feed" href="https://bgst009.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="shell编程
编写简单的脚本
例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：
[root@linuxprobe ~]# vim example.sh
#!/bin/bash 
..." />
    <meta name="keywords" content="shell编程" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://bgst009.github.io/">
  <img class="avatar" src="https://bgst009.github.io//images/avatar.png?v=1611835701765" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              shell编程
            </h2>
            <div class="post-info">
              <span>
                2020-02-13
              </span>
              <span>
                26 min read
              </span>
              
                <a href="https://bgst009.github.io/tag/cwvOdNjtLD/" class="post-tag">
                  # shell编程
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="shell编程">shell编程</h1>
<h2 id="编写简单的脚本"><strong>编写简单的脚本</strong></h2>
<p>例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# vim example.sh
#!/bin/bash 
#For Example BY linuxprobe.com 
pwd 
ls -al
</code></pre>
<ul>
<li>
<p>​	Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上</p>
</li>
<li>
<p>第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本</p>
</li>
<li>
<p>第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息</p>
</li>
<li>
<p>第三、四行的可执行语句也就是我们平时执行的Linux命令了</p>
</li>
<li>
<p>bash xxxxx.sh <em>执行</em></p>
</li>
</ul>
<h2 id="接收用户的参数"><strong>接收用户的参数</strong></h2>
<p>但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板了。为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。</p>
<p>其实，Linux系统中的Shell脚本语言早就考虑到了这些，已经内设了用于接收参数的变量，变量之间可以使用空格间隔。例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">对</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">前</mi><mi>S</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">脚</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">称</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">0对应的是当前Shell脚本程序的名称，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">前</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">脚</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">名</span><span class="mord cjk_fallback">称</span><span class="mord cjk_fallback">，</span></span></span></span>#对应的是总共有几个参数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mi mathvariant="normal">对</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">*对应的是所有位置的参数值，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span></span></span></span>?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第N个位置的参数值，如图4-15所示。</p>
<figure data-type="image" tabindex="1"><img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/Shell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE%E5%8F%98%E9%87%8F.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></figure>
<p>图4-15  Shell脚本程序中的参数位置变量</p>
<p>理论过后我们来练习一下。尝试编写一个脚本程序示例，通过引用上面的变量参数来看下真实效果：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo &quot;当前脚本名称为$0&quot;
echo &quot;总共有$#个参数，分别是$*。&quot;
echo &quot;第1个参数为$1，第5个为$5。&quot;
[root@linuxprobe ~]# sh example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。
</code></pre>
<h2 id="判断用户的参数"><strong>判断用户的参数</strong></h2>
<p>在本书前面章节中讲到，系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。条件测试语法的执行格式如图4-16所示。切记，条件表达式两边均应有一个空格。</p>
<figure data-type="image" tabindex="2"><img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%E6%A0%BC%E5%BC%8F.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></figure>
<p>图4-16  条件测试语句的执行格式</p>
<hr>
<p>按照测试对象来划分，条件测试语句可以分为4种：</p>
<blockquote>
<p>文件测试语句；</p>
<p>逻辑测试语句；</p>
<p>整数值比较语句；</p>
<p>字符串比较语句。</p>
</blockquote>
<p>文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表4-3所示。</p>
<p>表4-3                                                    文件测试所用的参数</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>测试文件是否为目录类型</td>
</tr>
<tr>
<td>-e</td>
<td>测试文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>判断是否为一般文件</td>
</tr>
<tr>
<td>-r</td>
<td>测试当前用户是否有权限读取</td>
</tr>
<tr>
<td>-w</td>
<td>测试当前用户是否有权限写入</td>
</tr>
<tr>
<td>-x</td>
<td>测试当前用户是否有权限执行</td>
</tr>
</tbody>
</table>
<p>下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着目录不存在：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1
</code></pre>
<p>再使用文件测试语句来判断/etc/fstab是否为一般文件，如果返回值为0，则代表文件存在，且为一般文件：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# [ -f /etc/fstab ]
[root@linuxprobe ~]# echo $?
0
</code></pre>
<p>逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&amp;&amp;，<strong>它表示当前面的命令执行成功后才会执行它后面的命令</strong>，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。</p>
<pre><code class="language-bash">[root@linuxprobe ~]# [ -e /dev/cdrom ] &amp;&amp; echo &quot;Exist&quot;
Exist
</code></pre>
<p>除了逻辑“与”外，还有逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的<strong>命令执行失败后才会执行它后面的命令</strong>，因此可以用来结合系统环境变量USER来判断当前登录的用户是否为非管理员身份：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# echo $USER
root
[root@linuxprobe ~]# [ $USER = root ] || echo &quot;user&quot;
[root@linuxprobe ~]# su - linuxprobe 
[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo &quot;user&quot;
user
</code></pre>
<p>第三种逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果则将其变成正确的。</p>
<p>我们现在切换回到root管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：</p>
<pre><code class="language-bash">[linuxprobe@linuxprobe ~]$ exit
logout
[root@linuxprobe root]# [ $USER != root ] || echo &quot;administrator&quot;
administrator
</code></pre>
<p>就技术图书的写作来讲，一般有两种套路：让读者真正搞懂技术了；让读者觉得自己搞懂技术了。因此市面上很多浅显的图书会让读者在学完之后感觉进步特别快，这基本上是作者有意为之，目的就是让您觉得“图书很有料，自己收获很大”，但是在步入工作岗位后就露出短板吃大亏。所以刘遄老师决定继续提高难度，为读者增加一个综合的示例，一方面作为前述知识的总结，另一方面帮助读者夯实基础，能够在今后工作中更灵活地使用逻辑符号。</p>
<p>当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的USER变量名称是否等于root，然后用逻辑运算符“非”进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运算符输出user字样；或条件不满足则会通过逻辑“或”运算符输出root字样，而如果前面的&amp;&amp;不成立才会执行后面的||符号。</p>
<pre><code class="language-bash">[root@linuxprobe ~]# [ $USER != root ] &amp;&amp; echo &quot;user&quot; || echo &quot;root&quot;
root
</code></pre>
<hr>
<p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表4-4所示。</p>
<p>表4-4                                                  可用的整数比较运算符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>是否等于</td>
</tr>
<tr>
<td>-ne</td>
<td>是否不等于</td>
</tr>
<tr>
<td>-gt</td>
<td>是否大于</td>
</tr>
<tr>
<td>-lt</td>
<td>是否小于</td>
</tr>
<tr>
<td>-le</td>
<td>是否等于或小于</td>
</tr>
<tr>
<td>-ge</td>
<td>是否大于或等于</td>
</tr>
</tbody>
</table>
<p>接下来小试牛刀。我们先测试一下10是否大于10以及10是否等于10（通过输出的返回值内容来判断）：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?
1
[root@linuxprobe ~]# [ 10 -eq 10 ]
[root@linuxprobe ~]# echo $?
0
</code></pre>
<p>在2.4节曾经讲过free命令，它可以用来获取当前系统正在使用及可用的内存量信息。接下来先使用free -m命令查看内存使用量情况（单位为MB），然后通过grep Mem:命令过滤出剩余内存量的行，再用awk '{print $4}'命令只保留第四列，最后用FreeMem=<code>语句</code>的方式把语句内执行的结果赋值给变量。</p>
<p>这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。</p>
<pre><code class="language-bash">[root@linuxprobe ~]# free -m
            total     used     free     shared     buffers     cached
Mem:        1826      1244     582      9          1           413
-/+ buffers/cache:    830 996
Swap:       2047      0        2047
[root@linuxprobe ~]# free -m | grep Mem:
Mem:        1826      1244     582      9 
[root@linuxprobe ~]# free -m | grep Mem: | awk '{print $4}'
582
[root@linuxprobe ~]# FreeMem=`free -m | grep Mem: | awk '{print $4}'`
[root@linuxprobe ~]# echo $FreeMem 
582
</code></pre>
<p>上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于1024，若小于则会提示“Insufficient Memory”（内存不足）的字样：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# [ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;Insufficient Memory&quot;
Insufficient Memory
</code></pre>
<p><code>字符串</code>比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表4-5所示。</p>
<p>表4-5                                                常见的字符串比较运算符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>比较字符串内容是否相同</td>
</tr>
<tr>
<td>!=</td>
<td>比较字符串内容是否不同</td>
</tr>
<tr>
<td>-z</td>
<td>判断字符串内容是否为空</td>
</tr>
</tbody>
</table>
<p>接下来通过判断String变量是否为空值，进而判断是否定义了这个变量：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# [ -z $String ]
[root@linuxprobe ~]# echo $?
0
</code></pre>
<p>再尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值LANG不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# echo $LANG
en_US.UTF-8
[root@linuxprobe ~]# [ $LANG != &quot;en.US&quot; ] &amp;&amp; echo &quot;Not en.US&quot;
Not en.US
</code></pre>
<h2 id="流程控制语句"><strong>流程控制语句</strong></h2>
<ul>
<li>if、for、while、case这4种流程控制语句来学习编写难度更大、功能更强的Shell脚本。</li>
</ul>
<h3 id="if条件测试语句"><strong>if条件测试语句</strong></h3>
<p>if条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。</p>
<p>if条件语句的单分支结构由if、then、fi关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的if语句属于最简单的一种条件判断结构，语法格式如图4-17所示。<br>
<img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8D%95%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-2.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></p>
<p>图4-17  单分支的if语句</p>
<p>下面使用单分支的if条件语句来判断/media/cdrom文件是否存在，若存在就结束条件判断和整个Shell脚本，反之则去创建这个目录：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# vim mkcdrom.sh
#!/bin/bash
DIR=&quot;/media/cdrom&quot;
if [ ! -e $DIR ]
then
mkdir -p $DIR
fi
</code></pre>
<p>由于第5章才讲解用户身份与权限，因此这里继续用“bash 脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用ls命令验证/media/cdrom目录是否已经成功创建：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# bash mkcdrom.sh
[root@linuxprobe ~]# ls -d /media/cdrom
/media/cdrom
</code></pre>
<hr>
<p>if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if条件语句的双分支结构也是一种很简单的判断结构，语法格式如图4-18所示。</p>
<figure data-type="image" tabindex="3"><img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%8F%8C%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-1.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></figure>
<p>图4-18 双分支的if条件语句</p>
<p>下面使用双分支的if条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用ping命令来测试与对方主机的网络联通性，而Linux系统中的ping命令不像Windows一样尝试4次就结束，因此为了避免用户等待时间过长，需要通过-c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。</p>
<pre><code class="language-bash">[root@linuxprobe ~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/null
if [ $? -eq 0 ]
then
echo &quot;Host $1 is On-line.&quot;
else
echo &quot;Host $1 is Off-line.&quot;
fi
</code></pre>
<p>我们在4.2.3小节中用过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>?</mo><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">命</mi><mi mathvariant="normal">令</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">返</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">若</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">条</mi><mi mathvariant="normal">语</mi><mi mathvariant="normal">句</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">则</mi></mrow><annotation encoding="application/x-tex">?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">?</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">返</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">若</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">语</span><span class="mord cjk_fallback">句</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span></span></span></span>?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为0，从而获知那条语句的最终判断情况。这里的服务器IP地址为192.168.10.10，我们来验证一下脚本的效果：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
[root@linuxprobe ~]# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.
</code></pre>
<p>if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图4-19所示。<img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/%E5%A4%9A%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-2.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></p>
<p>图 4-19 多分支的if条件语句</p>
<p>下面使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如Excellent、Pass、Fail等提示信息。在Linux系统中，read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于向用户显示一定的提示信息。在下面的脚本示例中，只有当用户输入的分数大于等于85分且小于等于100分，才输出Excellent字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于70分且小于等于84分，如果是，则输出Pass字样；若两次都落空（即两次的匹配操作都失败了），则输出Fail字样：</p>
<pre><code class="language-bash">[root@linuxprobe ~]# vim chkscore.sh
#!/bin/bash
read -p &quot;Enter your score（0-100）：&quot; GRADE
if [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ] ; then
echo &quot;$GRADE is Excellent&quot;
elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -le 84 ] ; then
echo &quot;$GRADE is Pass&quot;
else
echo &quot;$GRADE is Fail&quot; 
fi
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
[root@linuxprobe ~]# bash chkscore.sh 
Enter your score（0-100）：80
80 is Pass
</code></pre>
<p>下面执行该脚本。当用户输入的分数分别为30和200时，其结果如下：</p>
<pre><code class="language-shell">[root@linuxprobe ~]# bash chkscore.sh  
Enter your score（0-100）：30
30 is Fail
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：200 
200 is Fail
</code></pre>
<p>为什么输入的分数为200时，依然显示Fail呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于100或小于0的分数时，给予Error报错字样的提示。</p>
<h3 id="for条件循环语句"><strong>for条件循环语句</strong></h3>
<p>or循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用for循环语句再适合不过了。for循环语句的语法格式如图4-20所示。</p>
<figure data-type="image" tabindex="4"><img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/for%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></figure>
<p>图4-20  for循环语句的语法格式</p>
<p>下面使用for循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数：</p>
<pre><code class="language-shell">[root@linuxprobe ~]# vim users.txt
andy
barry
carl
duke
eric
george
</code></pre>
<p>接下来编写Shell脚本Example.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id 用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。</p>
<p>需要多说一句，/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。</p>
<pre><code class="language-shell">[root@linuxprobe ~]# vim Example.sh
#!/bin/bash
read -p &quot;Enter The Users Password : &quot; PASSWD
for UNAME in `cat users.txt`
do
id $UNAME &amp;&gt; /dev/null
if [ $? -eq 0 ]
then
echo &quot;Already exists&quot;
else
useradd $UNAME &amp;&gt; /dev/null
echo &quot;$PASSWD&quot; | passwd --stdin $UNAME &amp;&gt; /dev/null
if [ $? -eq 0 ]
then
echo &quot;$UNAME , Create success&quot;
else
echo &quot;$UNAME , Create failure&quot;
fi
fi
done
</code></pre>
<p>执行批量创建用户的Shell脚本Example.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后不会有其他内容。</p>
<p>在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。</p>
<pre><code class="language-shell">[root@linuxprobe ~]# bash Example.sh
Enter The Users Password : linuxprobe
andy , Create success
barry , Create success
carl , Create success
duke , Create success
eric , Create success
george , Create success
[root@linuxprobe ~]# tail -6 /etc/passwd
andy:x:1001:1001::/home/andy:/bin/bash
barry:x:1002:1002::/home/barry:/bin/bash
carl:x:1003:1003::/home/carl:/bin/bash
duke:x:1004:1004::/home/duke:/bin/bash
eric:x:1005:1005::/home/eric:/bin/bash
george:x:1006:1006::/home/george:/bin/bash
</code></pre>
<p>您还记得在学习双分支if条件语句时，用到的那个测试主机是否在线的脚本么？既然我们现在已经掌握了for循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。</p>
<p>首先创建一个主机列表文件ipadds.txt：</p>
<pre><code class="language-shell">[root@linuxprobe ~]# vim ipadds.txt
192.168.10.10
192.168.10.11
192.168.10.12
</code></pre>
<p>然后前面的双分支if条件语句与for循环语句相结合，让脚本从主机列表文件ipadds.txt中自动读取IP地址（用来表示主机）并将其赋值给HLIST变量，从而通过判断ping命令执行后的返回值来逐个测试主机是否在线。脚本中出现的$（命令）是一种完全类似于第3章的转义字符中反引号<code>命令</code>的Shell操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：</p>
<pre><code class="language-shell">[root@linuxprobe ~]# vim CheckHosts.sh
#!/bin/bash
HLIST=$(cat ~/ipadds.txt)
for IP in $HLIST
do
ping -c 3 -i 0.2 -W 3 $IP &amp;&gt; /dev/null
if [ $? -eq 0 ] ; then
echo &quot;Host $IP is On-line.&quot;
else
echo &quot;Host $IP is Off-line.&quot;
fi
done
[root@linuxprobe ~]# ./CheckHosts.sh
Host 192.168.10.10 is On-line.
Host 192.168.10.11 is Off-line.
Host 192.168.10.12 is Off-line.
</code></pre>
<h3 id="while条件循环语句"><strong>while条件循环语句</strong></h3>
<p>while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while语句的语法格式如图4-21所示。<img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/while%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></p>
<p>图4-21  while循环语句的语法格式</p>
<p>接下来结合使用多分支的if条件测试语句与while条件循环语句，编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们当前要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，这两者相等之后才运行exit 0命令，终止脚本的执行。</p>
<pre><code class="language-shell">[root@linuxprobe ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo &quot;商品实际价格为0-999之间，猜猜看是多少？&quot;
while true
do
read -p &quot;请输入您猜测的价格数目：&quot; INT
let TIMES++
if [ $INT -eq $PRICE ] ; then
echo &quot;恭喜您答对了，实际价格是 $PRICE&quot;
echo &quot;您总共猜测了 $TIMES 次&quot;
exit 0
elif [ $INT -gt $PRICE ] ; then
echo &quot;太高了！&quot;
else
echo &quot;太低了！&quot;
fi
done
</code></pre>
<p>在这个Guess.sh脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到let TIMES++命令时都会让TIMES变量内的数值加1，用来统计循环总计执行了多少次。这可以让用户得知总共猜测了多少次之后，才猜对价格。</p>
<pre><code class="language-shell">[root@linuxprobe ~]# bash Guess.sh
商品实际价格为0-999之间，猜猜看是多少？
请输入您猜测的价格数目：500
太低了！
请输入您猜测的价格数目：800
太高了！
请输入您猜测的价格数目：650
太低了！
请输入您猜测的价格数目：720
太高了！
请输入您猜测的价格数目：690
太低了！
请输入您猜测的价格数目：700
太高了！
请输入您猜测的价格数目：695
太高了！
请输入您猜测的价格数目：692
太高了！
请输入您猜测的价格数目：691
恭喜您答对了，实际价格是 691
您总共猜测了 9 次
</code></pre>
<h3 id="case条件测试语句"><strong>case条件测试语句</strong></h3>
<p>如果您之前学习过C语言，看到这一小节的标题肯定会会心一笑“这不就是switch语句嘛！”是的，case条件测试语句和switch语句的功能非常相似！case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。case语句的语法结构如图4-22所示。</p>
<figure data-type="image" tabindex="5"><img src="https://www.linuxprobe.com/wp-content/uploads/2015/07/case%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1.png" alt="第4章 Vim编辑器与Shell命令脚本。第4章 Vim编辑器与Shell命令脚本。" loading="lazy"></figure>
<p>图4-22  case条件测试语句的语法结构</p>
<p>在前文介绍的Guess.sh脚本中有一个致命的弱点—只能接受数字！您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a是否大于等于3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。</p>
<p>通过在脚本中组合使用case条件测试语句和通配符（详见第3章），完全可以满足这里的需求。接下来我们编写脚本Checkkeys.sh，提示用户输入一个字符并将其赋值给变量KEY，然后根据变量KEY的值向用户显示其值是字母、数字还是其他字符。</p>
<pre><code class="language-shell">[root@linuxprobe ~]# vim Checkkeys.sh
#!/bin/bash
read -p &quot;请输入一个字符，并按Enter键确认：&quot; KEY
case &quot;$KEY&quot; in
[a-z]|[A-Z])
echo &quot;您输入的是 字母。&quot;
;;
[0-9])
echo &quot;您输入的是 数字。&quot;
;;
*)
echo &quot;您输入的是 空格、功能键或其他控制字符。&quot;
esac
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：6
您输入的是 数字。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：p
您输入的是 字母。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：^[[15~
您输入的是 空格、功能键或其他控制字符。
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#shell%E7%BC%96%E7%A8%8B">shell编程</a>
<ul>
<li><a href="#%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%9C%AC"><strong>编写简单的脚本</strong></a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E7%9A%84%E5%8F%82%E6%95%B0"><strong>接收用户的参数</strong></a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E7%9A%84%E5%8F%82%E6%95%B0"><strong>判断用户的参数</strong></a></li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><strong>流程控制语句</strong></a>
<ul>
<li><a href="#if%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5"><strong>if条件测试语句</strong></a></li>
<li><a href="#for%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><strong>for条件循环语句</strong></a></li>
<li><a href="#while%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><strong>while条件循环语句</strong></a></li>
<li><a href="#case%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5"><strong>case条件测试语句</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://bgst009.github.io/post/常用命令/">
              <h3 class="post-title">
                常用命令
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://bgst009.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
